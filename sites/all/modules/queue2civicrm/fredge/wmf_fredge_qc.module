<?php
use queue2civicrm\fredge\AntifraudQueueConsumer;
use SmashPig\Core\Configuration;
use SmashPig\Core\Context;

/**
 * Implements hook_menu
 */
function wmf_fredge_qc_menu() {
  $items[ 'admin/config/queue2civicrm/fredge_qc' ] = array(
    'title'            => 'fredge',
    'description'      => t('Configure fredge queue consumers'),
    'access arguments' => array( 'administer queue2civicrm' ),
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array( 'fredge_qc_settings' ),
  );
  return $items;
}

/**
 * Constructs the settings page for this module.
 *
 * @return array Of form components.
 */
function fredge_qc_settings() {
  $form = array();

  $form['fredge_qc_disable'] = array(
    '#type' => 'checkbox',
    '#title' => t('Disable payments-init job'),
    '#description' => t('If checked, no message processing will be performed for the payments-init queue.'),
    '#default_value' => variable_get('fredge_qc_disable', false),
  );

  $form['fredge_payments_init_queue'] = array(
    '#type' => 'textfield',
    '#title' => t('Payments-init subscription path'),
    '#required' => TRUE,
    '#default_value' => variable_get('fredge_payments_init_queue', '/queue/payments-init'),
    '#description' => t('Queue for payments-init items'),
  );

  $form['fredge_payments_antifraud_queue'] = array(
    '#type' => 'textfield',
    '#title' => t('Payments-antifraud queue name'),
    '#required' => TRUE,
    '#default_value' => variable_get('fredge_payments_antifraud_queue', 'payments-antifraud'),
    '#description' => t('Config key under data-store for payments-antifraud queue'),
  );
//  payments-antifraud

  $form['fredge_batch_time'] = array(
    '#type' => 'textfield',
    '#title' => t('Job time limit (in seconds)'),
    '#description' => t('Maximum elapsed duration of an fredge job, after which we will abort from the loop.  This can be used to set a reliable duty cycle for the job.  Either a time limit or batch size limit is required.'),
    '#required' => TRUE,
    '#default_value' => variable_get('fredge_batch_time', 90),
  );

  return system_settings_form($form);
}

/**
 * Callback from Drush that actually executes the loop for processing messages in the queue.
 * @ref fredge_process_message
 * @ref drush_fredge_queue_consume
 */
function fredge_batch_process() {
  watchdog('fredge', 'Executing: fredge_batch_process');

  civicrm_initialize();
  $config = new Configuration();
  Context::initWithLogger($config, 'fredge_batch_process');

  //Let's start with the simplest possible division of labor
  $cycle_time = variable_get('fredge_batch_time', 0) / 2;

  $processed = queue2civicrm_stomp()->dequeue_loop(
    variable_get('fredge_payments_init_queue', '/queue/payments-init'),
    false,
    $cycle_time,
    'fredge_payments_init_process_message'
  );

  $fraudQueueConsumer = new AntifraudQueueConsumer(
    variable_get('fredge_payments_antifraud_queue', 'payments-antifraud'),
    $cycle_time
  );

  $processed += $fraudQueueConsumer->dequeueMessages();

  if ($processed > 0) {
    watchdog('fredge', 'Successfully processed ' . $processed . ' fredge message(s).');
  }
  else {
    watchdog('fredge', 'No fredge messages processed.');
  }
}

/**
 * Processes an individual payments-init message.
 *
 * @param $msg A STOMP message class.
 *
 */
function fredge_payments_init_process_message($msg) {
  $txnid = $msg->headers['correlation-id'];
  watchdog('fredge', "Beginning processing of payments-init message for $txnid: " . json_encode($msg), array(), WATCHDOG_INFO);

  $body = json_decode($msg->body, TRUE);

  $id = 0;
  $inserting = true;

  $dbs = wmf_civicrm_get_dbs();
  $dbs->push('fredge');
  $query = 'SELECT id FROM payments_initial WHERE contribution_tracking_id = :ct_id AND order_id = :order_id LIMIT 1';
  $result = db_query( $query, array(
    ':ct_id' => $body['contribution_tracking_id'],
    ':order_id' => $body['order_id']
  ) );
  if ( $result->rowCount() === 1 ){
    $id = $result->fetch()->id;
    $inserting = false;
  }

  $data = fredge_prep_data($body, 'payments_initial', $txnid, $inserting);

  if ( $inserting ) {
    db_insert( 'payments_initial' )
      ->fields( $data )
      ->execute();
  } else {
    db_update( 'payments_initial' )
      ->fields( $data )
      ->condition( 'id', $id )
      ->execute();
  }
}

/**
 * Check a message against a table schema, and complain if it doesn't fit. Also
 * format date fields and discard fields with no matching column.
 * @param array $msg the array-converted message body
 * @param string $table the table you're trying to put $msg into
 * @param string $log_identifier Some small string for the log that will help id
 * the message if something goes amiss and we have to log about it.
 * @param bool $require_all if true, throw an exception on missing fields
 * @return array an array of the relevant fields, with dates in the right format
 * @throws FredgeDataValidationException
 */
function fredge_prep_data( $msg, $table, $log_identifier, $require_all = true ) {
  if ( !is_array($msg) || empty($msg) ){
    $error = "$log_identifier: Trying to insert nothing into $table. Dropping message on floor.";
    throw new FredgeDataValidationException( $error );
  }

  static $schemata = null;
  if (is_null($schemata)) {
    require_once('wmf_fredge_qc.install'); //annoyed I have to do this, but this seems the cleanest way from here
    $schemata = wmf_fredge_qc_get_current_schema();
    //and then, because we only care about the stuff we're inserting, remove the 'type' => 'serial' fields, because autonumber
    foreach ($schemata as $schema_table => $schema) {
      foreach ($schema['fields'] as $field => $definition) {
        if (isset($definition['type']) && $definition['type'] === 'serial') {
          unset($schemata[$schema_table]['fields'][$field]);
        }
      }
    }
  }

  $data = array();
  foreach ($schemata[$table]['fields'] as $field => $definition) {
    if (!array_key_exists($field, $msg)) {
      if ($require_all) {
        $error = "$log_identifier: Expected field $field bound for table $table not present! Dropping message on floor.";
        throw new FredgeDataValidationException( $error );
        //so... add fields to DI first when you do schema changes.
      }
    } else {
      //the field exists. Woot.
      // Check data length.
      if ( array_key_exists( 'length', $definition )
        && $definition['length'] < strlen( $msg[$field] )
      ) {
        $error = "$log_identifier: Data in field $field is too long! Dropping message on floor.";
        throw new FredgeDataValidationException( $error );
      }

      // Convert timestamps to native SQL format datetime.
      if (array_key_exists('mysql_type', $definition) && $definition['mysql_type'] === 'DATETIME') {
        $msg[$field] = wmf_common_date_unix_to_sql($msg[$field]);
      }
      $data[$field] = $msg[$field];
    }
  }
  return $data;
}

class FredgeDataValidationException extends WmfException {
    public function __construct( $message ) {
        // FIXME: other exception types are descriptive of the error,
        // not just its source module.  Make like the others.
        parent::__construct( 'fredge', $message );
    }
}
