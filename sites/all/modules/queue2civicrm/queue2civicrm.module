<?php
use queue2civicrm\DonationQueueConsumer;

// include common functions
require_once( drupal_get_path( 'module', 'queue2civicrm' ) . '/queue2civicrm_common.inc' );

/**
 * Implementation of hook_menu().
 */
function queue2civicrm_menu() {
  $items = array();

  $items['admin/config/queue2civicrm'] = array(
    'title' => 'Queue to CiviCRM',
    'access arguments' => array('administer queue2civicrm'),
    'page callback' => 'system_admin_menu_block_page',
    'file' => 'system.admin.inc',
    'file path' => drupal_get_path('module', 'system'),
  );

  $items['admin/config/queue2civicrm/configure'] = array(
    'title' => 'Configure',
    'description' => 'Configure message queue interface.',
    'access arguments' => array('administer queue2civicrm'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('queue2civicrm_settings'),
  );

  $items['admin/config/queue2civicrm/test'] = array(
    'title' => 'Test',
    'description' => 'Test queue connectivity.',
    'access arguments' => array('administer queue2civicrm'),
    'page callback' => 'queue2civicrm_test',
  );

  return $items;
}

function queue2civicrm_stomp_url() {
  return variable_get( 'queue2civicrm_url', 'tcp://localhost:61613' );
}

/**
 * Implements hook_permission().
 */
function queue2civicrm_permission() {
  return array(
    'administer queue2civicrm' => array(
      'title' => 'Administer queue2civicrm',
    ),
  );
}

/**
 * Callback for menu path "admin/config/queue2civicrm".
 */
function queue2civicrm_settings() {
  $form = array();

  $form['queue2civicrm_disable'] = array(
    '#type' => 'checkbox',
    '#title' => t('Disable job'),
    '#description' => t('If checked, no message processing will be performed.'),
    '#default_value' => variable_get('queue2civicrm_disable', false),
  );

  $form['queue2civicrm_batch'] = array(
    '#type' => 'select',
    '#title' => t('Cron batch size'),
    '#description' => t('Maximum number of donations processed by a queue2civicrm job.'),
    '#default_value' => variable_get('queue2civicrm_batch', 0),
    '#options' => array(
      0 => 'Unlimited',
      1 => 1,
      5 => 5,
      10 => 10,
      20 => 20,
      30 => 30,
      40 => 40,
      50 => 50,
      75 => 75,
      100 => 100,
      150 => 150,
      200 => 200,
      250 => 250,
      300 => 300,
      350 => 350,
      400 => 400,
      450 => 450,
      500 => 500,
      550 => 550,
      600 => 600,
      650 => 650,
      700 => 700,
    ),
  );

  $form['queue2civicrm_batch_time'] = array(
    '#type' => 'textfield',
    '#title' => t('Job time limit (in seconds)'),
    '#description' => t('Maximum elapsed duration of a queue2civicrm job, after which we will abort from the loop.  This can be used to set a reliable duty cycle for the job.  Either a time limit or batch size limit is required.'),
    '#required' => TRUE,
    '#default_value' => variable_get('queue2civicrm_batch_time', 90),
  );

  return system_settings_form($form);
}

function queue2civicrm_batch_process($options=[]) {
  // We only want to initialize the SmashPig stuff once, so we use the default
  // config section rather than a processor-specific section. This means all
  // processors have to use the same database for pending donation info.
  wmf_common_create_smashpig_context( 'queue2civicrm' );
  wmf_civicrm_boost_performance();

  if ( variable_get( 'queue2civicrm_disable', false ) ) {
    watchdog( 'queue2civicrm', 'Job is disabled.  Exiting.', NULL, WATCHDOG_INFO );
    return;
  }

  $batch_time = variable_get( 'queue2civicrm_batch_time', 0 );

  // If we're running on a time limit, try to account for drush's startup time.
  if ( $batch_time > 0 && isset( $_SERVER['REQUEST_TIME'] ) ) {
    $already_elapsed = time() - $_SERVER['REQUEST_TIME'];
    if ( $already_elapsed < $batch_time ) {
      $batch_time = $batch_time - $already_elapsed;
    }
  }

  // The number of contributions to process
  if (array_key_exists('batch', $options)) {
    $batch = $options['batch'];
  }
  else {
    $batch = variable_get('queue2civicrm_batch', 0);
  }

  $consumer = new DonationQueueConsumer(
    'donations',
    $batch_time,
    $batch
  );

  $DonationStatsCollector = DonationStatsCollector::getInstance();

  $DonationStatsCollector->startDefaultTimer();
  $processed = $consumer->dequeueMessages();
  $DonationStatsCollector->endDefaultTimer();

  $DonationStatsCollector->export();


  /**
   * === Legacy Donations Counter implementation ===
   *
   * Note that this might be a little whack.  At least, it feels a little sloppy.
   * We might consider specifying the names of gateways to keep track of, rather than auto-generate
   * the gateways to keep track of during queue consumption. With the latter (current) method,
   * we'll only report to prometheus when there are > 0 msgs consumed from the queue - meaning if
   * there are no msgs for a particular gateway, that fact will not get reported to prometheus.
   *
   * TODO: metrics stuff should be a hook
   */
  $counter = Queue2civicrmTrxnCounter::instance();
  $metrics = array();
  foreach ( $counter->get_trxn_counts() as $gateway => $count ) {
    $metrics["${gateway}_donations"] = $count;
  }
  $metrics['total_donations'] = $counter->get_count_total();
  module_invoke( 'metrics_reporting', 'report_metrics', 'queue2civicrm', $metrics );
  $ageMetrics = array();
  foreach ( $counter->get_average_ages() as $gateway => $age ) {
    $ageMetrics["${gateway}_message_age"] = $age;
  }
  module_invoke( 'metrics_reporting', 'report_metrics', 'donation_message_age', $ageMetrics );

  /**
   * === End of Legacy Donations Counter implementation ===
   */

  if ($processed > 0) {
    watchdog('queue2civicrm', 'Successfully processed ' . $processed . ' contribution(s).');
    watchdog('queue2civicrm',
      'Average Transaction age: ' . $DonationStatsCollector->getOverallAverageGatewayTransactionAge() . ' seconds.');
  } else {
    watchdog('queue2civicrm', 'No contributions processed.');
  }
}
