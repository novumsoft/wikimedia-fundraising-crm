<?php
use queue2civicrm\DonationQueueConsumer;

// include common functions
require_once( drupal_get_path( 'module', 'queue2civicrm' ) . '/queue2civicrm_common.inc' );

/**
 * Implementation of hook_menu().
 */
function queue2civicrm_menu() {
  $items = array();
  
  $items['admin/config/queue2civicrm'] = array(
    'title' => 'Queue to CiviCRM',
    'access arguments' => array('administer queue2civicrm'),
    'page callback' => 'system_admin_menu_block_page',
    'file' => 'system.admin.inc',
    'file path' => drupal_get_path('module', 'system'),
  );

  $items['admin/config/queue2civicrm/configure'] = array(
    'title' => 'Configure',
    'description' => 'Configure message queue interface.',
    'access arguments' => array('administer queue2civicrm'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('queue2civicrm_settings'),
  );

  $items['admin/config/queue2civicrm/test'] = array(
    'title' => 'Test',
    'description' => 'Test queue connectivity.',
    'access arguments' => array('administer queue2civicrm'),
    'page callback' => 'queue2civicrm_test',
  );

  return $items;
}

function queue2civicrm_stomp_url() {
  return variable_get( 'queue2civicrm_url', 'tcp://localhost:61613' );
}

/**
 * Implements hook_permission().
 */
function queue2civicrm_permission() {
  return array(
    'administer queue2civicrm' => array(
      'title' => 'Administer queue2civicrm',
    ),
  );
}

/**
 * Callback for menu path "admin/config/queue2civicrm".
 */
function queue2civicrm_settings() {
  $form = array();

  $form['queue2civicrm_disable'] = array(
    '#type' => 'checkbox',
    '#title' => t('Disable job'),
    '#description' => t('If checked, no message processing will be performed.'),
    '#default_value' => variable_get('queue2civicrm_disable', false),
  );

  $form['queue2civicrm_batch'] = array(
    '#type' => 'select',
    '#title' => t('Cron batch size'),
    '#description' => t('Maximum number of donations processed by a queue2civicrm job.'),
    '#default_value' => variable_get('queue2civicrm_batch', 0),
    '#options' => array(
      0 => 'Unlimited',
      1 => 1,
      5 => 5,
      10 => 10,
      20 => 20,
      30 => 30,
      40 => 40,
      50 => 50,
      75 => 75,
      100 => 100,
      150 => 150,
      200 => 200,
      250 => 250,
      300 => 300,
      350 => 350,
      400 => 400,
      450 => 450,
      500 => 500,
      550 => 550,
      600 => 600,
      650 => 650,
      700 => 700,
    ),
  );

  $form['queue2civicrm_batch_time'] = array(
    '#type' => 'textfield',
    '#title' => t('Job time limit (in seconds)'),
    '#description' => t('Maximum elapsed duration of a queue2civicrm job, after which we will abort from the loop.  This can be used to set a reliable duty cycle for the job.  Either a time limit or batch size limit is required.'),
    '#required' => TRUE,
    '#default_value' => variable_get('queue2civicrm_batch_time', 90),
  );

  $form [ 'queue2civicrm_gmetric_tmax' ] = array(
    '#type' => 'textfield',
    '#title' => t('Default tmax for gmetric reporting (in seconds)'),
    '#required' => false,
    '#default_value' => variable_get( 'queue2civicrm_gmetric_tmax', 60 ),
    '#description' => t('TMAX indicates the freshness of a metric. If TN exceeds TMAX, then Ganglia is expecting a new value. However, TMAX is only advisory: Ganglia takes no action when TN exceeds TMAX.')
  );
  
  $form [ 'queue2civicrm_gmetric_dmax' ] = array(
  	'#type' => 'textfield',
    '#title' => t('Default dmax for gmetric reporting (in seconds)'),
    '#required' => false,
    '#default_value' => variable_get( 'queue2civicrm_gmetric_dmax', 360 ),
    '#description' => t('DMAX indicates for how long an old metric should be retained. If TN exceeds DMAX then Ganglia will consider that that metric is no longer being monitored. Therefore, it will discard information about that metric.')
  );
  
  return system_settings_form($form);
}

function queue2civicrm_batch_process() {
  // We only want to initialize the SmashPig stuff once, so we use the default
  // config section rather than a processor-specific section. This means all
  // processors have to use the same database for pending donation info.
  wmf_common_create_smashpig_context( 'queue2civicrm' );
  wmf_civicrm_boost_performance();

  if ( variable_get( 'queue2civicrm_disable', false ) ) {
    watchdog( 'queue2civicrm', 'Job is disabled.  Exiting.', NULL, WATCHDOG_INFO );
    return;
  }

  $batch_time = variable_get( 'queue2civicrm_batch_time', 0 );

  // If we're running on a time limit, try to account for drush's startup time.
  if ( $batch_time > 0 && isset( $_SERVER['REQUEST_TIME'] ) ) {
    $already_elapsed = time() - $_SERVER['REQUEST_TIME'];
    if ( $already_elapsed < $batch_time ) {
      $batch_time = $batch_time - $already_elapsed;
    }
  }

  $consumer = new DonationQueueConsumer(
    'donations',
    $batch_time,
    variable_get( 'queue2civicrm_batch', 0 )
  );
  $processed = $consumer->dequeueMessages();

  /**
   * this may some day supersede the process counts handled above...
   * 
   * Note that this might be a little whack.  At least, it feels a little sloppy.
   * The tmax/dmax fields should probably be configurable
   * through the UI rather than hardcoded here. Furthermore, we might consider specifying the names
   * of gateways to keep track of, rather than auto-generate the gateways to keep track of during 
   * queue consumption.  With the latter (current) method, we'll only report to gmetric when there
   * are > 0 msgs consumed from the queue - meaning if there are no msgs for a particular gateway, 
   * that fact will not get reported to gmetric.  But I've hardcoded the dmax param here to be the
   * same as the frequency of queue consumption, so if there are no messages in the queue for
   * a particular gateway, the gateway will report as having consumed 0 messages in ganglia anyway.
   *
   * TODO: the ganglia stuff should be a hook
   */
  $gmetric_tmax = variable_get( 'queue2civicrm_gmetric_tmax', 60 );
  $gmetric_dmax = variable_get( 'queue2civicrm_gmetric_dmax', 360 );
  $counter = Queue2civicrmTrxnCounter::instance();
  foreach ( $counter->get_trxn_counts() as $gateway => $count ) {
    module_invoke( 'ganglia_reporter', 'send_metric', $gateway . ' donations', $count, 'int8', 'donations', 'both', $gmetric_tmax, $gmetric_dmax );
  }
  module_invoke( 'ganglia_reporter', 'send_metric', 'Total donations', $counter->get_count_total(), 'int8', 'donations', 'both', $gmetric_tmax, $gmetric_dmax );
  
  if ($processed > 0) {
    watchdog('queue2civicrm', 'Successfully processed ' . $processed . ' contribution(s).');
  }
  else {
    watchdog('queue2civicrm', 'No contributions processed.');
  }
}
