<?php
use SmashPig\Core\Configuration;
use SmashPig\Core\Context;
use SmashPig\Core\DataStores\PendingDatabase;
use SmashPig\Core\Logging\Logger;

// include common functions
require_once( drupal_get_path( 'module', 'queue2civicrm' ) . '/queue2civicrm_common.inc' );

/**
 * Implementation of hook_menu().
 */
function queue2civicrm_menu() {
  $items = array();
  
  $items['admin/config/queue2civicrm'] = array(
    'title' => 'Queue to CiviCRM',
    'access arguments' => array('administer queue2civicrm'),
    'page callback' => 'system_admin_menu_block_page',
    'file' => 'system.admin.inc',
    'file path' => drupal_get_path('module', 'system'),
  );

  $items['admin/config/queue2civicrm/configure'] = array(
    'title' => 'Configure',
    'description' => 'Configure message queue interface.',
    'access arguments' => array('administer queue2civicrm'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('queue2civicrm_settings'),
  );

  $items['admin/config/queue2civicrm/test'] = array(
    'title' => 'Test',
    'description' => 'Test queue connectivity.',
    'access arguments' => array('administer queue2civicrm'),
    'page callback' => 'queue2civicrm_test',
  );

  return $items;
}

function queue2civicrm_stomp_url() {
  return variable_get( 'queue2civicrm_url', 'tcp://localhost:61613' );
}

/**
 * Create or retrieve a stomp queue connection.  It's best to use a different
 * Queue object for each queue you access if you are interleaving reads from
 * different queues.
 * @param string $name a label for the Queue object
 * @return Queue named connection object
 */
function queue2civicrm_stomp( $name = 'default' ) {
  static $q = array();

  if ( empty( $q[$name] ) ) {
    $q[$name] = new Queue( queue2civicrm_stomp_url() );
  }

  return $q[$name];
}

function queue2civicrm_test() {
  $content = array();
  
  $content[] = '<p>Attempting connection to ' . queue2civicrm_stomp_url() . '... ';  
  $q = queue2civicrm_stomp();
  try {
    $q->getConnection();
    $content[] = '[SUCCESS]</p>';
  }
  catch (Exception $e) {
    $content[] = '[FAILURE], error: ' . $e . '</p>';
  }
  
  return implode("\n", $content);
}

/**
 * Implements hook_permission().
 */
function queue2civicrm_permission() {
  return array(
    'administer queue2civicrm' => array(
      'title' => 'Administer queue2civicrm',
    ),
  );
}

/**
 * Callback for menu path "admin/config/queue2civicrm".
 */
function queue2civicrm_settings() {
  $form = array();

  $form['queue2civicrm_disable'] = array(
    '#type' => 'checkbox',
    '#title' => t('Disable job'),
    '#description' => t('If checked, no message processing will be performed.'),
    '#default_value' => variable_get('queue2civicrm_disable', false),
  );

  $form['queue2civicrm_url'] = array(
    '#type' => 'textfield',
    '#title' => t('Connection URL'),
    '#description' => t('Include the port number, like so for a typical development environment: !example_url', array( '!example_url' => 'http://localhost:61613')),
    '#required' => TRUE,
    '#default_value' => queue2civicrm_stomp_url(),
  );

  $form['queue2civicrm_subscription'] = array(
    '#type' => 'textfield',
    '#title' => t('Subscription path'),
    '#description' => t('The queue holding normal, incoming donations waiting to be processed.'),
    '#required' => TRUE,
    '#default_value' => variable_get('queue2civicrm_subscription', '/queue/donations'),
  );

  $form['queue2civicrm_batch'] = array(
    '#type' => 'select',
    '#title' => t('Cron batch size'),
    '#description' => t('Maximum number of donations processed by a queue2civicrm job.'),
    '#default_value' => variable_get('queue2civicrm_batch', 0),
    '#options' => array(
      '' => 'Unlimited',
      1 => 1,
      5 => 5,
      10 => 10,
      20 => 20,
      30 => 30,
      40 => 40,
      50 => 50,
      75 => 75,
      100 => 100,
      150 => 150,
      200 => 200,
      250 => 250,
      300 => 300,
      350 => 350,
      400 => 400,
      450 => 450,
      500 => 500,
      550 => 550,
      600 => 600,
      650 => 650,
      700 => 700,
    ),
  );

  $form['queue2civicrm_batch_time'] = array(
    '#type' => 'textfield',
    '#title' => t('Job time limit (in seconds)'),
    '#description' => t('Maximum elapsed duration of a queue2civicrm job, after which we will abort from the loop.  This can be used to set a reliable duty cycle for the job.  Either a time limit or batch size limit is required.'),
    '#required' => TRUE,
    '#default_value' => variable_get('queue2civicrm_batch_time', 90),
  );

  $form [ 'queue2civicrm_gmetric_tmax' ] = array(
    '#type' => 'textfield',
    '#title' => t('Default tmax for gmetric reporting (in seconds)'),
    '#required' => false,
    '#default_value' => variable_get( 'queue2civicrm_gmetric_tmax', 60 ),
    '#description' => t('TMAX indicates the freshness of a metric. If TN exceeds TMAX, then Ganglia is expecting a new value. However, TMAX is only advisory: Ganglia takes no action when TN exceeds TMAX.')
  );
  
  $form [ 'queue2civicrm_gmetric_dmax' ] = array(
  	'#type' => 'textfield',
    '#title' => t('Default dmax for gmetric reporting (in seconds)'),
    '#required' => false,
    '#default_value' => variable_get( 'queue2civicrm_gmetric_dmax', 360 ),
    '#description' => t('DMAX indicates for how long an old metric should be retained. If TN exceeds DMAX then Ganglia will consider that that metric is no longer being monitored. Therefore, it will discard information about that metric.')
  );
  
  return system_settings_form($form);
}

function queue2civicrm_batch_process() {
  // We only want to initialize the SmashPig stuff once, so we use the default
  // config section rather than a processor-specific section. This means all
  // processors have to use the same database for pending donation info.
  $config = new Configuration();
  Context::initWithLogger( $config, 'queue2civicrm' );
  wmf_civicrm_boost_performance();

  if ( variable_get( 'queue2civicrm_disable', false ) ) {
    watchdog( 'queue2civicrm', 'Job is disabled.  Exiting.', NULL, WATCHDOG_INFO );
    return;
  }

  $processed = queue2civicrm_stomp()->dequeue_loop(
      variable_get( 'queue2civicrm_subscription', '/queue/donations' ),
      variable_get( 'queue2civicrm_batch', 0 ),
      variable_get( 'queue2civicrm_batch_time', 0 ),
      'queue2civicrm_import'
  );

  /**
   * this may some day supercede the process counts handled above...
   * 
   * Note that this might be a little whack.  At least, it feels a little sloppy.
   * The tmax/dmax fields should probably be configurable
   * through the UI rather than hardcoded here. Furthermore, we might consider specifying the names
   * of gateways to keep track of, rather than auto-generate the gateways to keep track of during 
   * queue consumption.  With the latter (current) method, we'll only report to gmetric when there
   * are > 0 msgs consumed from the queue - meaning if there are no msgs for a particular gateway, 
   * that fact will not get reported to gmetric.  But I've hardcoded the dmax param here to be the
   * same as the frequency of queue consumption, so if there are no messages in the queue for
   * a particular gateway, the gateway will report as having consumed 0 messages in ganglia anyway.
   *
   * TODO: the ganglia stuff should be a hook
   */
  $gmetric_tmax = variable_get( 'queue2civicrm_gmetric_tmax', 60 );
  $gmetric_dmax = variable_get( 'queue2civicrm_gmetric_dmax', 360 );
  $counter = Queue2civicrmTrxnCounter::instance();
  foreach ( $counter->get_trxn_counts() as $gateway => $count ) {
    module_invoke( 'ganglia_reporter', 'send_metric', $gateway . ' donations', $count, 'int8', 'donations', 'both', $gmetric_tmax, $gmetric_dmax );
  }
  module_invoke( 'ganglia_reporter', 'send_metric', 'Total donations', $counter->get_count_total(), 'int8', 'donations', 'both', $gmetric_tmax, $gmetric_dmax );
  
  if ($processed > 0) {
    watchdog('queue2civicrm', 'Successfully processed ' . $processed . ' contribution(s).');
  }
  else {
    watchdog('queue2civicrm', 'No contributions processed.');
  }
}

/**
 * Process one contribution from the queue to CiviCRM.
 *
 * @param Stomp_Frame|array $msg
 */
function queue2civicrm_import( $msg ) {
    if ( is_object( $msg ) && property_exists( $msg, 'body' ) ) {
        $msg = $msg->body;
    }

    if ( is_string( $msg ) ) {
        // save the original message for logging
        $msg_orig = $msg;

        $msg = json_decode( $msg, true );
    } else {
        $msg_orig = json_encode( $msg );
    }

    /**
    * prepare data for logging
    */
    $log = array(
        'gateway' => $msg[ 'gateway' ],
        'gateway_txn_id' => $msg[ 'gateway_txn_id' ],
        'data' => $msg_orig,
        'timestamp' => time(),
        'verified' => 0,
    );
    $cid = _queue2civicrm_log( $log );

    $dbEntry = false;
    // If more information is available, find it from the pending database
    // FIXME: replace completion_message_id with a boolean flag
    if ( isset( $msg['completion_message_id'] ) ) {
        $dbEntry = queue2civicrm_update_from_pending_db( $msg );
        if ( !$dbEntry ) {
            // If the contribution has already been imported, this check will
            // throw an exception that says to drop it entirely, not re-queue.
            wmf_civicrm_check_for_duplicates(
                $msg['gateway'], $msg['gateway_txn_id']
            );

            // Otherwise, throw an exception that tells the queue consumer to
            // requeue the incomplete message with a delay.
            $errorMessage = "Message {$msg['gateway']}-{$msg['gateway_txn_id']} " .
                "indicates a pending DB entry with order ID {$msg['order_id']}, " .
                "but none was found.  Requeueing.";
            throw new WmfException( 'MISSING_PREDECESSOR', $errorMessage );
        }
    }

    $contribution = wmf_civicrm_contribution_message_import($msg);

    // construct an array of useful info to invocations of queue2civicrm_import
    $contribution_info = array(
        'contribution_id' => $contribution['id'],
        'contact_id' => $contribution['contact_id'],
        'msg' => $msg,
    );

    // update the log if things went well
    if ( $cid ) {
        $log[ 'cid' ] = $cid;
        $log[ 'verified' ] = 1;
        $log[ 'timestamp' ] = time();
        _queue2civicrm_log( $log );
    }

    // Send thank you email, other post-import things
    module_invoke_all( 'queue2civicrm_import', $contribution_info );
    
    // keep count of the transactions
    Queue2civicrmTrxnCounter::instance()->increment( $msg['gateway'] );

    // Delete message from pending db once the rest has completed successfully
    if ( $dbEntry ) {
        PendingDatabase::get()->deleteMessage( $dbEntry );
    }
}

/**
 * Fill in some missing information from the pending database
 * @param array $msg sparse donation message, usually from IPN listener
 * @return array|null message from database, or null if not found
 */
function queue2civicrm_update_from_pending_db( &$msg ) {
    $gateway = $msg['gateway'];
    $orderId = $msg['order_id'];

    $data = PendingDatabase::get()->fetchMessageByGatewayOrderId(
        $gateway,
        $orderId
    );

	// Sparse messages should have no keys at all for the missing info,
	// rather than blanks or junk data. And $msg should always have newer
	// info than the pending db.
    if ( $data ) {
        $msg = $msg + $data;
        // $data has a pending_id key for ease of deletion,
        // but $msg doesn't need it
        unset( $msg['pending_id'] );
    }
    return $data;
}
