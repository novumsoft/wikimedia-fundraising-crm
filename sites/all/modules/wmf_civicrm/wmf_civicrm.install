<?php

use Civi\Api4\OptionValue;

require_once(__DIR__ . "/bootstrap.inc");
require_once 'update_custom_fields.php';

/**
 * On new install call these functions.
 *
 * Some things need to run on update but not on new installs in which case they won't be below.
 *
 * A good example is that we have update functions to 'enable all the extensions we need' - on
 * new installs we need to run this only once as the list is dynamic so we don't need to call
 * each update function that does that. Another e.g is datacleanup tasks.
 *
 * @throws \CiviCRM_API3_Exception
 * @throws \DrupalUpdateException
 * @throws \Exception
 */
function wmf_civicrm_install() {
  civicrm_initialize();
  _wmf_civicrm_escalate_permissions();
  _wmf_civicrm_update_custom_fields();
  wmf_civicrm_update_7000();
  wmf_civicrm_update_7003();
  wmf_civicrm_update_7005();
  wmf_civicrm_update_7006();
  wmf_civicrm_update_7007();
  wmf_civicrm_update_7008();
  wmf_civicrm_update_7012();
  wmf_civicrm_update_7013();
  wmf_civicrm_update_7016();
  wmf_civicrm_update_7017();
  wmf_civicrm_update_7021();
  wmf_civicrm_update_7028();
  wmf_civicrm_update_7029();
  wmf_civicrm_update_7030();
  wmf_civicrm_update_7032();
  wmf_civicrm_update_7060();
  wmf_civicrm_update_7062();
  wmf_civicrm_update_7063();
  wmf_civicrm_update_7080();
  wmf_civicrm_update_7090();
  wmf_civicrm_update_7100();
  wmf_civicrm_update_7110();
  wmf_civicrm_update_7120();
  wmf_civicrm_update_7170();
  wmf_civicrm_update_7180();
  wmf_civicrm_update_7190();
  wmf_civicrm_update_7200();
  wmf_civicrm_update_7210();
  wmf_civicrm_update_7230();
  wmf_civicrm_update_7235();
  wmf_civicrm_update_7280();
  wmf_civicrm_update_7290();
  wmf_civicrm_update_7455();
  wmf_civicrm_update_7460();
  wmf_civicrm_update_7524();
  wmf_civicrm_update_7525();
  wmf_civicrm_update_7526();
  wmf_civicrm_update_7570();
  wmf_civicrm_update_7585();
  wmf_civicrm_update_7610();
  wmf_civicrm_update_7615();
  wmf_civicrm_update_7705();
  wmf_civicrm_update_7726();
  wmf_civicrm_update_7890();
  wmf_civicrm_update_7935();
  wmf_civicrm_update_7940();
  wmf_civicrm_update_8055();
  wmf_civicrm_update_8065();
}

/**
 * Escalate permissions.
 *
 * In general we do api calls from php with check_permissions = FALSE so this doesn't matter.
 *
 * However, when there is an error the debug output is affected by permissions -ie
 *
 * if (CRM_Core_Permission::check('Administer CiviCRM') || CIVICRM_UF == 'UnitTests') {
 *
 * For core tests the UF is UnitTests so the extra debug is returned but we are running
 * under Drupal so we need to be more aggressive.
 */
function _wmf_civicrm_escalate_permissions() {
  civicrm_initialize();
  CRM_Core_Config::singleton()->userPermissionTemp = new CRM_Core_Permission_Temp();
  CRM_Core_Config::singleton()->userPermissionTemp->grant('administer CiviCRM');
}

/**
 * Helper creates a new option group and links an
 * existing custom field in the Gift_Data custom group.
 *
 * TODO this is not a handy generalization, just a way
 * to have a little less copypasta in this file.  I also
 * suspect there's a better place for it to live.
 */
function _link_gift_data_field_to_new_group($field_name, $group_name, $values) {
  $api = wmf_civicrm_bootstrap_civi();

  $params = [
    'custom_group_id' => 'Gift_Data',
    'name' => $field_name,
    'return' => 'id',
  ];
  $custom_field_id = civicrm_api3('CustomField', 'getvalue', $params);

  // Make the options.
  $success = $api->OptionGroup->get(array(
    'name' => $group_name,
  ));
  if (!$success || !count($api->values)) {
    $success = $api->OptionGroup->create(array(
      'is_active' => 1,
      'is_reserved' => 1,
      'name' => $group_name,
      'title' => $field_name,
    ));
    if (!$success) {
      throw new DrupalUpdateException($api->errorMsg());
    }
  }
  $option_group_id = $api->values[0]->id;

  foreach ($values as $value) {
    $success = $api->OptionValue->get(array(
      'group_id' => $option_group_id,
      'value' => $value,
    ));
    if (!$success || !count($api->values)) {
      $success = $api->OptionValue->create(array(
        'option_group_id' => $option_group_id,
        'label' => ts($value),
        'value' => $value,
      ));
      if (!$success) {
        throw new DrupalUpdateException($api->errorMsg());
      }
    }
  }

  try {
    $params = [
      'id' => $custom_field_id,
      'option_group_id' => $option_group_id,
      'debug' => 1,
    ];
    civicrm_api3('CustomField', 'create', $params);
  }
  catch (CiviCRM_API3_Exception $e) {
    throw new DrupalUpdateException($e->getMessage() .  "\n" . print_r($params, TRUE) . "\n" . $e->getTraceAsString() . "\n" . print_r($e->getExtraParams(), TRUE));
  }

}

/**
 * Add contribution types and payment instruments
 */
function wmf_civicrm_update_7000() {
  $financial_types = array(
    'Cash',
    'Benevity',
  );
  wmf_civicrm_bootstrap_civi();
  require_once 'update_payment_instruments.php';
  wmf_install_add_missing_payment_instruments();
  wmf_civicrm_create_financial_types($financial_types);
}

function wmf_civicrm_update_7003() {
  wmf_civicrm_bootstrap_civi();
  wmf_civicrm_create_financial_types(array(
    'Merkle',
  ));
}

/**
 * More complete gateway and settlement recording. Adding a field to mark
 * auditing-only transactions, and a hack to link contributions.
 */
function wmf_civicrm_update_7005() {
  $api = wmf_civicrm_bootstrap_civi();
  $success = $api->CustomGroup->get(array(
    'name' => 'contribution_extra',
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }
  $values = $api->values();
  $custom_group = array_pop($values);

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'gateway',
    'column_name' => 'gateway',
    'label' => ts('Gateway'),
    'data_type' => 'String',
    'html_type' => 'Text',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_view' => 1,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'gateway_txn_id',
    'column_name' => 'gateway_txn_id',
    'label' => ts('Gateway Transaction ID'),
    'data_type' => 'String',
    'html_type' => 'Text',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_view' => 1,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'gateway_status_raw',
    'column_name' => 'gateway_status_raw',
    'label' => ts('Gateway Status (raw)'),
    'data_type' => 'String',
    'html_type' => 'Text',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_view' => 1,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'gateway_status',
    'column_name' => 'gateway_status',
    'label' => ts('Gateway Status (normalized)'),
    'data_type' => 'String',
    'html_type' => 'Text',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_view' => 1,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'gateway_date',
    'column_name' => 'gateway_date',
    'label' => ts('Gateway Last Update Timestamp'),
    'data_type' => 'Date',
    'html_type' => 'Select Date',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_search_range' => 1,
    'is_view' => 1,
    'date_format' => 'M d, yy',
    'time_format' => 2,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'original_amount',
    'column_name' => 'original_amount',
    'label' => ts('Original Amount Received (unconverted)'),
    'data_type' => 'Money',
    'html_type' => 'Text',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_search_range' => 1,
    'is_view' => 1,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'original_currency',
    'column_name' => 'original_currency',
    'label' => ts('Original Currency Received'),
    'data_type' => 'String',
    'html_type' => 'Text',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_view' => 1,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'settlement_usd',
    'column_name' => 'settlement_usd',
    'label' => ts('Settlement Total (USD)'),
    'data_type' => 'Money',
    'html_type' => 'Text',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_search_range' => 1,
    'is_view' => 1,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'settlement_currency',
    'column_name' => 'settlement_currency',
    'label' => ts('Settlement Currency'),
    'data_type' => 'String',
    'html_type' => 'Text',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_view' => 1,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'deposit_date',
    'column_name' => 'deposit_date',
    'label' => ts('Deposit Received Date'),
    'data_type' => 'Date',
    'html_type' => 'Select Date',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_search_range' => 1,
    'is_view' => 1,
    'date_format' => 'M d, yy',
    'time_format' => 2,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'deposit_usd',
    'column_name' => 'deposit_usd',
    'label' => ts('Deposit Total (USD)'),
    'data_type' => 'Money',
    'html_type' => 'Text',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_search_range' => 1,
    'is_view' => 1,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'deposit_currency',
    'column_name' => 'deposit_currency',
    'label' => ts('Deposit Currency'),
    'data_type' => 'String',
    'html_type' => 'Text',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_view' => 1,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'parent_contribution_id',
    'column_name' => 'parent_contribution_id',
    'label' => ts('Parent Contribution ID'),
    'data_type' => 'Int',
    'html_type' => 'Text',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_view' => 1,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'finance_only',
    'column_name' => 'finance_only',
    'label' => ts('Finance Auditing Only'),
    'data_type' => 'Boolean',
    'html_type' => 'Radio',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_view' => 1,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }
}

/**
 * Additional, gateway-related contribution statuses
 */
function wmf_civicrm_update_7006() {
  wmf_civicrm_create_option_values('contribution_status', array(
    'Settled',
    'Paid',
  ));

  $api = wmf_civicrm_bootstrap_civi();

  $success = $api->CustomGroup->get(array(
    'name' => 'contribution_extra',
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }
  $custom_group = $api->values[0];
  $success = $api->CustomField->get(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'gateway_status',
  ));
  if ($success && $api->values) {
    $field = $api->values[0];
    $success = $api->CustomField->delete(array(
      'id' => $field->id,
    ));
    if (!$success) {
      throw new DrupalUpdateException($api->errorMsg());
    }
  }
}

/**
 * New contribution types to distinguish refunds from chargebacks. Create old
 * "Review" tag.
 */
function wmf_civicrm_update_7007() {
  $api = wmf_civicrm_bootstrap_civi();

  wmf_civicrm_create_financial_types(array(
    'Refund',
    'Chargeback',
  ));

  $success = $api->Tag->create(array(
    'name' => 'Review',
    'description' => 'Review',
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }
}

/**
 * Add new check processor!
 */
function wmf_civicrm_update_7008() {
  wmf_civicrm_bootstrap_civi();
  wmf_civicrm_create_financial_types(array(
    'Arizona Lockbox',
  ));
}

/**
 * Add source metadata fields
 */
function wmf_civicrm_update_7012() {
  $api = wmf_civicrm_bootstrap_civi();

  $success = $api->CustomGroup->get(array(
    'name' => 'contribution_extra',
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }
  $values = $api->values();
  $custom_group = array_pop($values);

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'source_name',
    'column_name' => 'source_name',
    'label' => ts('Source Name'),
    'data_type' => 'String',
    'html_type' => 'Text',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_view' => 1,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'source_type',
    'column_name' => 'source_type',
    'label' => ts('Source Type'),
    'data_type' => 'String',
    'html_type' => 'Text',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_view' => 1,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'source_host',
    'column_name' => 'source_host',
    'label' => ts('Source Host'),
    'data_type' => 'String',
    'html_type' => 'Text',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_view' => 1,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'source_run_id',
    'column_name' => 'source_run_id',
    'label' => ts('Source Run ID'),
    'data_type' => 'String',
    'html_type' => 'Text',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_view' => 1,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'source_version',
    'column_name' => 'source_version',
    'label' => ts('Source Version'),
    'data_type' => 'String',
    'html_type' => 'Text',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_view' => 1,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'source_enqueued_time',
    'column_name' => 'source_enqueued_time',
    'label' => ts('Enqueued At Timestamp'),
    'data_type' => 'Date',
    'html_type' => 'Select Date',
    'is_active' => 1,
    'is_searchable' => 1,
    'is_search_range' => 1,
    'is_view' => 1,
    'date_format' => 'M d, yy',
    'time_format' => 2,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }
}

/**
 * Add Postmark Date field
 */
function wmf_civicrm_update_7013() {
  $api = wmf_civicrm_bootstrap_civi();
  $api->CustomGroup->get(array(
    'name' => 'contribution_extra',
  ));
  $values = $api->values();
  $custom_group = array_pop($values);

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group->id,
    'name' => 'Postmark_Date',
    'column_name' => 'postmark_date',
    'label' => ts('Postmark Date'),
    'data_type' => 'Date',
    'html_type' => 'Select Date',
    'is_active' => 1,
    'is_searchable' => 0,
    'is_view' => 0,
  ));
  if (!$success) {
    throw new DrupalUpdateException($api->errorMsg());
  }
}

/**
 * Create recurring restarted contribution tag
 */
function wmf_civicrm_update_7016() {
  $ret = array();
  $api = wmf_civicrm_bootstrap_civi();
  wmf_civicrm_create_option_values_detailed('tag_used_for', array(
    'Contributions' => array('value' => 'civicrm_contribution'),
  ));

  $success = $api->Tag->get(array(
    'name' => 'RecurringRestarted',
    'used_for' => 'civicrm_contribution',
  ));
  if (!count($api->values)) {
    $success = $api->Tag->create(array(
      'name' => 'RecurringRestarted',
      'description' => 'For the first contribution of a restarted recurring subscription.',
      'is_selectable' => FALSE,
      'is_reserved' => TRUE,
      'used_for' => 'civicrm_contribution',
    ));
    if (!$success) {
      throw new DrupalUpdateException($api->errorMsg());
    }
  }
}

/**
 * Create truncated address tag
 */
function wmf_civicrm_update_7017() {
  $ret = array();
  $api = wmf_civicrm_bootstrap_civi();
  $success = $api->Tag->get(array(
    'name' => 'AddressTruncated',
    'used_for' => 'civicrm_contact',
  ));
  if (!count($api->values)) {
    $success = $api->Tag->create(array(
      'name' => 'AddressTruncated',
      'description' => 'Tag applied to a contact when the address was truncated on import.',
      'is_selectable' => TRUE,
      'is_reserved' => TRUE,
      'used_for' => 'civicrm_contact',
    ));
    if (!$success) {
      throw new DrupalUpdateException($api->errorMsg());
    }
  }
}

/**
 * Create UnrecordedCharge contribution tag
 */
function wmf_civicrm_update_7021() {
  $ret = array();
  $api = wmf_civicrm_bootstrap_civi();
  $success = $api->Tag->get(array(
    'name' => 'UnrecordedCharge',
    'used_for' => 'civicrm_contribution',
  ));
  if (!count($api->values)) {
    $success = $api->Tag->create(array(
      'name' => 'UnrecordedCharge',
      'description' => 'For donations which have already been charged, but were not recorded in Civi at the time.',
      'is_selectable' => FALSE,
      'is_reserved' => TRUE,
      'used_for' => 'civicrm_contribution',
    ));
    if (!$success) {
      throw new DrupalUpdateException($api->errorMsg());
    }
  }
}

/**
 * Add "Engage" contribution type
 *
 * Note that we create the "Engage Direct Mail" role programatically, but it
 * won't have usable permissions.
 */
function wmf_civicrm_update_7028() {
  if (FALSE === user_role_load_by_name('Engage Direct Mail')) {
    $role = new stdClass();
    $role->name = 'Engage Direct Mail';
    user_role_save($role);
  }

  wmf_civicrm_bootstrap_civi();
  wmf_civicrm_create_financial_types(array(
    'Engage',
  ));
}

/**
 * Rename "Old and add "Old 2015" Location Type values
 *
 * We are also adding existing values programmatically if they don't already
 * exist.
 */
function wmf_civicrm_update_7029() {
  $api = wmf_civicrm_bootstrap_civi();
  $location_types = array(
    'Home' => 'Home',
    'Work' => 'Work',
    'Main' => 'Main',
    'Other' => 'Other',
    'Mailing' => 'Mailing',
    'Billing' => 'Billing',
    'Old' => 'Old 2014',
    'Old_2015' => 'Old 2015',
  );
  wmf_civicrm_create_location_types($location_types, TRUE);
}

/**
 * Add some custom fields that already exist on production
 */
function wmf_civicrm_update_7030() {
  $warnings = array();

  $api = wmf_civicrm_bootstrap_civi();
  $success = $api->CustomGroup->get(array(
    'name' => 'Organization_Contact',
  ));
  if (!$success || !$api->count) {
    $success = $api->CustomGroup->create(array(
      'name' => 'Organization_Contact',
      'title' => 'Organization Contact',
      'extends' => 'Organization',
      'is_active' => 1,
    ));
    if (!$success) {
      throw new DrupalUpdateException($api->errorMsg());
    }
  }
  $custom_group_id = $api->id;

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group_id,
    'name' => 'Name',
    'label' => ts('Name'),
    'data_type' => 'String',
    'html_type' => 'Text',
    'is_active' => 1,
    'is_required' => 0,
    'is_searchable' => 1,
    'is_view' => 0,
  ));
  if (!$success) {
    $warnings[] = $api->errorMsg();
  }

  $success = $api->CustomField->create(array(
    'custom_group_id' => $custom_group_id,
    'name' => 'Title',
    'label' => ts('Title'),
    'data_type' => 'String',
    'html_type' => 'Text',
    'is_active' => 1,
    'is_required' => 0,
    'is_searchable' => 0,
    'is_view' => 0,
  ));
  if (!$success) {
    $warnings[] = $api->errorMsg();
  }

  return implode("\n", $warnings);
}

/**
 * Link Restrictions, Gift Source, Appeal options to custom fields.
 */
function wmf_civicrm_update_7032() {

  _link_gift_data_field_to_new_group('Fund', 'fund_20080709173248', [
    'Unrestricted - General',
    'Restricted - Foundation',
    'Restricted - Program',
    'Restricted - Fiscal Sponsorship',
  ]);

  _link_gift_data_field_to_new_group('Campaign', 'campaign_20080709183311', array(
    'Community Gift',
    'Benefactor Gift',
    'Foundation Gift',
    'Matching Gift',
    'Donor Advised Fund',
    'Corporate Gift',
    'Legacy Gift',
    'Chapter Gift',
    'Major Gift',
    'Combined Federal Campaign',
    'Payroll Deduction',
  ));

  _link_gift_data_field_to_new_group('Appeal', 'appeal_20080709183729', array(
    'White Mail',
    'Spontaneous Donation',
    'Facebook',
    'Event',
    'Mobile Giving',
    'Corp Matching Gift',
  ));
}

/**
 * Add option value 'tag_used_for' for civicrm_contribution.
 *
 * This might exist as it had to be added to update 7016 so check first.d
 *
 * Note I have skipped to 7060 leaving a numerical gap for upgrades that happen
 * in master before this is merged.
 */
function wmf_civicrm_update_7060() {
  wmf_civicrm_bootstrap_civi();
  wmf_civicrm_create_option_values_detailed('tag_used_for', array(
    'Contributions' => array('value' => 'civicrm_contribution'),
  ));
}

/**
 * Set default language for contacts to 'undefined'.
 *
 * This means a new contact created will have an empty language rather than a
 * guessed one.
 *
 * CRM-14232
 *
 * @throws \CiviCRM_API3_Exception
 */
function wmf_civicrm_update_7062() {
  civicrm_initialize();
  civicrm_api3('Setting', 'create', array(
    'contact_default_language' => "undefined",
  ));
}

/**
 * Reset navigation menu.
 *
 * CRM-17176
 *
 * @throws \CiviCRM_API3_Exception
 */
function wmf_civicrm_update_7063() {
  civicrm_initialize();
  civicrm_api3('Navigation', 'reset', array(
    'for' => "report",
  ));
}

/**
 * Ensure all payments have a payment instrument id.
 *
 * Per
 * http://wiki.civicrm.org/confluence/display/CRMDOC/Fixing+Transactions+Missing+a+Payment+Instrument+-+4.4.3+Upgrades
 * there is a payment instrument id set for all contributions.
 *
 * The code there basically just figures out a default & sets the empty ones to
 * that.
 *
 * If we look at the first million contributions just setting the it to
 * 'Gateway' seems a reasonable choice of default.
 *
 * SELECT  payment_instrument_id, count(*) FROM (SELECT * FROM
 * civicrm_contribution LIMIT 1000000) as t GROUP BY payment_instrument_id;
 * +-----------------------+----------+
 * | payment_instrument_id | count(*) |
 * +-----------------------+----------+
 * |                  NULL |       33 |
 * |                     1 |        3 |
 * |                     3 |       30 |
 * |                     4 |    14162 |
 * |                     5 |      119 |
 * |                     6 |   982954 |
 * |                     7 |     1451 |
 * |                     8 |     1246 |
 * |                    44 |        1 |
 * |                   186 |        1 |
 */
function wmf_civicrm_update_7065() {
  civicrm_initialize();
  // Ensure that 'Gateway' option exists. Will be a no-op if it's already there.
  wmf_civicrm_create_option_values('payment_instrument', array('Gateway'));
  $paymentInstruments = civicrm_api3('Contribution', 'getoptions', array('field' => 'payment_instrument_id'));
  $defaultPaymentInstrument = array_search('Gateway', $paymentInstruments['values']);
  CRM_Core_DAO::executeQuery(
    "UPDATE civicrm_contribution SET payment_instrument_id = $defaultPaymentInstrument WHERE payment_instrument_id IS NULL"
  );
  CRM_Core_DAO::executeQuery(
    "UPDATE civicrm_financial_trxn cft
LEFT JOIN civicrm_entity_financial_trxn ceft ON ceft.financial_trxn_id = cft.id
LEFT JOIN civicrm_contribution cc  ON ceft.entity_id = cc.id
SET cft.payment_instrument_id = IFNULL(cc.payment_instrument_id, $defaultPaymentInstrument)
WHERE ceft.entity_table = 'civicrm_contribution' AND cft.payment_instrument_id IS NULL;"
  );
}

/**
 * Update upgraded 4.2 refund transactions to have negative refund records.
 *
 * In the 4.3 upgrade transaction records were done for statuses Completed
 * Pending and Cancelled. The status Refunded was not a core status until 4.3
 * so transactions were NOT added in the upgrade to refunded status
 * transactions.
 *
 * The original upgrade code is in the function
 * CRM_Upgrade_Incremental_php_FourThree::createFinancialRecords
 *
 * I tried re-editing it for use here but the sql was just too slow and we
 * don't
 * want another long-outage. It's probably slower for this section than on the
 * main upgrade as the financial_trxn table has been populated in the meantime.
 * The main upgrade sql included adding and dropping columns on tables whereas
 * here I have used LAST_INSERT_ID() to get the inserted row ids.
 *
 * OTOH we only need to deal with ~16k records to php parsing is a reasonable
 * option
 * (it might take a little while but it won't lock the tables so I don't think
 * the site would need to come down to run it).
 */
function wmf_civicrm_update_7070() {
  require_once('update_7070.php');
  _wmf_civicrm_update_7070_fill_refund_transaction_data();
}

/**
 * Remove any duplication of the 'Refunded' Contribution status.
 *
 * This status was added to WMF & then added to core - resulting in
 * 2 on WMF. The retained one should be set to reserved.
 *
 * NB I didn't add this to the install as I don't think it should be relevant
 * there.
 *
 * T116317
 *
 * @throws \CiviCRM_API3_Exception
 */
function wmf_civicrm_update_7075() {
  civicrm_initialize();
  if ((civicrm_api3('OptionValue', 'getcount', array(
      'name' => 'Refunded',
      'option_group_id' => 'contribution_status',
    ))) == 1) {
    // Nothing to do here, move along.
    return;
  }
  $options = civicrm_api3('OptionValue', 'get', array(
    'name' => 'Refunded',
    'option_group_id' =>
      'contribution_status',
    'sequential' => 1,
    'options' => array('sort' => 'id ASC'),
  ));

  if ($options['count'] != 2) {
    throw new Exception(ts('This is an unexpected state - we are only expecting to handle the situation where there is one wmf added & one core added. Please wave a wand'));
  }

  $expectedRedundantType = $options['values'][1];
  $refundValueToKeep = $options['values'][0]['value'];

  if (civicrm_api3('Contribution', 'getcount', array('contribution_status_id' => $expectedRedundantType['value']))) {
    CRM_Core_DAO::executeQuery("DELETE FROM civicrm_financial_trxn WHERE status_id = %1", array(
      1 => array(
        $expectedRedundantType['value'],
        'Integer',
      ),
    ));
    CRM_Core_DAO::executeQuery("UPDATE civicrm_contribution SET contribution_status_id = %1 WHERE contribution_status_id = %2", array(
      1 => array($refundValueToKeep, 'Integer'),
      2 => array($expectedRedundantType['value'], 'Integer'),
    ));
  }
  civicrm_api3('OptionValue', 'delete', array('id' => $expectedRedundantType['id']));
  civicrm_api3('OptionValue', 'create', array(
    'id' => $options['values'][0]['id'],
    'is_reserved' => TRUE,
  ));
}

/**
 * Add indexes that are missing from CiviCRM 4.6.
 *
 * These indexes have been added to 4.7 using the same php function.
 *
 * This function checks the index does not already exist before adding it.
 * This ensures that we will not hit a problem on upgrade as a result of adding
 * them now.
 *
 * Note this could be a slow update.
 *
 * https://github.com/civicrm/civicrm-core/pull/7672
 * https://github.com/civicrm/civicrm-core/pull/7678
 * https://github.com/civicrm/civicrm-core/pull/7673
 */
function wmf_civicrm_update_7080() {
  civicrm_initialize();
  $tables = array('civicrm_contribution' => array('creditnote_id'));
  CRM_Core_BAO_SchemaHandler::createIndexes($tables);

  $tables = array('civicrm_financial_trxn' => array('trxn_id'));
  CRM_Core_BAO_SchemaHandler::createIndexes($tables);
}

/**
 * T122947 add index to civicrm_financial item.
 *
 * The existing one does not start with entity_id so the queries that omit
 * entity_table dont' use it. It is also logically the wrong way around as the
 * one with more variation should lead.
 *
 * The upstream patch (CRM-17775) removes indexes as well. I have not ported
 * that part back at this stage as I'm viewing it as tidy up rather than a
 * performance fix and leaving 4.7.2 upgrade to catch it.
 */
function wmf_civicrm_update_7090() {
  civicrm_initialize();
  CRM_Core_BAO_SchemaHandler::createIndexes(array(
    'civicrm_financial_item' => array(array('entity_id', 'entity_table')),
  ));
}

/**
 * T124979 add Chargeback refund status and chargeback & contra account
 * relationships.
 *
 * This is the same code in 4.7.2 to add these options and is written to be
 * upgrade safe.
 */
function wmf_civicrm_update_7100() {
  civicrm_initialize();
  // First we enable and edit the record for Credit contra - this exists but is disabled for most sites.
  // Using the ensure function (below) will not enabled a disabled option (by design).
  CRM_Core_DAO::executeQuery("UPDATE civicrm_option_value v
     INNER JOIN civicrm_option_group g on v.option_group_id=g.id and g.name='account_relationship'
     SET v.is_active=1, v.label='Credit/Contra Revenue Account is', v.name='Credit/Contra Revenue Account is', v.description='Credit/Contra Revenue Account is'
     WHERE v.name = 'Credit/Contra Account is';");
  CRM_Core_BAO_OptionValue::ensureOptionValueExists(array(
    'option_group_id' => 'account_relationship',
    'name' => 'Chargeback Account is',
    'label' => ts('Chargeback Account is'),
    'is_active' => TRUE,
    'component_id' => 'CiviContribute',
  ));
  CRM_Core_BAO_OptionValue::ensureOptionValueExists(array(
    'option_group_id' => 'contribution_status',
    'name' => 'Chargeback',
    'label' => ts('Chargeback'),
    'is_active' => TRUE,
    'component_id' => 'CiviContribute',
  ));
}

/**
 * 123418 / CRM-17999 add index to civicrm_contribution.source field.
 */
function wmf_civicrm_update_7110() {
  civicrm_initialize();
  CRM_Core_BAO_SchemaHandler::createIndexes(array('civicrm_contribution' => array('source')));
}

/**
 * T124979 add a Financial Account to each Financial Type for Chargeback &
 * Refund.
 */
function wmf_civicrm_update_7120() {
  civicrm_initialize();
  $financialTypes = civicrm_api3('FinancialType', 'get', array());

  foreach (array_keys($financialTypes['values']) as $financialTypeID) {
    civicrm_api3('EntityFinancialAccount', 'create', array(
      'entity_id' => $financialTypeID,
      'entity_table' => 'civicrm_financial_type',
      'account_relationship' => 'Chargeback Account is',
      'financial_account_id' => 'Chargeback',
    ));
    civicrm_api3('EntityFinancialAccount', 'create', array(
      'entity_id' => $financialTypeID,
      'entity_table' => 'civicrm_financial_type',
      'account_relationship' => 'Credit/Contra Revenue Account is',
      'financial_account_id' => 'Refund',
    ));
  }
}

/**
 * T122946 fix financial trxn record for upgraded contributions missing
 * to_financial_account_id.
 *
 * These came about in the upgrade (this update does not need to run on
 * install) and affect the same contributions as update 7065.
 *
 * My queries suggest they all have financial_type = 'Cash' so I explicitly
 * limited to that.
 */
function wmf_civicrm_update_7130() {
  civicrm_initialize();
  $depositFinancialAccountID = civicrm_api3('FinancialAccount', 'getvalue', array(
    'return' => 'id',
    'name' => 'Deposit Bank Account',
  ));

  $cashFinancialTypeID = civicrm_api3('FinancialType', 'getvalue', array(
    'return' => 'id',
    'name' => 'Cash',
  ));
  CRM_Core_DAO::executeQuery(
    "UPDATE
     civicrm_contribution con
     LEFT JOIN civicrm_entity_financial_trxn eft ON (eft.entity_id = con.id AND eft.entity_table = 'civicrm_contribution')
     INNER JOIN civicrm_financial_trxn ft ON ft.id = eft.financial_trxn_id

     SET ft.to_financial_account_id = %1

     WHERE ft.to_financial_account_id IS NULL AND con.financial_type_id = %2",
    array(
      1 => array($depositFinancialAccountID, 'Integer'),
      2 => array($cashFinancialTypeID, 'Integer'),
    )
  );
}

/**
 * Fix financial item records with null financial_account.
 *
 * Incredibly we have only 4 of these in our database & Elliott picked up this
 * problem through spot checks!.
 *
 * Reference contact is civicrm/contact/view?reset=1&cid=11346599 - before this
 * update one of the contact's transactions does not display financial details
 * when expanded in the UI.
 *
 *  [civicrm]> SELECT count(*) FROM civicrm_financial_item WHERE
 * financial_account_id IS NULL;
 * +----------+
 * | count(*) |
 * +----------+
 * |        4 |
 * +----------+
 *
 * These relate to line items with no financial_type_id of which we have 74.
 *
 * SELECT count(*) FROM civicrm_line_item li LEFT JOIN civicrm_contribution c
 * ON c.id = li.contribution_id WHERE li.financial_type_id IS NULL;
 * +----------+
 * | count(*) |
 * +----------+
 * |       74 |
 * +----------+
 *
 * Of those 74 rows 70 are orphans - ie line items with no contributions. It
 * appears the contributions were deleted at some point in the past.
 *
 * This relates to T122946 & is a follow up fix.
 */
function wmf_civicrm_update_7150() {
  civicrm_initialize();
  $cashFinancialTypeID = civicrm_api3('FinancialType', 'getvalue', array(
    'return' => 'id',
    'name' => 'Cash',
  ));

  $cashFinancialAccountID = civicrm_api3('FinancialAccount', 'getvalue', array(
    'return' => 'id',
    'name' => 'Cash',
  ));
  // Deletes 70 orphan entries - a bit slow but I couldn't bring myself to take out the join & just filter
  // on contribution_id IS NOT NULL as it felt less safe. Takes 1-2 minutes
  CRM_Core_DAO::executeQuery("
    DELETE li
    FROM civicrm_line_item li
    LEFT JOIN civicrm_contribution c ON li.entity_id = c.id
    AND li.entity_table = 'civicrm_contribution'
    WHERE c.id IS NULL
  ");
  // Updates 4 records.
  CRM_Core_DAO::executeQuery("UPDATE civicrm_contribution SET financial_type_id = $cashFinancialTypeID WHERE financial_type_id IS NULL");
  // Updates 4 records.
  CRM_Core_DAO::executeQuery("UPDATE civicrm_line_item SET financial_type_id = $cashFinancialTypeID WHERE financial_type_id IS NULL");
  // Updates 4 records.
  CRM_Core_DAO::executeQuery("UPDATE civicrm_financial_item SET financial_account_id = $cashFinancialAccountID WHERE financial_account_id IS NULL");

}

/**
 * Further refund financial data fix.
 *
 * This is an extra record that was missing in 7070. It was obvious until the
 * patch for CRM-17951 was merged:
 *
 * CRM-17951 (merged into 4.7) modify transaction view to show the financial
 * account of the transaction
 */
function wmf_civicrm_update_7160() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery("
    INSERT INTO civicrm_entity_financial_trxn
    (entity_table, entity_id, financial_trxn_id, amount)
    SELECT  'civicrm_financial_item' as entity_table, fi.id as entity_id, cont_ft.financial_trxn_id  as financial_trxn_id, fi.amount
    FROM civicrm_financial_item fi
    LEFT JOIN civicrm_entity_financial_trxn ft  ON ft.entity_id = fi.id AND ft.entity_table = 'civicrm_financial_item'
    LEFT JOIN civicrm_line_item li ON li.id = fi.entity_id AND fi.entity_table = 'civicrm_line_item'
    LEFT JOIN civicrm_contribution c ON c.id = li.contribution_id
    LEFT JOIN civicrm_entity_financial_trxn cont_ft ON cont_ft.entity_id = c.id AND cont_ft.entity_table = 'civicrm_contribution'
    WHERE ft.id IS NULL AND fi.created_date > '2016-02-01'
  ");
}

/**
 * Further refund financial data fix.
 *
 * This is a change Elliott made on live to reflect these accounts as Expenses
 * not Income.
 *
 * Added here to ensure dev sites have the same info.
 */
function wmf_civicrm_update_7170() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery("
   UPDATE civicrm_financial_account
   SET account_type_code = 'EXP',
   financial_account_type_id = (
     SELECT v.value
     FROM civicrm_option_value v
     INNER JOIN civicrm_option_group g
       ON g.id = v.option_group_id AND g.name = 'financial_account_type'
       AND v.name = 'Expenses'
   )
   WHERE name in ('Refund', 'Chargeback')
  ");
}

/**
 * Fix e-Notice due to some Option Values not having the 'name' field filled in.
 *
 * This is just an e-notice visible in the jenkins log. It appears to do no harm
 * other than having caused me to investigate it when checking the logs.
 *
 * T127029.
 */
function wmf_civicrm_update_7180() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery("
    UPDATE civicrm_option_group g
    LEFT JOIN civicrm_option_value v ON v.option_group_id = g.id
    INNER JOIN civicrm_custom_field cf ON cf.option_group_id = g.id
    SET v.name = REPLACE(v.value, ' ', '_')
    WHERE
     v.name IS NULL
  ");
}

/**
 * T128221 add index to civicrm_contribution.total_amount.
 *
 * Note that I made this a combined index with receive_date because the ticket
 * included both criteria and they seemed likely to be used in conjunction to
 * me in other cases.
 *
 * I ran the offending search on staging afterwards and it was fast.
 */
function wmf_civicrm_update_7190() {
  civicrm_initialize();
  CRM_Core_BAO_SchemaHandler::createIndexes(array(
    'civicrm_contribution' => array(array('total_amount', 'receive_date')),
  ));
}

/**
 * Add contact deleted by merge activity.
 *
 * CRM-18106 / T119246.
 */
function wmf_civicrm_update_7200() {
  civicrm_initialize();
  CRM_Core_BAO_OptionValue::ensureOptionValueExists(array(
    'option_group_id' => 'activity_type',
    'name' => 'Contact Deleted by Merge',
    'label' => ts('Contact Deleted by Merge'),
    'description' => ts('Contact was merged into another contact'),
    'is_active' => TRUE,
    'filter' => 1,
  ));
}

/**
 * Enable setting to specify logging is handled offline.
 *
 * CRM-18212 / T127133.
 */
function wmf_civicrm_update_7205() {
  civicrm_initialize();
  civicrm_api3('System', 'flush', array(
    'triggers' => 0,
    'session' => 0,
  ));
  civicrm_api3('Setting', 'create', array(
    'logging_no_trigger_permission' => 1,
  ));
}

/**
 * Oops this activity type was added without filter = 1 being set.
 *
 * CRM-18327 / T119246.
 */
function wmf_civicrm_update_7210() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery(
    "UPDATE civicrm_option_value ov
       LEFT JOIN civicrm_option_group og ON og.id = ov.option_group_id
       SET filter = 1
       WHERE ov.name = 'Contact Deleted By Merge' AND og.name = 'activity_type'"
  );
}

/**
 * Create additional prospecting custom fields.
 */
function wmf_civicrm_update_7220() {
  require_once 'update_custom_fields.php';
  _wmf_civicrm_update_custom_fields();
}

/**
 * Set do not trade field to 0 for all contacts.
 *
 * We do not use this field.
 */
function wmf_civicrm_update_7225() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery(
    "UPDATE civicrm_contact SET do_not_trade = 0"
  );
}

/**
 * Add Endowment gifts to gift source.
 *
 * T139629
 */
function wmf_civicrm_update_7230() {
  civicrm_initialize();
  CRM_Core_BAO_OptionValue::ensureOptionValueExists(array(
    'name' => 'Endowment Gift',
    'value' => 'Endowment Gift',
    'option_group_id' => 'campaign_20080709183311',
  ));
}

/**
 * Add Endowment gift to financial type.
 *
 * T139629
 */
function wmf_civicrm_update_7235() {
  civicrm_initialize();
  wmf_civicrm_create_financial_types(array(
    'Endowment Gift',
  ));
}

/**
 * Fix next_sched_contribution_date on records affected by Aug recur bug.
 *
 * There appear to be only 8 that still need fixing before re-enabling the job.
 *
 * These 8 failed to re-process on their second attempt so were not reset.
 *
 * The others all re-processed within the affected time period and their dates
 * were pushed out
 *
 * SQL to view these 8.
 *
 * SELECT count(*) as c, contribution_recur_id, cr.contact_id,
 * group_concat(receive_date) as rdate, next_sched_contribution_date,
 * c.contribution_status_id, cr.contribution_status_id FROM
 * civicrm_contribution c LEFT JOIN civicrm_contribution_recur cr ON cr.id =
 * c.contribution_recur_id WHERE receive_date > '2016-08-31' AND
 * contribution_recur_id IS NOT NULL AND c.trxn_id LIKE 'RECURRING
 * GLOBALCOLLECT%' AND next_sched_contribution_date < '2016-09-30' GROUP BY
 * contribution_recur_id having c = 1 AND rdate < '2016-09-01';
 *
 * To view the others:
 *
 * SELECT count(*) as c, contribution_recur_id, c.contact_id,
 * group_concat(receive_date) as dates, next_sched_contribution_date,
 * GROUP_CONCAT(c.trxn_id) FROM civicrm_contribution c Left JOIN
 * civicrm_contribution_recur cr ON cr.id = c.contribution_recur_id WHERE
 * receive_date > '2016-08-30' AND contribution_recur_id IS NOT NULL AND
 * c.trxn_id LIKE 'RECURRING GLOBALCOLLECT%' GROUP BY contribution_recur_id
 * having c > 1;
 *
 * T144489
 */
function wmf_civicrm_update_7240() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery("
    UPDATE civicrm_contribution_recur
    SET
      failure_retry_date = NULL,
      failure_count = 0,
      next_sched_contribution_date = '2010-10-01',
      contribution_status_id = 5

   WHERE id IN
    (SELECT  contribution_recur_id FROM (
      SELECT count(*) as c, contribution_recur_id, cr.contact_id, group_concat(receive_date) as rdate,
      next_sched_contribution_date, c.contribution_status_id
      FROM civicrm_contribution c
      LEFT JOIN civicrm_contribution_recur cr ON cr.id = c.contribution_recur_id
      WHERE receive_date > '2016-08-31' AND contribution_recur_id IS NOT NULL AND c.trxn_id LIKE 'RECURRING GLOBALCOLLECT%'
       AND next_sched_contribution_date < '2016-09-30'
      GROUP BY contribution_recur_id having c = 1 AND rdate < '2016-09-01')
    as d )
    ");
}

/**
 * Remove placeholder email addresses.
 *
 * In the past nobody@wikimedia.org was used as a placeholder email. This is no
 * longer required and causes performance load & UI confusion on deduping.
 *
 * Bug: T143062
 */
function wmf_civicrm_update_7245() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery("DELETE FROM civicrm_email WHERE email = 'nobody@wikimedia.org'");
}

/**
 * Fix contacts who have no primary - this has arisen from the dedupes.
 *
 * I'll probably run this again once I've fixed dedupe to stop creating them
 * but this fixes the ~10000 contacts who currently don't have an address
 * marked as primary.
 *
 * Staging : (9 min 16.83 sec)
 *
 * Bug: T143062
 */
function wmf_civicrm_update_7250() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery("
    CREATE TEMPORARY TABLE civicrm_email_updates
     SELECT id FROM
      (
        SELECT contact_id, sum(is_primary) as c, e.id
        FROM civicrm_email e
        INNER JOIN civicrm_contact c ON c.id = contact_id AND is_deleted = 0
        GROUP BY contact_id HAVING c = 0
      ) as i
  ");

  CRM_Core_DAO::executeQuery("ALTER TABLE civicrm_email_updates ADD INDEX index_id(id)");
  CRM_Core_DAO::executeQuery("UPDATE civicrm_email e INNER JOIN civicrm_email_updates u ON e.id = u.id
    SET e.is_primary = 1
  ");
}

/**
 * T128221 add index to civicrm_contribution.total_amount.
 *
 * Bug: T96410
 */
function wmf_civicrm_update_7255() {
  civicrm_initialize();
  CRM_Core_BAO_SchemaHandler::createIndexes(array('civicrm_contact' => array('preferred_language')));
}

/**
 * Update the preferred_language field in civicrm_contact based on tracking
 * data.
 *
 * Bug: T96410
 */
function wmf_civicrm_update_7260() {
  civicrm_initialize();
  require_once('update_7260.php');
  _wmf_civicrm_update_7260_update_preferred_language();
}

/**
 * Clean up weird English variants from preferred_language field.
 *
 * Good bye Dutch English, Uzbekastani English etc.
 *
 * Bug: T96410
 */
function wmf_civicrm_update_7270() {
  civicrm_initialize();
  $nonUsefulEnglishes = array(
    // these ones have information in CldrData.php so don't alter.
    //'en_BE', 'en_ZA', 'en_BW', 'en_BZ', 'en_HK', 'en_IN', 'en_JM', 'en_NA', 'en_PK', 'en_SG', 'en_TT', 'en_ZW',
    'en_NZ', // :-(
    'en_EN', // en_GB instead? Only 3 - who cares.
    'en_SE', 'en_NO', 'en_NL', 'en_ES', 'en_IT', 'en_IL', 'en_DK', 'en_FR', 'en_IE',
    'en_MY', 'en_BR', 'en_RO', 'en_AT', 'en_HU', 'en_PL', 'en_MX', 'en_PT', 'en_JP',
    'en_CN', 'en_CZ', 'en_SK', 'en_GR', 'en_DE', 'en_AE', 'en_UA', 'en_TH', 'en_TW', 'en_LV', 'en_LU',
    'en_CH', 'en_PH', 'en_SI', 'en_BG', 'en_AR', 'en_HR', 'en_CL', 'en_CO', 'en_IS', 'en_LT', 'en_CY',
    'en_XX', 'en_KW', 'en_UY', 'en_QA', 'en_MT', 'en_PE', 'en_VN', 'en_CR', 'en_RS', 'en_LK', 'en_KZ',
    'en_EG', 'en_BH', 'en_DO', 'en_PR', 'en_NG', 'en_VE', 'en_EC', 'en_PA', 'en_OM',
    'en_BA', 'en_JO', 'en_KE', 'en_GT', 'en_MU', 'en_GE', 'en_AZ', 'en_AM', 'en_BN', 'en_MK',
    'en_NI', 'en_AL', 'en_BD', 'en_BS', 'en_BM', 'en_KH', 'en_BB', 'en_SV', 'en_MD', 'en_HN', 'en_MO',
    'en_NP', 'en_VI', 'en_MV', 'en_GI', 'en_KY', 'en_TZ', 'en_ET', 'en_AO', 'en_ME', 'en_MA',
    'en_MZ', 'en_AF', 'en_GU', 'en_PY', 'en_AD', 'en_FO', 'en_BO', 'en_MN', 'en_AW', 'en_UG',
    'en_FJ', 'en_GN', 'en_PG', 'en_GH', 'en_ZM', 'en_KG', 'en_GY', 'en_JE', 'en_CW', 'en_LC',
    'en_IM', 'en_BL', 'en_MC', 'en_SB', 'en_DZ', 'en_GL', 'en_HT', 'en_AG', 'en_GD', 'en_LA', 'en_UZ',
    'en_LI', 'en_PF', 'en_KN', 'en_DM', 'en_GG', 'en_NC', 'en_SC', 'en_GP', 'en_TC', 'en_VC', 'en_VG',
    'en_VU', 'en_PS', 'en_TN', 'en_MW', 'en_SX', 'en_SM', 'en_SR', 'en_SZ', 'en_FM', 'en_RE', 'en_RW',
    'en_SN', 'en_TJ', 'en_CM', 'en_AI', 'en_CK', 'en_LR', 'en_MG', 'en_LS', 'en_SL', 'en_TM', 'en_BJ',
    'en_MH', 'en_ML', 'en_WS', 'en_AS', 'en_BF', 'en_BQ', 'en_FK', 'en_GA', 'en_MP', 'en_MQ', 'en_CV',
    'en_GF', 'en_MF', 'en_MR', 'en_KR', 'en_NE', 'en_TL', 'en_RU', 'en_AX', 'en_BI', 'en_ID', 'en_TO',
    'en_FI', 'en_TR', 'en_SA', 'en_GM', 'en_GQ', 'en_HO', 'en_SP', 'en_AN', 'en_TA', 'en_SJ', 'en_IO',
    'en_PW', 'en_JA', 'en_CD', 'en_IR', 'en_UN', 'en_WW', 'en_CG', 'en_DJ', 'en_TD', 'en_TV', 'en_NF',
    'en_OS', 'en_DN', 'en_YE', 'en_ER', 'en_VA', 'en_BY', 'en_LB', 'en_IQ', 'en_MM', 'en_EH', 'en_LY',
    'en_BT', 'en_CF', 'en_SD', 'en_SS', 'en_KP', 'en_AQ', 'en_SH', 'en_CI', 'en_UM', 'en_WF',
    'en_KI', 'en_NU', 'en_SY', 'en_SO', 'en_TG', 'en_CU', 'en_HM', 'en_BV', 'en_MS',
  );
  CRM_Core_DAO::executeQuery("UPDATE civicrm_contact SET preferred_language = 'en' WHERE preferred_language IN('"
    . implode("', '", $nonUsefulEnglishes) . "')");
  // This only needs to run on production so hard-coding option_group_id seems OK.
  CRM_Core_DAO::executeQuery("UPDATE civicrm_option_value SET is_active = 0 WHERE option_group_id = 86 AND value IN('"
    . implode("', '", $nonUsefulEnglishes) . "')");
}

/**
 * Clean up legacy junk data from preferred_language field.
 *
 * This nulls out '_' junk data string (19690 rows)
 * and changes '_US' to 'en_US' (which is implied) (25387 rows).
 * plus some other oddities.
 *
 * Bug: T96410
 */
function wmf_civicrm_update_7275() {
  civicrm_initialize();
  // 19691 records.
  CRM_Core_DAO::executeQuery("UPDATE civicrm_contact SET preferred_language = NULL WHERE preferred_language = '_' OR preferred_language = '<c_US'");
  CRM_Core_DAO::executeQuery("UPDATE civicrm_contact SET preferred_language = 'en_US' WHERE preferred_language = '_US'");
  // There are some 14000 of these. They stopped being created 'half a database ago' and they have been
  // effectively treated as 'en' due to the fact the data is invalid. NULL has the same effect.
  // We could try to guess them by their country but that would break from what we have been doing and could be wrong.
  CRM_Core_DAO::executeQuery("UPDATE civicrm_contact SET preferred_language = NULL WHERE preferred_language LIKE '\_%'");
  // only 186, very old. Same consideration about choosing to set to NULL.
  CRM_Core_DAO::executeQuery("UPDATE civicrm_contact SET preferred_language = NULL WHERE preferred_language LIKE 'Do_%'");
  // 9356 with an extraneous '_' at the end
  CRM_Core_DAO::executeQuery("UPDATE civicrm_contact SET preferred_language = REPLACE(preferred_language, '_', '') WHERE RIGHT(preferred_language, 1) = '_'");
  // Just a single oddity.
  CRM_Core_DAO::executeQuery("UPDATE civicrm_contact SET preferred_language = 'zh_CN' WHERE preferred_language = '恩_CN'");
}

/**
 * Update offline message template to match thank you letter.
 *
 * The template is cut down from our standard thank you in the following ways
 *
 * 1) I pretty much by-passed translation - I’m thinking this is mostly for a
 * small number of English language receipts to be manually generated. I’d need
 * to do something more complex to get it translating well
 * 2) I ditched the RecurringRestarted & UnrecordedCharge logic. I figured you
 * would be sending these on request.
 * 3)I have assumed we have a first name & not done the fall-back to donor (on
 * assumption manual sends know the name).
 * 4) I did not include "{% if recurring %}<p> This donation is part of a
 * recurring subscription. Monthly payments will be debited by the Wikimedia
 * Foundation until you notify us to stop. If you’d like to cancel the payments
 * please see our
 * <a
 * href="https://wikimediafoundation.org/wiki/Special:LandingCheck?landing_page=Cancel_or_change_recurring_payment..
 *
 * In other words this is a pretty-simple English language solution.
 *
 * Bug T137496
 */
function wmf_civicrm_update_7280() {
  require_once 'update_receipt.php';
  _wmf_civicrm_update_offline_receipt();
}

/**
 * Re-update the message template to fix:
 *
 *  - missing currency symbol on the second reference to the amount
 *  - not using original currency/ amount where available.
 *
 * As noted in the commit message I have reservations about the approach
 * (using smarty in the template) now that I realise the template
 * only knows the label, not the machine name of the custom fields.
 *
 * This gives an immediate win but I don't think it's over.
 *
 * BUG: T137496
 */
function wmf_civicrm_update_7285() {
  require_once 'update_receipt.php';
  _wmf_civicrm_update_offline_receipt();
}

/**
 * Update the currency display setting to not have a space between currency &
 * amount.
 *
 * (based on feedback from Leanne on receipt).
 *
 * BUG: T137496
 */
function wmf_civicrm_update_7290() {
  civicrm_initialize();
  civicrm_api3('Setting', 'create', array('moneyformat' => '%c%a'));
}

/**
 * Update custom fields to match fields defined on live.
 *
 * Note that these are generally created on live by non-tech staff
 * (e.g major gifts) and we add them in the script to keep our dev
 * environments in sync.
 *
 * Bug: T147965
 */
function wmf_civicrm_update_7300() {
  require_once 'update_custom_fields.php';
  _wmf_civicrm_update_custom_fields();
}

/**
 * Remove invalid address na@na.com.
 *
 * I put this before update 7305 in case it leaves any contacts without a
 * primary.
 *
 * Only a small number of emails involved.
 *
 * Bug: T149248
 */
function wmf_civicrm_update_7303() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery('DELETE FROM civicrm_email WHERE email = "na@na.com"');
}

/**
 * Rerun fix for no primary address.
 *
 * I fixed a second cause for this (a rarer one) - make sure
 * all contacts have a primary address.
 *
 * Bug: T145873
 */
function wmf_civicrm_update_7305() {
  wmf_civicrm_update_7250();
}

/**
 * Fix contacts who have no primary address- this has arisen from the dedupes.
 *
 * I did this on emails before and but I just checked and there are around 7000
 * addresses
 *
 * Bug: T143062
 */
function wmf_civicrm_update_7315() {
  civicrm_initialize();
  $entity = 'address';
  CRM_Core_DAO::executeQuery("
    CREATE TEMPORARY TABLE civicrm_{$entity}_updates
     SELECT id FROM
      (
        SELECT contact_id, sum(is_primary) as c, e.id
        FROM civicrm_{$entity} e
        INNER JOIN civicrm_contact c ON c.id = contact_id AND is_deleted = 0
        GROUP BY contact_id HAVING c = 0
      ) as i
  ");

  CRM_Core_DAO::executeQuery("ALTER TABLE civicrm_{$entity}_updates ADD INDEX index_id(id)");
  CRM_Core_DAO::executeQuery("UPDATE civicrm_{$entity} e INNER JOIN civicrm_{$entity}_updates u ON e.id = u.id
    SET e.is_primary = 1
  ");
}

/**
 * Update existing US addresses with latitude, longitude, and time zone
 */
function wmf_civicrm_update_7320() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery("
    CREATE TEMPORARY TABLE civicrm_address_geocode (
      id INT PRIMARY KEY,
      zip CHAR(64),
      latitude DECIMAL (10,6),
      longitude DECIMAL (10,6),
      timezone VARCHAR(8)
    )");

  CRM_Core_DAO::executeQuery("INSERT INTO civicrm_address_geocode (id, zip)
     SELECT id, LEFT(postal_code, 5)
     FROM civicrm_address
     WHERE country_id = (SELECT id FROM civicrm_country WHERE iso_code = 'US')
  ");

  CRM_Core_DAO::executeQuery("ALTER TABLE civicrm_address_geocode ADD INDEX index_zip(zip)");

  CRM_Core_DAO::executeQuery("
    UPDATE civicrm_address_geocode c
    INNER JOIN civicrm_geocoder_zip_dataset g ON c.zip = g.zip
    SET c.latitude = g.latitude,
      c.longitude = g.longitude,
      c.timezone = g.timezone
  ");

  $batch = 100000;
  for ($startId = 0; $startId < 21000000; $startId += $batch) {
    $endId = $startId + $batch;
    CRM_Core_DAO::executeQuery("
      UPDATE civicrm_address a
      INNER JOIN civicrm_address_geocode c ON c.id = a.id
      SET a.geo_code_1 = c.latitude,
        a.geo_code_2 = c.longitude,
        a.timezone = c.timezone
      WHERE a.id BETWEEN $startId AND $endId
    ");
  }
}

/**
 * Backfill gift so that donations of $1000+ have a gift source.
 *
 * These fields have defaults which will have been used if the table is
 * touched at all during the update. As this stage I think we are just filling
 * missing data.
 *
 * T138361
 */
function wmf_civicrm_update_7325() {
  civicrm_initialize();
  $customGroup = civicrm_api3('CustomGroup', 'getsingle', array(
    'name' => 'Gift_Data',
    'return' => 'table_name',
  ));
  $customField = civicrm_api3('CustomField', 'getsingle', array(
    'name' => 'Campaign',
    'return' => 'column_name',
  ));

  CRM_Core_DAO::executeQuery("INSERT INTO {$customGroup['table_name']} (entity_id, {$customField['column_name']})
    SELECT c.id as entity_id, 'Benefactor Gift' as {$customField['column_name']}
    FROM civicrm_contribution c
    LEFT JOIN {$customGroup['table_name']} v ON v.entity_id = c.id
    WHERE c.total_amount >= 1000 AND v.id IS NULL
  ");

}

/**
 * Fix rounding of lat/long caused by DOUBLE wierdness.
 *
 * T150305
 */
function wmf_civicrm_update_7330() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery("
    UPDATE civicrm_address
    SET geo_code_1 = ROUND(geo_code_1, 6),
    geo_code_2 = ROUND(geo_code_2, 6)
    WHERE geo_code_1 IS NOT NULL;
  ");
}

/**
 * Text updates to the Thank you letter.
 *
 * Bug T151814
 */
function wmf_civicrm_update_7335() {
  require_once 'update_receipt.php';
  _wmf_civicrm_update_offline_receipt();
}

/**
 * Remove review tag.
 *
 * Bug: T118904
 */
function wmf_civicrm_update_7440() {
  civicrm_initialize();
  $tagID = civicrm_api3('Tag', 'getvalue', array(
    'name' => 'Review',
    'return' => 'id',
  ));
  CRM_Core_DAO::executeQuery("
    DELETE FROM civicrm_entity_tag
    WHERE tag_id = $tagID
    AND entity_table = 'civicrm_contact'
  ");
}

/**
 * Re-run fixed geocoding updates
 *
 * Bug: T155677
 */
function wmf_civicrm_update_7450() {
  wmf_civicrm_update_7320();
}

/**
 * Add index to nick_name column as we have decided to use it for imports.
 *
 * We have decided the Benevity Import should accept org matches on nick_name
 * or organization_name in order to provide the option to refer to them with
 * 2 names. In order to use it it must be indexed. Note that I believe the
 * index size is relative to the number of values in it (currently a few
 * hundred).
 *
 * Bug: T115044
 */
function wmf_civicrm_update_7455() {
  civicrm_initialize();
  $tables = array('civicrm_contact' => array('nick_name'));
  CRM_Core_BAO_SchemaHandler::createIndexes($tables);
}

/**
 * Add index to activity_date_time column.
 *
 * Without this index activities are basically unsearchable as we need to limit
 * them to a time frame to make it manageable.
 *
 * Some performance discussion here.
 *
 * https://issues.civicrm.org/jira/browse/CRM-19821
 */
function wmf_civicrm_update_7460() {
  civicrm_initialize();
  $tables = array('civicrm_activity' => array('activity_date_time'));
  CRM_Core_BAO_SchemaHandler::createIndexes($tables);
}

/**
 * Adjust contribution date on 4 recurring contributions to get past blockage.
 *
 * https://phabricator.wikimedia.org/T159298#3063457
 *
 * T159298
 */
function wmf_civicrm_update_7465() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery("
    UPDATE civicrm_contribution_recur
    SET next_sched_contribution_date = '2017-04-01'
    WHERE id IN (163431,163364,59477,59458)
    AND next_sched_contribution_date IN ('2017-03-28', '2017-03-27')
  ");
}

/**
 * Re-run geocoding update, many not updated.
 *
 * Bug T158271.
 */
function wmf_civicrm_update_7470() {
  wmf_civicrm_update_7320();
}

/**
 * Create table of all candidates for blank address fixes.
 *
 * We will delete from here as we resolve them.
 *
 * Bug: T159396
 */
function wmf_civicrm_update_7475() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery(
    "CREATE TABLE IF NOT EXISTS blank_addresses
     SELECT *
     FROM log_civicrm_address
     WHERE street_address IS NULL
     AND city IS NULL
     AND postal_code IS NULL
     AND state_province_id IS NULL
     AND country_id IS NULL
    "
  );
  CRM_Core_DAO::executeQuery(
    "ALTER TABLE blank_addresses ADD INDEX index_id(id), ADD INDEX index_log_action(log_action)"
  );
}

/**
 * Fill in missing first and last names from the sort_name field
 *
 * Bug: T159455
 */
function wmf_civicrm_update_7480() {
  civicrm_initialize();
  // First the easy ones
  CRM_Core_DAO::executeQuery(
    "UPDATE civicrm_contact
		SET last_name = SUBSTRING_INDEX(sort_name, ', ', 1),
			first_name = SUBSTRING_INDEX(sort_name, ', ', -1)
		WHERE created_date BETWEEN '2017-02-28' AND '2017-03-03'
		AND contact_type = 'Individual'
		AND first_name IS NULL
		AND last_name IS NULL
		AND sort_name LIKE '%, %'
    ");
  // Some of the contacts have been touched since creation, and Civi has helpfully
  // destroyed the sort_name. log_civicrm_contact to the rescue!
  CRM_Core_DAO::executeQuery("
create temporary table tmp_T159455
select
    id,
	-- Include null columns as placeholders.
	first_name,
	last_name
from civicrm_contact
where
    created_date between '2017-02-28' and '2017-03-03'
    and contact_type = 'Individual'
    and first_name is null
    and last_name is null
		");

  CRM_Core_DAO::executeQuery("
update tmp_T159455 t
inner join log_civicrm_contact l
    on t.id = l.id
set
    t.last_name = substring_index(l.sort_name, ', ', 1),
    t.first_name = substring_index(l.sort_name, ', ', -1)
where
    l.sort_name like '%, %'
		");

  // Set the names using the API in order to refresh calculations.
  $query = "
		select * from tmp_T159455
		where first_name is not null
			and last_name is not null
	";
  $dao = CRM_Core_DAO::executeQuery($query);
  while ($dao->fetch()) {
    civicrm_api3('Contact', 'create', array(
      'id' => $dao->id,
      'first_name' => $dao->first_name,
      'last_name' => $dao->last_name,
    ));
  }
}

/**
 * Remove blank addresses that were created blank & have not been updated.
 *
 * Bug: T159402
 */
function wmf_civicrm_update_7485() {
  civicrm_initialize();
  $batch = 50000;
  // arbitrary start.
  $count = 1;
  while ($count > 0) {
    CRM_Core_DAO::executeQuery("
    CREATE TABLE blanks_to_go
    SELECT b.id
    FROM blank_addresses b
    INNER JOIN civicrm_address a
      ON a.id = b.id
    LEFT JOIN log_civicrm_address c
      ON c.id = b.id
      AND c.log_action <> b.log_action
      AND c.log_conn_id NOT IN ('" . implode("','", wmf_civicrm_get_log_conn_bulk_update()) . "')
      AND (
        c.contact_id <> b.contact_id
        OR (
          c.city IS NOT NULL
          OR c.postal_code IS NOT NULL
          OR c.state_province_id IS NOT NULL
          OR c.country_id IS NOT NULL
          OR c.street_address IS NOT NULL
        )
      )
    WHERE
      a.street_address IS NULL
      AND a.city IS NULL
      AND a.country_id IS NULL
      AND a.postal_code IS NULL
      AND a.state_province_id IS NULL
      AND b.log_action IN ('Initialization', 'Insert')
      AND c.id IS NULL
      LIMIT $batch
    ");
    $count = CRM_Core_DAO::singleValueQuery('SELECT count(*) FROM blanks_to_go');

    CRM_Core_DAO::executeQuery(
      "DELETE a
       FROM civicrm_address a
       WHERE id IN (
        SELECT b.id
        FROM blanks_to_go b
       )
     "
    );

    CRM_Core_DAO::executeQuery(
      "DELETE a
       FROM blanks_to_go b
       INNER JOIN blank_addresses a ON a.id = b.id
     "
    );

    CRM_Core_DAO::executeQuery(
      "DROP TABLE blanks_to_go"
    );

  }

}

/**
 *
 * Remove obsolete blank address from tracking table.
 *
 * The blank_addresses table tracks blanked addresses. This
 * function removes addresses from that table that were inserted as blanks,
 * later deleted while still blanks and which did not have an updates made.
 *
 * In some cases an update may have been made without adding data. This
 * could involve either fixing the is_primary flag or updating the contact in
 * a merge. However, we know the record has been deleted and never had any
 * retrievable data on it.
 *
 * In other words we don't need to track these as they were fully resolved
 * already.
 *
 * 21590 rows so we don't need to batch.
 *
 * Bug: T159396
 */
function wmf_civicrm_update_7490() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery("
    CREATE TABLE blanks_to_go
    SELECT i.id
    FROM blank_addresses i
    INNER JOIN blank_addresses d
      ON i.id = d.id
      AND i.log_action  IN ('Insert', 'Initialization')
      AND d.log_action = 'Delete'
    LEFT JOIN log_civicrm_address l
      ON l.id = i.id AND l.log_action = 'Update'
      AND (
       l.country_id IS NOT NULL
       OR l.state_province_id IS NOT NULL
       OR l.street_address IS NOT NULL
       OR l.postal_code IS NOT NULL
       OR l.city IS NOT NULL
      )
      AND l.log_conn_id NOT IN ('" . implode("','", wmf_civicrm_get_log_conn_bulk_update()) . "')
    WHERE l.id IS NULL
    ");

  CRM_Core_DAO::executeQuery(
    "DELETE a
       FROM blanks_to_go b
       INNER JOIN blank_addresses a ON a.id = b.id
     "
  );

  CRM_Core_DAO::executeQuery(
    "DROP TABLE blanks_to_go"
  );

}

/**
 *
 * Remove blank addresses relating to bulk updates from tracking table.
 *
 * There is a small number of addresses (only 130) which were only updated
 * as part of the geocoding updates, some more are affected by primary address
 * fixes
 *
 * . Remove these to be less confusing.
 *
 * Bug: T159396
 */
function wmf_civicrm_update_7495() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery("
    DELETE FROM blank_addresses WHERE log_conn_id IN (
    '" . implode("','", wmf_civicrm_get_log_conn_bulk_update()) . "')");
}

/**
 * Get the log connection ids for known bulk updates to we can
 * remove them from the update records we are considering.
 *
 * @return array
 */
function wmf_civicrm_get_log_conn_bulk_update() {
  return array(
    // Bulk update on 2017-02-07 involving 11712 records.
    // Consistent with the fix to primary addresses.
    // I committed the relevant fix on
    // commit 7b287e68292da1ae161aa2383808d8925af4a583
    // Author: eileen <emcnaughton@wikimedia.org>
    // Date:   Thu Feb 2 15:41:58 2017 +1300
    '589a35f1e77ec',
    // Buld update on 2016-11-02 involving 4458473 records
    // Consistent with first attempt to add (non-rounded) geocodes.
    //commit e4bf03d321f975a21510337f75e088c235c49521
    // Author: Elliott Eggleston <ejegg@ejegg.com>
    // Date:   Tue Nov 1 14:18:31 2016 -0500
    // Geocode existing US addresses
    '581939a5f3bc8',
    // Bulk update on 2016-11-09 21:28:43 involving 4715708 records
    // consistent with fixing the rounding on prior changes.
    //commit 25558f9b27b2b2d0be17d1dd25e16ff4d0708a96
    // Author: eileen <emcnaughton@wikimedia.org>
    // Date:   Thu Nov 10 10:01:36 2016 +1300
    // Fix rounding of lat/long caused by DOUBLE wierdness.
    // (note I think the commit is in my tz).
    '5823950b11501',
  );

}

/**
 * Add benevity as a financial type for benevity imports.
 *
 * Bug: T115044
 */
function wmf_civicrm_update_7500() {
  civicrm_initialize();
  wmf_civicrm_create_financial_types(array('Benevity'));
}

/**
 * Rerun 7845 & 7490 with a slightly bigger catchment.
 *
 * This means that addresses with updates that only affect bulk updates on
 * things like geocode & is_primary will also be treated as 'non-updated' &
 * removed from the db if blank.
 */
function wmf_civicrm_update_7505() {
  wmf_civicrm_update_7485();
  wmf_civicrm_update_7490();
}

/**
 * Set street address/ postal_code to NULL where placeholder info has been used.
 *
 * Note that all addresses in the DB with N0NE PROVIDED or 0 postal_code have a
 * country_id so this is really precautionary, but we would want to delete the
 * address if it were blank, rather than update it.
 *
 * Bug: T158268
 */
function wmf_civicrm_update_7510() {
  wmf_civicrm_remove_bad_data_from_field('civicrm_address', 'street_address', array('N0NE PROVIDED'));
  wmf_civicrm_remove_bad_data_from_field('civicrm_address', 'postal_code', array('0'));
}

/**
 * Remove bad data from an address field in a batched manner.
 *
 * @param string $tableName
 * @param string $fieldName
 *   Field name to update
 * @param array $fieldValues
 *   Values to strip out.
 */
function wmf_civicrm_remove_bad_data_from_field($tableName, $fieldName, $fieldValues) {

  civicrm_initialize();

  foreach ($fieldValues as $fieldValue) {
    $whereClause = "WHERE $fieldName = '{$fieldValue}'";
    $setClause = "SET a.{$fieldName} = NULL";
    wmf_civicrm_batch_update_data($tableName, $whereClause, $setClause);
  }
}

/**
 * Update civicrm data in batches.
 *
 * @param string $tableName
 *   Name of table to update.
 * @param string string $whereClause
 *   Where clause to apply
 * @param string $setClause
 *   SET clause to apply.
 * @param int $batchSize
 *   Number to process per iteration
 */
function wmf_civicrm_batch_update_data($tableName, $whereClause, $setClause, $batchSize = 10000) {
  $nextId = 1;
  while ($nextId > 0) {
    CRM_Core_DAO::executeQuery("
        CREATE TEMPORARY TABLE {$tableName}_to_update
        SELECT id FROM {$tableName}
        $whereClause
        LIMIT $batchSize
      ");
    CRM_Core_DAO::executeQuery("
        ALTER TABLE {$tableName}_to_update
        ADD INDEX(id)
      ");
    CRM_Core_DAO::executeQuery("
        UPDATE {$tableName}_to_update t
        INNER JOIN {$tableName} a
        ON t.id = a.id
        $setClause
      "
    );
    $nextId = CRM_Core_DAO::singleValueQuery("
        SELECT id
        FROM {$tableName}
        $whereClause
        LIMIT 1
      ");
    CRM_Core_DAO::executeQuery("DROP TEMPORARY TABLE {$tableName}_to_update");
  }
}

/**
 * Backfill contribution_tracking associations for recurring donations
 *
 * Bug: T163443
 */
function wmf_civicrm_update_7520() {
  civicrm_initialize();
  $affected = CRM_Core_DAO::executeQuery("
    SELECT cont.id, ext.gateway_txn_id
    FROM civicrm_contribution cont
    INNER JOIN wmf_contribution_extra ext on ext.entity_id = cont.id
    LEFT JOIN drupal.contribution_tracking ct
    ON ct.contribution_id = cont.id
    WHERE cont.trxn_id LIKE 'RECURRING PAYPAL%'
    AND cont.receive_date > '2017-04-09'
    AND ct.id IS NULL
  ");
  $found = [];
  $logDir = wmf_audit_get_log_archive_dir();
  $lines = array();
  // These lines will have the gateway_trxn_id and the ct_id
  $files = implode(' ', glob("$logDir/fundraising-drupal-201704*"));
  $cmd = "/bin/zgrep subscr_payment $files";
  exec($cmd, $lines);
  foreach ($lines as $line) {
    $parsed = wmf_civicrm_parse_watchdog_array($line);
    if (
      !empty($parsed['gateway_txn_id']) &&
      !empty($parsed['contribution_tracking_id'])
    ) {
      // Normalized lines
      $found[$parsed['gateway_txn_id']] = $parsed['contribution_tracking_id'];
    }
    else {
      if (!empty($parsed['txn_id'])) {
        // Raw PayPal IPNs
        if (
          !empty($parsed['transaction_subject']) &&
          is_numeric($parsed['transaction_subject'])
        ) {
          $found[$parsed['txn_id']] = $parsed['transaction_subject'];
        }
        else {
          if (
            !empty($parsed['custom']) &&
            is_numeric($parsed['custom'])
          ) {
            $found[$parsed['txn_id']] = $parsed['custom'];
          }
        }
      }
    }
  }
  $fixed = 0;
  $missing = 0;
  while ($affected->fetch()) {
    $gatewayTxnId = $affected->gateway_txn_id;
    if (empty($found[$gatewayTxnId])) {
      $missing++;
    }
    else {
      wmf_civicrm_message_update_contribution_tracking(
        array('contribution_tracking_id' => $found[$gatewayTxnId]),
        array('id' => $affected->id)
      );
      $fixed++;
    }
  }
}

/**
 * Normalize old phone numbers
 **/
function wmf_civicrm_update_7522() {
  civicrm_initialize();
  $maxId = CRM_CORE_DAO::singleValueQuery("SELECT max(id) FROM civicrm_phone");
  $batch = 100000;
  for ($startId = 0; $startId < $maxId; $startId += $batch) {
    $endId = $startId + $batch;
    CRM_Core_DAO::executeQuery("
      UPDATE civicrm_phone
      SET phone_numeric = civicrm_strip_non_numeric(phone)
      WHERE id BETWEEN $startId AND $endId
    ");
  }
}

/**
 * Add correct currency symbols
 */
function wmf_civicrm_update_7523() {
  require_once('update_7523.php');
  _wmf_civicrm_update_7523_insert_currency_symbols();
}

/**
 * Add duplicate contribution tag
 */
function wmf_civicrm_update_7524() {
  civicrm_initialize();
  $tag = array(
    'name' => 'DuplicateInvoiceId',
    'used_for' => 'civicrm_contribution',
    'description' => 'Used for contributions where the original assigned invoice id was a duplicate with another already in the database',
    'is_reserved' => 1, //WIP: What does this mean?
    'selectable' => 0,
  );
  civicrm_api3('Tag', 'Create', $tag);
}

/**
 * Enable CiviCampaign.
 */
function wmf_civicrm_update_7525() {
  wmf_civicrm_bootstrap_civi();
  $components = civicrm_api3('Setting', 'getvalue', array(
    'name' => "enable_components",
  ));
  if (isset($components['is_error'])) {
    // weirdness.
    unset($components['is_error']);
  }
  $components[] = 'CiviCampaign';
  civicrm_api3('Setting', 'create', array('enable_components' => $components));
}

/**
 * Add index to name field on civicrm_campaign.
 *
 * Bug: T168499
 */
function wmf_civicrm_update_7526() {
  civicrm_initialize();
  $tables = array('civicrm_campaign' => array('name'));
  CRM_Core_BAO_SchemaHandler::createIndexes($tables);
}

/**
 * Remove void data from city field & tidy name field data.
 */
function wmf_civicrm_update_7540() {
  wmf_civicrm_remove_bad_data_from_field('civicrm_address', 'city', array(
    'city',
    '0',
    'City/Town',
    'NoCity',
  ));
  wmf_civicrm_remove_bad_data_from_field('civicrm_address', 'postal_code', array('0'));
  $replacements = array(
    array(
      // Non breaking space. If we don't sort out these odd spaces
      // first the replace spaces line doesn't work on them & we get an endless loop.
      // Although the LIKE BINARY down further probably now mitigates.
      'find' => "C2A0",
      'replace_with' => ' ',
      'fields' => array('first_name', 'last_name'),
      'is_binary' => TRUE,
      'like_clause' => "BINARY CONCAT('%', unhex('C2A0'), '%')",
    ),
    array(
      // IDEOGRAPHIC SPACE
      // http://www.fileformat.info/info/unicode/char/3000/index.htm
      'find' => "E38080",
      'replace_with' => ' ',
      'fields' => array('first_name', 'last_name'),
      'is_binary' => TRUE,
      'like_clause' => "BINARY CONCAT('%', unhex('E38080'), '%')",
    ),
    array(
      'find' => '  ',
      'replace_with' => ' ',
      'fields' => array('first_name', 'last_name'),
    ),
    array(
      'find' => '&amp;',
      'replace_with' => '&',
      'fields' => array('first_name', 'last_name'),
    ),
    array(
      'find' => '&Amp;',
      'replace_with' => '&',
      'fields' => array('first_name', 'last_name'),
    ),
  );
  foreach ($replacements as $replacement) {
    $likeClause = "'%{$replacement['find']}%'";
    $findString = "'{$replacement['find']}'";
    if (!empty($replacement['is_binary'])) {
      $likeClause = $replacement['like_clause'];
      $findString = "UNHEX('{$replacement['find']}')";
    }
    foreach ($replacement['fields'] as $field) {
      wmf_civicrm_batch_update_data(
        'civicrm_contact',
        "WHERE $field LIKE BINARY $likeClause",
        "SET a.{$field} = REPLACE({$field}, {$findString}, '{$replacement['replace_with']}')"
      );
    }
  }

}

/**
 * Clean up CiviCRM groups.
 *
 * T174407.
 */
function wmf_civicrm_update_7545() {
  // This has now run on live & may not run on people's locals so
  // hack it down now.
  return;
  require_once('update_7545.php');
  _wmf_civicrm_cleanup_groups();
}

/**
 * Add country-only addresses omitted because of T178316
 *
 * Contributions imported between 2017-10-12 19:47 and
 * 2017-10-16 23:39 were affected. IDs were gleaned from
 * donation queue consumer logs.
 */
function wmf_civicrm_update_7550() {
  civicrm_initialize();
  $query = 'SELECT cc.id, cc.contact_id
    FROM civicrm_contribution cc
    LEFT JOIN civicrm_address a on cc.contact_id = a.contact_id
    WHERE a.id IS NULL
    AND cc.id BETWEEN 25045410 AND 25147673';
  $dao = CRM_Core_DAO::executeQuery($query);
  while ($dao->fetch()) {
    $trackingCountry = db_select('contribution_tracking', 'ct')
      ->fields('ct', array('country'))
      ->condition('contribution_id', $dao->id)
      ->execute()
      ->fetchField();
    if (!$trackingCountry) {
      continue;
    }
    $countryId = wmf_civicrm_get_country_id($trackingCountry);
    if (!$countryId) {
      continue;
    }
    civicrm_api3(
      'Address',
      'create',
      array(
        'contact_id' => $dao->contact_id,
        'country_id' => $countryId,
        'location_type_id' => 1,
      )
    );
  }
}

/**
 * Fix contacts with two primary addresses
 */
function wmf_civicrm_update_7560() {
  civicrm_initialize();
  $query = 'SELECT contact_id
    FROM civicrm_address
    WHERE is_primary=1
    AND contact_id IS NOT NULL
    GROUP BY contact_id
    HAVING COUNT(*) > 1';
  $contactIds = CRM_Core_DAO::executeQuery($query);
  while ($contactIds->fetch()) {
    $addresses = civicrm_api3(
      'Address',
      'get',
      array(
        'contact_id' => $contactIds->contact_id,
        'is_primary' => 1,
      )
    );
    $bestAddress = NULL;
    $addressesToDelete = array();
    $addressesToDemote = array();
    foreach ($addresses['values'] as $address) {
      if ($bestAddress === NULL) {
        $bestAddress = $address;
      }
      else {
        if (_wmf_civicrm_is_this_address_better($address, $bestAddress)) {
          // previous best address is a subset of current address
          $addressesToDelete[] = $bestAddress;
          $bestAddress = $address;
        }
        elseif (_wmf_civicrm_is_this_address_better($bestAddress, $address)) {
          // current address is a subset of previous best address
          $addressesToDelete[] = $address;
        }
        elseif ($address['id'] > $bestAddress['id']) {
          // neither is a subset, current is newer than previous best
          $addressesToDemote[] = $bestAddress;
          $bestAddress = $address;
        }
        else {
          // neither is a subset, previous best is newer
          $addressesToDemote[] = $address;
        }
      }
    }
    foreach ($addressesToDelete as $deleteMe) {
      civicrm_api3('Address', 'delete', array('id' => $deleteMe['id']));
    }
    foreach ($addressesToDemote as $demoteMe) {
      $dao = _civicrm_api3_load_DAO('Address');
      $dao->id = $demoteMe['id'];
      $dao->is_primary = 0;
      $dao->update();
    }
  }
}

/*
 * Update Contact Deleted by Merge activies
 */
function wmf_civicrm_update_7565() {
  civicrm_initialize();
  $batch = 100;
  $maxId = CRM_Core_DAO::singleValueQuery("SELECT max(id) FROM civicrm_activity");
  $activity_type_id = civicrm_api3('OptionValue', 'getSingle', array(
    'label' => 'Contact Deleted by Merge',
    'return' => 'value',
  ));
  $query = "SELECT ca.id as activity_id, cap.contact_id as new_contact_id
             FROM civicrm_activity ca
             JOIN civicrm_activity_contact cap ON ca.parent_id=cap.activity_id AND cap.record_type_id=3
             WHERE (SELECT count(*) FROM civicrm_activity_contact WHERE record_type_id=1 AND activity_id=ca.id)=0
             AND ca.activity_type_id=%1 AND ca.id BETWEEN %2 AND %3";
  $params = array(1 => array($activity_type_id['value'], 'Integer'));
  for ($startId = 0; $startId < $maxId; $startId += $batch) {
    $endId = $startId + $batch;
    $params[2] = array($startId, 'Integer');
    $params[3] = array($endId, 'Integer');
    $activities = CRM_Core_DAO::executeQuery($query, $params);
    while ($activities->fetch()) {
      civicrm_api3('ActivityContact', 'create', array(
        'activity_id' => $activities->activity_id,
        'contact_id' => $activities->new_contact_id,
        'record_type_id' => 1,
      ));
    }
  }
}

/**
 * Tidy up our dedupe rules.
 */
function wmf_civicrm_update_7570() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery("UPDATE civicrm_dedupe_rule_group SET name = 'IndividualSupervised' WHERE name = 'Kaldari Rule-9'");
  // This didn't cascade right in single query so 2 deletes.
  CRM_Core_DAO::executeQuery("DELETE r FROM civicrm_dedupe_rule_group rg LEFT JOIN civicrm_dedupe_rule r ON r.dedupe_rule_group_id = rg.id WHERE name = 'IndividualSupervised2_14'");
  CRM_Core_DAO::executeQuery("DELETE FROM civicrm_dedupe_rule_group WHERE name = 'IndividualSupervised2_14'");

  $generalRules = CRM_Core_DAO::singleValueQuery(
    "SELECT count(*) FROM civicrm_dedupe_rule_group WHERE used = 'General' AND is_reserved = 1 AND contact_type = 'Individual'"
  );
  if ($generalRules > 1) {
    // Otherwise we are probably on someone's dev environment. Goal here is to remove duff data from prod not mess with people (much).
    CRM_Core_DAO::executeQuery("
      DELETE r FROM civicrm_dedupe_rule_group rg
      LEFT JOIN civicrm_dedupe_rule r ON r.dedupe_rule_group_id = rg.id
      WHERE used = 'General' AND is_reserved = 1 AND contact_type = 'Individual' AND rg.id IN(10,11)
    ");
    CRM_Core_DAO::executeQuery("
      DELETE FROM civicrm_dedupe_rule_group
      WHERE used = 'General' AND is_reserved = 1 AND contact_type = 'Individual' AND id IN(10,11)
    ");
  }

  // Create a new rule group that will catch a broad range of contacts (but should only be
  // used against a narrow one for performance reasons.
  // This is to help major gifts pull up a screen of possible matches rather than
  // trawling for them.
  //
  // Struggling to think of a precise name / description so going for something
  // people should remember. Am tempted to add a 'Go Fish' button to contact dash now.
  // This rule is set up on staging and can be accessed from a contact record
  // under the drop down actions. I tried it on a few fairly common names (John Smith)
  // and there was some lag in those cases but not that bad & certainly better than doing searches.
  $ruleGroup = civicrm_api3('RuleGroup', 'create', array(
    'name' => 'fishing_net',
    'title' => 'Fishing Net',
    'contact_type' => 'Individual',
    'used' => 'General',
    'threshold' => 150,
  ));

  $queryStart = "INSERT INTO civicrm_dedupe_rule (dedupe_rule_group_id, rule_table, rule_field, rule_weight) VALUES ({$ruleGroup['id']}, ";

  // Only 5 rule-criteria can be configured in the UI but more will work if added.
  // An email match alone is enough to hit the threshold.
  CRM_Core_DAO::executeQuery($queryStart . "'civicrm_email', 'email', 150 )");

  // Last name is enough if the street address is the same OR the
  // first name is the same too and either state or city is the same.
  // There are some odd street address ones -
  CRM_Core_DAO::executeQuery($queryStart . "'civicrm_contact', 'last_name', 120 )");
  CRM_Core_DAO::executeQuery($queryStart . "'civicrm_contact', 'first_name', 25 )");
  CRM_Core_DAO::executeQuery($queryStart . "'civicrm_address', 'street_address', 30 )");
  CRM_Core_DAO::executeQuery($queryStart . "'civicrm_address', 'city', 10 )");
  CRM_Core_DAO::executeQuery($queryStart . "'civicrm_address', 'state_province_id', 5 )");
}

/**
 * Enable dedupe tools.
 *
 * This extension is intended to be where our custom dedupe code gets
 * transferred to.
 *
 * Bug: T177999
 */
function wmf_civicrm_update_7575() {
  wmf_civicrm_reconcile_extensions();
}

function wmf_civicrm_reconcile_extensions() {
  require_once 'update_extensions.php';
  wmf_install_add_missing_extensions();
}

/**
 * Enable extended report.
 *
 * This extension gives us the Address History tab.
 *
 * Bug: T142549
 */
function wmf_civicrm_update_7580() {
  wmf_civicrm_reconcile_extensions();
}

/**
 * Add report for Address History tab.
 *
 * Bug: T142549
 */
function wmf_civicrm_update_7585() {
  civicrm_initialize();
  civicrm_api3('ReportInstance', 'create', array(
    'title' => ts('Address History'),
    'report_id' => 'contact/addresshistory',
    'description' => 'ContactAddress History',
    'permission' => 'access CiviReport',
    'form_values' => serialize(array(
      'fields' => array(
        'address_display_address' => 1,
        'log_date' => 1,
        'address_location_type_id' => 1,
        'address_is_primary' => 1,
        'log_conn_id' => 1,
        'log_user_id' => 1,
        'log_action' => 1,
      ),
      'contact_dashboard_tab' => array('contact_dashboard_tab' => '1'),
    )),
  ));
}

/**
 * Add Stripe payment instrument
 */
function wmf_civicrm_update_7595() {
  require_once 'update_payment_instruments.php';
  wmf_install_add_missing_payment_instruments();
}

/**
 * Re-save any contacts without a display name.
 *
 * Doing a blank re-save will cause the display name to be recalculated by Civi
 * rules.
 *
 * Not useful here but possibly for Major Gifts letter addressing it also
 * will allow us to update addressing fields (e.g Dear Fred) for sending letters.
 * We don't do that for all contacts but could for MG.
 *
 * Bug: T179118
 */
function wmf_civicrm_update_7600() {
  civicrm_initialize();
  $result = CRM_Core_DAO::executeQuery(
    "SELECT id FROM civicrm_contact WHERE (display_name is null  OR display_name = '') AND is_deleted= 0"
  );
  while ($result->fetch()) {
    civicrm_api3('Contact', 'create', array('id' => $result->id));
  }
}

/**
 * Add contact type editor extension.
 *
 * Bug: TT156193
 */
function wmf_civicrm_update_7605() {
  wmf_civicrm_reconcile_extensions();
}

/**
 * Add civitoken extension.
 *
 * We want the formatted address blocks from here.
 *
 * We disable most of the others to keep things clean.
 *
 * Bug: T184647
 */
function wmf_civicrm_update_7610() {
  wmf_civicrm_reconcile_extensions();
  civicrm_api3('Setting', 'create', array('civitoken_enabled_tokens' => array(
    'address.address_block',
    'address.address_text',
    'address.conditional_country',
    'date.today_format_full',
    'date.today_format_raw',
  )));
}

/**
 * Add geocoder extension.
 *
 * Disable geocoders we don't want.
 *
 * Bug: T184830
 */
function wmf_civicrm_update_7615() {
  wmf_civicrm_ensure_correct_geocoder_enabled();
}

/**
 * Create table contribution_source if not existant.
 *
 * Not quite sure why this would not exist locally but create it if needed to
 * keep the script on the road.
 *
 * Correct answer is something like the contribution_tracking.install file.
 */
function wmf_civicrm_update_7617() {
  db_query("CREATE TABLE IF NOT EXISTS `contribution_source`  (
    `contribution_tracking_id` int(10) unsigned NOT NULL,
    `banner` varchar(128) DEFAULT NULL,
    `landing_page` varchar(128) DEFAULT NULL,
    `payment_method` varchar(128) DEFAULT NULL,
    PRIMARY KEY (`contribution_tracking_id`),
    KEY `banner` (`banner`),
    KEY `landing_page` (`landing_page`),
    KEY `payment_method` (`payment_method`)
  ) ENGINE=InnoDB"
  );
}
/**
 * Cancel unintended Ingenico subscriptions
 *
 * Bug: T186833
 */
function wmf_civicrm_update_7620() {
  civicrm_initialize();
  global $databases;
  $drupal = $databases['default']['default']['database'];
  CRM_Core_DAO::executeQuery(
    "UPDATE civicrm_contribution_recur AS cr
     INNER JOIN civicrm_contribution AS cc on cc.contribution_recur_id = cr.id
     INNER JOIN {$drupal}.contribution_tracking AS ct on ct.contribution_id = cc.id
     INNER JOIN {$drupal}.contribution_source AS cs on ct.id = cs.contribution_tracking_id
     SET cr.cancel_date = '2018-3-13 01:23:45'
     WHERE ct.ts >= '20171130000000'  and ct.ts <= '20171204213500'
     AND cc.trxn_id LIKE '%RECURRING GLOBALCOLLECT%'
     AND (isnull(cr.end_date) and isnull(cr.cancel_date))
     AND cs.banner IN ('B1718_113016_en6C_ipd_p1_lg_txt_awk',
     'B1718_113016_en6C_ipd_p1_lg_txt_awkdead',
     'B1718_113016_en6C_ipd_p1_lg_txt_awkemb',
     'B1718_113016_en6C_ipd_p1_lg_txt_awkembdead',
     'B1718_113016_en6C_ipd_p1_lg_txt_cnt',
     'B1718_113016_en6C_ipd_p1_lg_txt_dead',
     'B1718_113016_en6C_ipd_p2_sm_txt_cnt',
     'B1718_113016_en6C_ipd_p2_sm_txt_deadline',
     'B1718_113016_en6C_ipd_p2_sm_txt_depend',
     'B1718_113016_en6C_ipd_p2_sm_txt_expPP_v1',
     'B1718_113016_en6C_mob_p1_lg_txt_awk',
     'B1718_113016_en6C_mob_p1_lg_txt_awkdead',
     'B1718_113016_en6C_mob_p1_lg_txt_awkemb',
     'B1718_113016_en6C_mob_p1_lg_txt_awkembdead',
     'B1718_113016_en6C_mob_p1_lg_txt_cnt',
     'B1718_113016_en6C_mob_p1_lg_txt_dead',
     'B1718_113016_en6C_mob_p2_sm_txt_cnt',
     'B1718_113016_en6C_mob_p2_sm_txt_deadline',
     'B1718_113016_en6C_mob_p2_sm_txt_depend',
     'B1718_113016_en6C_mob_p2_sm_txt_expPP_v1',
     'B1718_113021_en6C_ipd_p2_sm_txt_cnt',
     'B1718_113021_en6C_ipd_p2_sm_txt_ddlwithmnm',
     'B1718_113021_en6C_ipd_p2_sm_txt_expday',
     'B1718_113021_en6C_ipd_p2_sm_txt_expday_border',
     'B1718_113021_en6C_ipd_p2_sm_txt_expday_italic',
     'B1718_113021_en6C_ipd_p2_sm_txt_weekday',
     'B1718_113021_en6C_mob_p2_sm_txt_cnt',
     'B1718_113021_en6C_mob_p2_sm_txt_ddlwithmnm',
     'B1718_113021_en6C_mob_p2_sm_txt_expday',
     'B1718_113021_en6C_mob_p2_sm_txt_expday_border',
     'B1718_113021_en6C_mob_p2_sm_txt_expday_italic',
     'B1718_113021_en6C_mob_p2_sm_txt_weekday',
     'B1718_113023_en6C_ipd_p1_lg_txt_5paras',
     'B1718_113023_en6C_ipd_p1_lg_txt_cbemailemb',
     'B1718_113023_en6C_ipd_p1_lg_txt_cnt',
     'B1718_113023_en6C_ipd_p1_lg_txt_enhancedcnt',
     'B1718_113023_en6C_mob_p1_lg_txt_5paras',
     'B1718_113023_en6C_mob_p1_lg_txt_cbemailemb',
     'B1718_113023_en6C_mob_p1_lg_txt_cnt',
     'B1718_113023_en6C_mob_p1_lg_txt_enhancedcnt',
     'B1718_120115_en6C_ipd_p1_lg_frq_cnt',
     'B1718_120115_en6C_ipd_p1_lg_frq_improvedtoggle',
     'B1718_120115_en6C_ipd_p2_sm_frq_cnt',
     'B1718_120115_en6C_ipd_p2_sm_frq_improvedtoggle',
     'B1718_120115_en6C_mob_p1_lg_frq_cnt',
     'B1718_120115_en6C_mob_p1_lg_frq_improvedtoggle',
     'B1718_120115_en6C_mob_p2_sm_frq_cnt',
     'B1718_120115_en6C_mob_p2_sm_frq_improvedtoggle',
     'B1718_120117_en6C_ipd_p1_lg_dsn_twin1',
     'B1718_120117_en6C_ipd_p1_lg_dsn_twin2',
     'B1718_120117_en6C_mob_p1_lg_dsn_twin1',
     'B1718_120117_en6C_mob_p1_lg_dsn_twin2',
     'B1718_120121_en6C_ipd_p1_lg_frm_ccicons',
     'B1718_120121_en6C_ipd_p1_lg_frm_cnt',
     'B1718_120121_en6C_ipd_p1_lg_frm_scr',
     'B1718_120121_en6C_ipd_p1_lg_frm_usrbbl',
     'B1718_120121_en6C_ipd_p1_lg_txt_ddldate',
     'B1718_120121_en6C_ipd_p1_lg_txt_ddldatehitourgoal',
     'B1718_120121_en6C_mob_p1_lg_frm_ccicons',
     'B1718_120121_en6C_mob_p1_lg_frm_cnt',
     'B1718_120121_en6C_mob_p1_lg_frm_scr',
     'B1718_120121_en6C_mob_p1_lg_frm_usrbbl',
     'B1718_120121_en6C_mob_p1_lg_txt_ddldate',
     'B1718_120121_en6C_mob_p1_lg_txt_ddldatehitourgoal',
     'B1718_120218_en6C_mob_p1_lg_frm_cnt',
     'B1718_120218_en6C_mob_p1_lg_frm_hrt')"
  );
}

/**
 * Update status on canceled unintended recurs
 *
 * Bug: T186833
 */
function wmf_civicrm_update_7625() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery(
    "UPDATE civicrm_contribution_recur as cr
     SET cr.contribution_status_id = 3
     WHERE cr.cancel_date = '2018-3-13 01:23:45'"
  );
}

/**
 * Remove geocoder rows from Managed table.
 *
 * These are now managed on install and we don't want Civi to try to reconcile them.
 *
 * Bug: T190119
 */
function wmf_civicrm_update_7630() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery("DELETE FROM civicrm_managed WHERE module = 'org.wikimedia.geocoder'");
}

/**
 * Update status on canceled unintended recurs round 2
 *
 * Bug: T190854
 */
function wmf_civicrm_update_7635() {
  civicrm_initialize();
  global $databases;
  $drupal = $databases['default']['default']['database'];
  CRM_Core_DAO::executeQuery(
    "UPDATE civicrm_contribution_recur AS cr
     INNER JOIN civicrm_contribution AS cc on cc.contribution_recur_id = cr.id
     INNER JOIN {$drupal}.contribution_tracking AS ct on ct.contribution_id = cc.id
     INNER JOIN {$drupal}.contribution_source AS cs on ct.id = cs.contribution_tracking_id
     SET cr.cancel_date = '2018-3-28 01:23:45', cr.contribution_status_id = 3
     WHERE ct.ts >= '20171011000000'  and ct.ts <= '20171129000000'
     AND cc.trxn_id LIKE '%RECURRING GLOBALCOLLECT%'
     AND (isnull(cr.end_date) and isnull(cr.cancel_date))
     AND cs.banner in ('B1718_1011_en6C_ipd_p1_lg_frq_cnt',
     'B1718_1011_en6C_ipd_p1_lg_frq_txttoggle',
     'B1718_1011_en6C_mob_p1_lg_frq_cnt',
     'B1718_1011_en6C_mob_p1_lg_frq_txttoggle',
     'B1718_1018_en6C_ipd_p1_lg_frq_cnt',
     'B1718_1018_en6C_ipd_p1_lg_frq_togunder',
     'B1718_1018_en6C_ipd_p2_sm_frq_toggle',
     'B1718_1018_en6C_mob_p1_lg_frq_cnt',
     'B1718_1018_en6C_mob_p1_lg_frq_togunder',
     'B1718_1018_en6C_mob_p2_sm_frq_toggle',
     'B1718_1019_en6C_ipd_p1_lg_dsn_cnt',
     'B1718_1019_en6C_ipd_p1_lg_dsn_greybknd',
     'B1718_1019_en6C_ipd_p1_lg_dsn_legacycblinebreaks',
     'B1718_1019_en6C_ipd_p1_lg_txt_jimmyIwaving',
     'B1718_1019_en6C_mob_p1_lg_dsn_cnt',
     'B1718_1019_en6C_mob_p1_lg_dsn_greybknd',
     'B1718_1019_en6C_mob_p1_lg_dsn_legacycblinebreaks',
     'B1718_1019_en6C_mob_p1_lg_txt_jimmyIwaving',
     'B1718_1025_en6C_ipd_p1_lg_dsn_betterdonateux',
     'B1718_1025_en6C_ipd_p1_lg_dsn_cnt',
     'B1718_1025_en6C_ipd_p1_lg_dsn_stckrhello',
     'B1718_1025_en6C_ipd_p1_lg_dsn_stckrhellocoffee',
     'B1718_1025_en6C_ipd_p2_sm_txt_2016fus',
     'B1718_1025_en6C_ipd_p2_sm_txt_cnt',
     'B1718_1025_en6C_mob_p1_lg_dsn_betterdonateux',
     'B1718_1025_en6C_mob_p1_lg_dsn_cnt',
     'B1718_1025_en6C_mob_p1_lg_dsn_stckrhello',
     'B1718_1025_en6C_mob_p1_lg_dsn_stckrhellocoffee',
     'B1718_1025_en6C_mob_p2_sm_txt_2016fus',
     'B1718_1025_en6C_mob_p2_sm_txt_cnt',
     'B1718_1101_en6C_ipd_p1_lg_dsn_cnt',
     'B1718_1101_en6C_ipd_p1_lg_dsn_coffee',
     'B1718_1101_en6C_ipd_p2_sm_frq_belowamts',
     'B1718_1101_en6C_ipd_p2_sm_frq_cnt',
     'B1718_1101_en6C_mob_p1_lg_dsn_cnt',
     'B1718_1101_en6C_mob_p1_lg_dsn_coffee',
     'B1718_1101_en6C_mob_p2_sm_frq_belowamts',
     'B1718_1101_en6C_mob_p2_sm_frq_cnt',
     'B1718_1107_en6C_ipd_p1_lg_dsn_cnt',
     'B1718_1107_en6C_ipd_p1_lg_dsn_refactor',
     'B1718_1107_en6C_ipd_p2_sm_txt_cnt',
     'B1718_1107_en6C_ipd_p2_sm_txt_usealot',
     'B1718_1107_en6C_mob_p1_lg_dsn_cnt',
     'B1718_1107_en6C_mob_p1_lg_dsn_refactor',
     'B1718_1107_en6C_mob_p2_sm_txt_cnt',
     'B1718_1107_en6C_mob_p2_sm_txt_usealot',
     'B1718_1111_en6C_ipd_p1_lg_txt_awkwknd',
     'B1718_1111_en6C_ipd_p1_lg_txt_awkwkndregret',
     'B1718_1111_en6C_ipd_p1_lg_txt_cnt',
     'B1718_1111_en6C_ipd_p1_lg_txt_happysat',
     'B1718_1111_en6C_ipd_p2_sm_txt_cnt',
     'B1718_1111_en6C_ipd_p2_sm_txt_thissat',
     'B1718_1111_en6C_mob_p1_lg_txt_awkwknd',
     'B1718_1111_en6C_mob_p1_lg_txt_awkwkndregret',
     'B1718_1111_en6C_mob_p1_lg_txt_cnt',
     'B1718_1111_en6C_mob_p1_lg_txt_happysat',
     'B1718_1111_en6C_mob_p2_sm_txt_cnt',
     'B1718_1111_en6C_mob_p2_sm_txt_thissat',
     'B1718_1114_en6C_ipd_p1_lg_dsn_iosjim',
     'B1718_1114_en6C_ipd_p1_lg_txt_awkv1long',
     'B1718_1114_en6C_ipd_p1_lg_txt_awkv2short',
     'B1718_1114_en6C_ipd_p1_lg_txt_cnt',
     'B1718_1114_en6C_ipd_p2_sm_txt_cnt',
     'B1718_1114_en6C_ipd_p2_sm_txt_tues',
     'B1718_1114_en6C_mob_p1_lg_dsn_iosjim',
     'B1718_1114_en6C_mob_p1_lg_txt_awkv1long',
     'B1718_1114_en6C_mob_p1_lg_txt_awkv2short',
     'B1718_1114_en6C_mob_p1_lg_txt_cnt',
     'B1718_1114_en6C_mob_p2_sm_txt_cnt',
     'B1718_1114_en6C_mob_p2_sm_txt_tues',
     'B1718_1116_en6C_ipd_p1_lg_dsn_cnt',
     'B1718_1116_en6C_ipd_p1_lg_dsn_plusminus',
     'B1718_1116_en6C_ipd_p1_lg_dsn_redcta',
     'B1718_1116_en6C_ipd_p1_lg_txt_thisweekdaycoffee',
     'B1718_1116_en6C_ipd_p2_sm_dsn_cnt',
     'B1718_1116_en6C_ipd_p2_sm_dsn_exp2ndpara',
     'B1718_1116_en6C_mob_p1_lg_dsn_cnt',
     'B1718_1116_en6C_mob_p1_lg_dsn_plusminus',
     'B1718_1116_en6C_mob_p1_lg_dsn_redcta',
     'B1718_1116_en6C_mob_p1_lg_txt_thisweekdaycoffee',
     'B1718_1116_en6C_mob_p2_sm_dsn_cnt',
     'B1718_1116_en6C_mob_p2_sm_dsn_exp2ndpara',
     'B1718_1116_enGB_ipd_p1_lg_amt_250',
     'B1718_1116_enGB_ipd_p1_lg_amt_cnt',
     'B1718_1116_enGB_ipd_p2_sm_amt_250',
     'B1718_1116_enGB_ipd_p2_sm_amt_cnt',
     'B1718_1116_enGB_mob_p1_lg_amt_250',
     'B1718_1116_enGB_mob_p1_lg_amt_cnt',
     'B1718_1116_enGB_mob_p2_sm_amt_250',
     'B1718_1116_enGB_mob_p2_sm_amt_cnt',
     'B1718_1118_en6C_ipd_p1_lg_txt_awkwkdyregret',
     'B1718_1118_en6C_ipd_p1_lg_txt_awkwkndregret',
     'B1718_1118_en6C_ipd_p1_lg_txt_cnt',
     'B1718_1118_en6C_ipd_p1_lg_txt_wkday',
     'B1718_1118_en6C_ipd_p2_sm_dsn_cnt',
     'B1718_1118_en6C_ipd_p2_sm_dsn_exp2pp',
     'B1718_1118_en6C_mob_p1_lg_txt_awkwkdyregret',
     'B1718_1118_en6C_mob_p1_lg_txt_awkwkndregret',
     'B1718_1118_en6C_mob_p1_lg_txt_cnt',
     'B1718_1118_en6C_mob_p1_lg_txt_wkday',
     'B1718_1118_en6C_mob_p2_sm_dsn_cnt',
     'B1718_1118_en6C_mob_p2_sm_dsn_exp2pp',
     'B1718_1122_en6C_ipd_p1_lg_txt_cnt',
     'B1718_1122_en6C_ipd_p1_lg_txt_dayawkbusyremind',
     'B1718_1122_en6C_ipd_p1_lg_txt_dayawkbusyremindemb',
     'B1718_1122_en6C_ipd_p1_lg_txt_daycoffee',
     'B1718_1122_en6C_ipd_p2_sm_dsn_cnt',
     'B1718_1122_en6C_ipd_p2_sm_dsn_expday',
     'B1718_1122_en6C_mob_p1_lg_txt_cnt',
     'B1718_1122_en6C_mob_p1_lg_txt_dayawkbusyremind',
     'B1718_1122_en6C_mob_p1_lg_txt_dayawkbusyremindemb',
     'B1718_1122_en6C_mob_p1_lg_txt_daycoffee',
     'B1718_1122_en6C_mob_p2_sm_dsn_cnt',
     'B1718_1122_en6C_mob_p2_sm_dsn_expday')"
  );
}

/**
 * Remove 'Language' custom group (if exists).
 *
 * The core install has a custom group 'language'. Only 75 records have data
 * & there is another place to store this. I sent out an email & get generalised support
 * on this change.
 *
 * (note I tested this api function on staging & checked there was one less group / table
 * afterwards).
 */
function wmf_civicrm_update_7640() {
  civicrm_initialize();
  civicrm_api3('CustomGroup', 'get', [
    'name' => 'Language',
    'api.CustomGroup.delete',
  ]);
}

/**
 * Enable fraud report.
 *
 * Bug: T187262
 */
function wmf_civicrm_update_7660() {
  wmf_civicrm_reconcile_extensions();
}

/**
 * Update first recurring payments to non-refunded
 */
 function wmf_civicrm_update_7678() {
   civicrm_initialize();

   global $databases;
   $drupaldb = $databases['default']['default']['database'];
   $cividb = substr($drupaldb, 0, 3) === 'dev' ? 'dev_civicrm' : 'civicrm';
   $contributionStatusId = CRM_Contribute_PseudoConstant::contributionStatus(NULL, 'name');
   $refundedStatusId = CRM_Utils_Array::key('Refunded', $contributionStatusId);
   $completedStatusId = CRM_Utils_Array::key('Completed', $contributionStatusId);
   $batch = 1000;
   $sql = "SELECT ccc.id, ccc.total_amount, ccc.financial_type_id, ccc.contact_id
               FROM $cividb.civicrm_contribution AS ccc
               INNER JOIN $cividb.civicrm_contribution_recur AS ccr on ccr.id = ccc.contribution_recur_id
               INNER JOIN $drupaldb.contribution_tracking AS dct on dct.contribution_id = ccc.id
               INNER JOIN $drupaldb.contribution_source AS dcs on dct.id = dcs.contribution_tracking_id
               WHERE dct.ts >= '20171011000000'  and dct.ts <= '20171204213500'
               AND ccc.trxn_id LIKE '%RECURRING GLOBALCOLLECT%'
               AND ccc.trxn_id NOT LIKE '%-%'
               AND ccc.contribution_status_id=$refundedStatusId
               AND dcs.banner IN
               ('B1718_1011_en6C_ipd_p1_lg_frq_cnt',
               'B1718_1011_en6C_ipd_p1_lg_frq_txttoggle',
               'B1718_1011_en6C_mob_p1_lg_frq_cnt',
               'B1718_1011_en6C_mob_p1_lg_frq_txttoggle',
               'B1718_1018_en6C_ipd_p1_lg_frq_cnt',
               'B1718_1018_en6C_ipd_p1_lg_frq_togunder',
               'B1718_1018_en6C_ipd_p2_sm_frq_toggle',
               'B1718_1018_en6C_mob_p1_lg_frq_cnt',
               'B1718_1018_en6C_mob_p1_lg_frq_togunder',
               'B1718_1018_en6C_mob_p2_sm_frq_toggle',
               'B1718_1019_en6C_ipd_p1_lg_dsn_cnt',
               'B1718_1019_en6C_ipd_p1_lg_dsn_greybknd',
               'B1718_1019_en6C_ipd_p1_lg_dsn_legacycblinebreaks',
               'B1718_1019_en6C_ipd_p1_lg_txt_jimmyIwaving',
               'B1718_1019_en6C_mob_p1_lg_dsn_cnt',
               'B1718_1019_en6C_mob_p1_lg_dsn_greybknd',
               'B1718_1019_en6C_mob_p1_lg_dsn_legacycblinebreaks',
               'B1718_1019_en6C_mob_p1_lg_txt_jimmyIwaving',
               'B1718_1025_en6C_ipd_p1_lg_dsn_betterdonateux',
               'B1718_1025_en6C_ipd_p1_lg_dsn_cnt',
               'B1718_1025_en6C_ipd_p1_lg_dsn_stckrhello',
               'B1718_1025_en6C_ipd_p1_lg_dsn_stckrhellocoffee',
               'B1718_1025_en6C_ipd_p2_sm_txt_2016fus',
               'B1718_1025_en6C_ipd_p2_sm_txt_cnt',
               'B1718_1025_en6C_mob_p1_lg_dsn_betterdonateux',
               'B1718_1025_en6C_mob_p1_lg_dsn_cnt',
               'B1718_1025_en6C_mob_p1_lg_dsn_stckrhello',
               'B1718_1025_en6C_mob_p1_lg_dsn_stckrhellocoffee',
               'B1718_1025_en6C_mob_p2_sm_txt_2016fus',
               'B1718_1025_en6C_mob_p2_sm_txt_cnt',
               'B1718_1101_en6C_ipd_p1_lg_dsn_cnt',
               'B1718_1101_en6C_ipd_p1_lg_dsn_coffee',
               'B1718_1101_en6C_ipd_p2_sm_frq_belowamts',
               'B1718_1101_en6C_ipd_p2_sm_frq_cnt',
               'B1718_1101_en6C_mob_p1_lg_dsn_cnt',
               'B1718_1101_en6C_mob_p1_lg_dsn_coffee',
               'B1718_1101_en6C_mob_p2_sm_frq_belowamts',
               'B1718_1101_en6C_mob_p2_sm_frq_cnt',
               'B1718_1107_en6C_ipd_p1_lg_dsn_cnt',
               'B1718_1107_en6C_ipd_p1_lg_dsn_refactor',
               'B1718_1107_en6C_ipd_p2_sm_txt_cnt',
               'B1718_1107_en6C_ipd_p2_sm_txt_usealot',
               'B1718_1107_en6C_mob_p1_lg_dsn_cnt',
               'B1718_1107_en6C_mob_p1_lg_dsn_refactor',
               'B1718_1107_en6C_mob_p2_sm_txt_cnt',
               'B1718_1107_en6C_mob_p2_sm_txt_usealot',
               'B1718_1111_en6C_ipd_p1_lg_txt_awkwknd',
               'B1718_1111_en6C_ipd_p1_lg_txt_awkwkndregret',
               'B1718_1111_en6C_ipd_p1_lg_txt_cnt',
               'B1718_1111_en6C_ipd_p1_lg_txt_happysat',
               'B1718_1111_en6C_ipd_p2_sm_txt_cnt',
               'B1718_1111_en6C_ipd_p2_sm_txt_thissat',
               'B1718_1111_en6C_mob_p1_lg_txt_awkwknd',
               'B1718_1111_en6C_mob_p1_lg_txt_awkwkndregret',
               'B1718_1111_en6C_mob_p1_lg_txt_cnt',
               'B1718_1111_en6C_mob_p1_lg_txt_happysat',
               'B1718_1111_en6C_mob_p2_sm_txt_cnt',
               'B1718_1111_en6C_mob_p2_sm_txt_thissat',
               'B1718_1114_en6C_ipd_p1_lg_dsn_iosjim',
               'B1718_1114_en6C_ipd_p1_lg_txt_awkv1long',
               'B1718_1114_en6C_ipd_p1_lg_txt_awkv2short',
               'B1718_1114_en6C_ipd_p1_lg_txt_cnt',
               'B1718_1114_en6C_ipd_p2_sm_txt_cnt',
               'B1718_1114_en6C_ipd_p2_sm_txt_tues',
               'B1718_1114_en6C_mob_p1_lg_dsn_iosjim',
               'B1718_1114_en6C_mob_p1_lg_txt_awkv1long',
               'B1718_1114_en6C_mob_p1_lg_txt_awkv2short',
               'B1718_1114_en6C_mob_p1_lg_txt_cnt',
               'B1718_1114_en6C_mob_p2_sm_txt_cnt',
               'B1718_1114_en6C_mob_p2_sm_txt_tues',
               'B1718_1116_en6C_ipd_p1_lg_dsn_cnt',
               'B1718_1116_en6C_ipd_p1_lg_dsn_plusminus',
               'B1718_1116_en6C_ipd_p1_lg_dsn_redcta',
               'B1718_1116_en6C_ipd_p1_lg_txt_thisweekdaycoffee',
               'B1718_1116_en6C_ipd_p2_sm_dsn_cnt',
               'B1718_1116_en6C_ipd_p2_sm_dsn_exp2ndpara',
               'B1718_1116_en6C_mob_p1_lg_dsn_cnt',
               'B1718_1116_en6C_mob_p1_lg_dsn_plusminus',
               'B1718_1116_en6C_mob_p1_lg_dsn_redcta',
               'B1718_1116_en6C_mob_p1_lg_txt_thisweekdaycoffee',
               'B1718_1116_en6C_mob_p2_sm_dsn_cnt',
               'B1718_1116_en6C_mob_p2_sm_dsn_exp2ndpara',
               'B1718_1116_enGB_ipd_p1_lg_amt_250',
               'B1718_1116_enGB_ipd_p1_lg_amt_cnt',
               'B1718_1116_enGB_ipd_p2_sm_amt_250',
               'B1718_1116_enGB_ipd_p2_sm_amt_cnt',
               'B1718_1116_enGB_mob_p1_lg_amt_250',
               'B1718_1116_enGB_mob_p1_lg_amt_cnt',
               'B1718_1116_enGB_mob_p2_sm_amt_250',
               'B1718_1116_enGB_mob_p2_sm_amt_cnt',
               'B1718_1118_en6C_ipd_p1_lg_txt_awkwkdyregret',
               'B1718_1118_en6C_ipd_p1_lg_txt_awkwkndregret',
               'B1718_1118_en6C_ipd_p1_lg_txt_cnt',
               'B1718_1118_en6C_ipd_p1_lg_txt_wkday',
               'B1718_1118_en6C_ipd_p2_sm_dsn_cnt',
               'B1718_1118_en6C_ipd_p2_sm_dsn_exp2pp',
               'B1718_1118_en6C_mob_p1_lg_txt_awkwkdyregret',
               'B1718_1118_en6C_mob_p1_lg_txt_awkwkndregret',
               'B1718_1118_en6C_mob_p1_lg_txt_cnt',
               'B1718_1118_en6C_mob_p1_lg_txt_wkday',
               'B1718_1118_en6C_mob_p2_sm_dsn_cnt',
               'B1718_1118_en6C_mob_p2_sm_dsn_exp2pp',
               'B1718_1122_en6C_ipd_p1_lg_txt_cnt',
               'B1718_1122_en6C_ipd_p1_lg_txt_dayawkbusyremind',
               'B1718_1122_en6C_ipd_p1_lg_txt_dayawkbusyremindemb',
               'B1718_1122_en6C_ipd_p1_lg_txt_daycoffee',
               'B1718_1122_en6C_ipd_p2_sm_dsn_cnt',
               'B1718_1122_en6C_ipd_p2_sm_dsn_expday',
               'B1718_1122_en6C_mob_p1_lg_txt_cnt',
               'B1718_1122_en6C_mob_p1_lg_txt_dayawkbusyremind',
               'B1718_1122_en6C_mob_p1_lg_txt_dayawkbusyremindemb',
               'B1718_1122_en6C_mob_p1_lg_txt_daycoffee',
               'B1718_1122_en6C_mob_p2_sm_dsn_cnt',
               'B1718_1122_en6C_mob_p2_sm_dsn_expday',
               'B1718_113016_en6C_ipd_p1_lg_txt_awk',
               'B1718_113016_en6C_ipd_p1_lg_txt_awkdead',
               'B1718_113016_en6C_ipd_p1_lg_txt_awkemb',
               'B1718_113016_en6C_ipd_p1_lg_txt_awkembdead',
               'B1718_113016_en6C_ipd_p1_lg_txt_cnt',
               'B1718_113016_en6C_ipd_p1_lg_txt_dead',
               'B1718_113016_en6C_ipd_p2_sm_txt_cnt',
               'B1718_113016_en6C_ipd_p2_sm_txt_deadline',
               'B1718_113016_en6C_ipd_p2_sm_txt_depend',
               'B1718_113016_en6C_ipd_p2_sm_txt_expPP_v1',
               'B1718_113016_en6C_mob_p1_lg_txt_awk',
               'B1718_113016_en6C_mob_p1_lg_txt_awkdead',
               'B1718_113016_en6C_mob_p1_lg_txt_awkemb',
               'B1718_113016_en6C_mob_p1_lg_txt_awkembdead',
               'B1718_113016_en6C_mob_p1_lg_txt_cnt',
               'B1718_113016_en6C_mob_p1_lg_txt_dead',
               'B1718_113016_en6C_mob_p2_sm_txt_cnt',
               'B1718_113016_en6C_mob_p2_sm_txt_deadline',
               'B1718_113016_en6C_mob_p2_sm_txt_depend',
               'B1718_113016_en6C_mob_p2_sm_txt_expPP_v1',
               'B1718_113021_en6C_ipd_p2_sm_txt_cnt',
               'B1718_113021_en6C_ipd_p2_sm_txt_ddlwithmnm',
               'B1718_113021_en6C_ipd_p2_sm_txt_expday',
               'B1718_113021_en6C_ipd_p2_sm_txt_expday_border',
               'B1718_113021_en6C_ipd_p2_sm_txt_expday_italic',
               'B1718_113021_en6C_ipd_p2_sm_txt_weekday',
               'B1718_113021_en6C_mob_p2_sm_txt_cnt',
               'B1718_113021_en6C_mob_p2_sm_txt_ddlwithmnm',
               'B1718_113021_en6C_mob_p2_sm_txt_expday',
               'B1718_113021_en6C_mob_p2_sm_txt_expday_border',
               'B1718_113021_en6C_mob_p2_sm_txt_expday_italic',
               'B1718_113021_en6C_mob_p2_sm_txt_weekday',
               'B1718_113023_en6C_ipd_p1_lg_txt_5paras',
               'B1718_113023_en6C_ipd_p1_lg_txt_cbemailemb',
               'B1718_113023_en6C_ipd_p1_lg_txt_cnt',
               'B1718_113023_en6C_ipd_p1_lg_txt_enhancedcnt',
               'B1718_113023_en6C_mob_p1_lg_txt_5paras',
               'B1718_113023_en6C_mob_p1_lg_txt_cbemailemb',
               'B1718_113023_en6C_mob_p1_lg_txt_cnt',
               'B1718_113023_en6C_mob_p1_lg_txt_enhancedcnt',
               'B1718_120115_en6C_ipd_p1_lg_frq_cnt',
               'B1718_120115_en6C_ipd_p1_lg_frq_improvedtoggle',
               'B1718_120115_en6C_ipd_p2_sm_frq_cnt',
               'B1718_120115_en6C_ipd_p2_sm_frq_improvedtoggle',
               'B1718_120115_en6C_mob_p1_lg_frq_cnt',
               'B1718_120115_en6C_mob_p1_lg_frq_improvedtoggle',
               'B1718_120115_en6C_mob_p2_sm_frq_cnt',
               'B1718_120115_en6C_mob_p2_sm_frq_improvedtoggle',
               'B1718_120117_en6C_ipd_p1_lg_dsn_twin1',
               'B1718_120117_en6C_ipd_p1_lg_dsn_twin2',
               'B1718_120117_en6C_mob_p1_lg_dsn_twin1',
               'B1718_120117_en6C_mob_p1_lg_dsn_twin2',
               'B1718_120121_en6C_ipd_p1_lg_frm_ccicons',
               'B1718_120121_en6C_ipd_p1_lg_frm_cnt',
               'B1718_120121_en6C_ipd_p1_lg_frm_scr',
               'B1718_120121_en6C_ipd_p1_lg_frm_usrbbl',
               'B1718_120121_en6C_ipd_p1_lg_txt_ddldate',
               'B1718_120121_en6C_ipd_p1_lg_txt_ddldatehitourgoal',
               'B1718_120121_en6C_mob_p1_lg_frm_ccicons',
               'B1718_120121_en6C_mob_p1_lg_frm_cnt',
               'B1718_120121_en6C_mob_p1_lg_frm_scr',
               'B1718_120121_en6C_mob_p1_lg_frm_usrbbl',
               'B1718_120121_en6C_mob_p1_lg_txt_ddldate',
               'B1718_120121_en6C_mob_p1_lg_txt_ddldatehitourgoal',
               'B1718_120218_en6C_mob_p1_lg_frm_cnt',
               'B1718_120218_en6C_mob_p1_lg_frm_hrt')
          LIMIT $batch";
   while (TRUE) {
     $dao = CRM_CORE_DAO::executeQuery($sql);
     $contributions = [];
     while ($dao->fetch()) {
       $contributions[] = [
         'id' => $dao->id,
         'total_amount' => $dao->total_amount,
         'financial_type_id' => $dao->financial_type_id,
         'contact_id' => $dao->contact_id,
       ];
     }
     $batchSize = count($contributions);
     if ($batchSize == 0) {
       break;
     }
     drush_print("Fixing batch of $batchSize incorrectly marked refunds");
     foreach ($contributions as $contribution) {
       $params = $contribution;
       $params['contribution_status_id'] = $completedStatusId;
       civicrm_api3(
         'Contribution', 'create', $params
       );
     }
     // catch breath
     sleep(1);
   }
 }

/**
 * Update status on canceled unintended recurs round 3
 *
 * Bug: T192958
 */
function wmf_civicrm_update_7685() {
  civicrm_initialize();
  global $databases;
  $drupal = $databases['default']['default']['database'];
  CRM_Core_DAO::executeQuery(
    "UPDATE civicrm_contribution_recur AS cr
     INNER JOIN civicrm_contribution AS cc on cc.contribution_recur_id = cr.id
     INNER JOIN {$drupal}.contribution_tracking AS ct on ct.contribution_id = cc.id
     INNER JOIN {$drupal}.contribution_source AS cs on ct.id = cs.contribution_tracking_id
     SET cr.cancel_date = '2018-5-24 01:23:45', cr.contribution_status_id = 3
     WHERE ct.ts >= '20171011000000'  and ct.ts <= '20171204213500'
     AND cc.trxn_id LIKE '%RECURRING GLOBALCOLLECT%'
     AND (isnull(cr.end_date) and isnull(cr.cancel_date))
     AND cs.banner in ('B1718_120318_en6C_mob_p1_lg_frm_cnt.no-LP.rcc','B1718_120318_en6C_mob_p1_lg_frm_commty',
                      'B1718_120117_en6C_mob_p2_sm_txt_cnt','B1718_120117_en6C_mob_p2_sm_txt_weekday',
                      'B1718_120318_en6C_ipd_p1_lg_frm_cnt.no-LP.rcc',
                      'B1718_120318_en6C_ipd_p1_lg_frm_commty','B1718_120117_en6C_ipd_p2_sm_txt_cnt',
                      'B1718_120117_en6C_ipd_p2_sm_txt_weekday')"
  );
}

/**
 * Re-save any contacts with a middle name.
 *
 * Doing a blank re-save will cause the display name to be recalculated by Civi
 * rules.
 *
 * We now display middle name in the display name so this will update that.
 *
 * Bug: T195311
 */
function wmf_civicrm_update_7686() {
  civicrm_initialize();
  $result = CRM_Core_DAO::executeQuery(
    "SELECT id FROM civicrm_contact WHERE (middle_name <> '') AND is_deleted= 0"
  );
  while ($result->fetch()) {
    civicrm_api3('Contact', 'create', array('id' => $result->id));
  }
}

/**
 * Enable forgetme.
 *
 * Bug: 195261
 */
function wmf_civicrm_update_7690() {
  wmf_civicrm_reconcile_extensions();
}

/**
 * Create additional partner custom fields.
 */
function wmf_civicrm_update_7700() {
  require_once 'update_custom_fields.php';
  _wmf_civicrm_update_custom_fields();
}

/**
 * Restore data lost in 'same moment merges'.
 *
 * For a period in May 2018 from 1 to 14 May there were 2 merge dedupe jobs that were
 * running at the same time about every 250 minutes. When the jobs started at exactly the same time
 * the contact wound up with no emails as they took conflicting actions.
 *
 * 284 contacts were affected (282 in this range)
 *
 * I only found 2 contacts outside this date range who this appeared to have happened to.
 * These were major gifts donors who appeared to have hit same-moment merges earlier on.
 * (It's more luck than good design that we only hit these same moment merges - we simply didn't have
 * a schedule that could conflict other than on major gifts - which is lower risk) until recently.
 * The job for fixing this before we next run more than one job concurrently is T194701)
 *
 * I tested for phone numbers lost (I found 0) and addresses (202).
 *
 * The addresses seemed a mix of ones that ALSO had email deletes & older miscellaneous.
 *
 * Due to the addresses being also involved & after a couple of tests I decided that it makes
 * sense to use the revert api to revert the whole merge. Trialled on staging.
 *
 * Note that each merge gets it's own log_conn_id so reverting them will only revert that merge.
 * Log_conn_id is a mandatory key so we won't get an empty causing havoc (the query should pre-clude that
 * too).
 *
 * I checked the reported contact ids were included.
 *
 * Note on staging the following tables exist
 * temp_t194662_emails - the selection to be reverted per below.
 * temp_t194662_address - address losses found.
 * temp_t194662_phones - ditto but none found
 * temp_t194662_emails_larger - the emails search but with a broader net using
 *   'LEFT JOIN civicrm_email email ON email.contact_id = retained_contact.contact_id AND email.email = la.email'
 *   - the extra contacts found didn't seem relevant on cross-checking.
 *
 * Bug T194662
 */
function wmf_civicrm_update_7701() {
  civicrm_initialize();
  $contactsToRestore = CRM_Core_DAO::executeQuery("
  SELECT retained_contact.contact_id, e.log_conn_id, a.activity_date_time, count(a.id) as count_rows,
e.email , e.location_type_id, e.is_primary, e.on_hold, e.`is_bulkmail`, deleted_contact.contact_id as deleted_contact_id
# We are looking for duplicate merge activities at exactly the same time
FROM civicrm_activity a
# restrict to merge activities with merged-to contacts (these are retained)
INNER JOIN civicrm_activity_contact retained_contact ON activity_id = a.id AND a.activity_type_id = 87 AND retained_contact.record_type_id = 1
# join merge activity to contact merged from
INNER JOIN civicrm_activity_contact deleted_contact ON deleted_contact.activity_id = a.id AND deleted_contact.record_type_id =3
# join to activity log table on the insert record to get the connection
LEFT JOIN log_civicrm_activity la ON la.id = a.id AND la.log_action = 'Insert'
# join that connection onto the deleted record in the email log table
INNER JOIN log_civicrm_email e ON e.log_conn_id = la.log_conn_id AND e.log_action = 'Delete'
# join that record onto the retained contacts existing email - we want ones where they have no email( AT ALL)
LEFT JOIN civicrm_email email ON email.contact_id = retained_contact.contact_id
WHERE email.id IS NULL
# group by activity time, looking for more than one record created at the exact same time.
GROUP BY a.activity_date_time, retained_contact.contact_id , deleted_contact.contact_id
HAVING count_rows > 1;
  ");
   while ($contactsToRestore->fetch()) {
     civicrm_api3('Logging', 'revert', ['log_conn_id' => $contactsToRestore->log_conn_id]);
   }

  /**
   *  Address query.
   CREATE TABLE temp_t194662_address
  SELECT retained_contact.contact_id, count(a.id) as count_rows,
  e.street_address , e.location_type_id, e.is_primary, deleted_contact.contact_id as deleted_contact_id,
  e.log_conn_id, a.activity_date_time
  # We are looking for duplicate merge activities at exactly the same time
  FROM civicrm_activity a
  # restrict to merge activities with merged-to contacts (these are retained)
  INNER JOIN civicrm_activity_contact retained_contact ON activity_id = a.id AND a.activity_type_id = 87 AND retained_contact.record_type_id = 1
  # join merge activity to contact merged from
  INNER JOIN civicrm_activity_contact deleted_contact ON deleted_contact.activity_id = a.id AND deleted_contact.record_type_id =3
  # join to activity log table on the insert record to get the connection
  LEFT JOIN log_civicrm_activity la ON la.id = a.id AND la.log_action = 'Insert'
  # join that connection onto the deleted record in the email log table
  INNER JOIN log_civicrm_address e ON e.log_conn_id = la.log_conn_id AND e.log_action = 'Delete'
  # join that record onto the retained contact's existing email - we want ones where they have no email( AT ALL)
  LEFT JOIN civicrm_address phone ON phone.contact_id = retained_contact.contact_id
  WHERE phone.id IS NULL
  # group by activity time, looking for more than one record created at the exact same time.
  GROUP BY a.activity_date_time, retained_contact.contact_id , deleted_contact.contact_id
  HAVING count_rows > 1;
   */
}

/**
 * Fix some NULLs in activity status filter
 */
function wmf_civicrm_update_7702() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery("
    UPDATE civicrm_option_value cov
      INNER JOIN civicrm_option_group cog ON cog.id = cov.option_group_id
    SET cov.filter = 0
    WHERE cov.filter IS NULL
    AND cog.name = 'activity_status'
  ");
}

/**
 * Enable SmashPig and create processor records.
 */
function wmf_civicrm_update_7705() {
  civicrm_api3('Setting', 'create', [
    'smashpig_recurring_use_queue' => '1',
  ]);

  $migrate = [
    'recurring_globalcollect_failure_retry_rate' => 'smashpig_recurring_retry_delay_days',
    'recurring_globalcollect_failures_before_cancellation' => 'smashpig_recurring_max_failures',
    'recurring_globalcollect_run_missed_days' => 'smashpig_recurring_catch_up_days',
    'recurring_globalcollect_batch_max' => 'smashpig_recurring_batch_size',
  ];
  foreach($migrate as $drupalSetting => $civiSetting) {
    $value = variable_get($drupalSetting);
    if ($value) {
      civicrm_api3('Setting', 'create', [
        $civiSetting => $value,
      ]);
    }
  }

  $processors = [
    'adyen',
    'amazon',
    'dlocal',
    'globalcollect',
    'ingenico',
    'paypal',
    'paypal_ec'
  ];
  foreach ($processors as $processor) {
    wmf_civicrm_ensure_payment_processor_exists("smashpig_$processor", $processor);
  }
}

/**
 * Add location_id to civicrm_group_contact table.
 *
 * OK so this is pretty scary - for most of recorded history the civicrm_group_contact
 * table has been supposed to have a location_id field - but on our database it has been
 * missing. Queue X-files music
 *
 * Bug: T197045
 */
function wmf_civicrm_update_7710() {
  civicrm_initialize();
  if (!CRM_Core_BAO_SchemaHandler::checkIfFieldExists("civicrm_group_contact", "location_id")) {
    CRM_Core_DAO::executeQuery("
    ALTER TABLE civicrm_group_contact ADD COLUMN `location_id` int(10) unsigned DEFAULT NULL COMMENT 'Optional location to associate with this membership'
  ");
  }
}

/**
 * Tokenize recurring payments that we were unable to tokenize up front
 */
function wmf_civicrm_update_7715() {
  require_once('recurring.inc');
  wmf_civicrm_recur_tokenize_damaged('ingenico');
}

/**
 * Fix processor_id for recurring donations not yet canceled.
 * Bug: T199331
 */
function wmf_civicrm_update_7725() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery("
    UPDATE civicrm_contribution_recur
    SET processor_id = '1'
    WHERE processor_id LIKE 'RECURRING GLOBALCOLLECT%'
    AND payment_token_id IS NULL
    AND contribution_status_id IN (1,4) -- Completed or Failed
  ");
}


/**
 * Create another RecurringRestarted tag, this one for the
 * civicrm_contribution_recur table. It will indicate that
 * the subscription has been cured of some malady, and that
 * the next contribution record created from it should get
 * the RecurringRestarted tag so the donor is thanked
 * correctly. The recurring processor should then remove
 * this tag from the civicrm_contribution_recur table.
 *
 * @throws \CiviCRM_API3_Exception
 */
function wmf_civicrm_update_7726() {
  civicrm_initialize();
  wmf_civicrm_create_option_values_detailed('tag_used_for', array(
    'Recurring contributions' => array('value' => 'civicrm_contribution_recur'),
  ));

  $result = civicrm_api3('Tag', 'get', array(
    'name' => 'RecurringRestartedUncharged',
    'used_for' => 'civicrm_contribution_recur',
  ));
  if (empty($result['values'])) {
    civicrm_api3('Tag', 'create', array(
      'name' => 'RecurringRestartedUncharged',
      'description' => 'A subscription that has been restarted but not yet charged.',
      'is_selectable' => FALSE,
      'is_reserved' => TRUE,
      'used_for' => 'civicrm_contribution_recur',
    ));
  }
}

/**
 * Fix processor_id for the rest of the misrecorded subscriptions.
 * Also un-cancel them and add a RecurringRestartedUncharged tag
 * to the recur records.
 *
 * Bug: T199331
 * @throws \CiviCRM_API3_Exception
 */
function wmf_civicrm_update_7728() {
  civicrm_initialize();
  $recurTagId = civicrm_api3('Tag', 'getvalue', array(
    'name' => 'RecurringRestartedUncharged',
    'used_for' => 'civicrm_contribution_recur',
    'return' => 'id'
  ));
  $contributionStatusId = CRM_Contribute_PseudoConstant::contributionStatus(NULL, 'name');
  $cancelledStatusId = CRM_Utils_Array::key('Cancelled', $contributionStatusId);
  $completedStatusId = CRM_Utils_Array::key('Completed', $contributionStatusId);
  CRM_Core_DAO::executeQuery("
    INSERT INTO civicrm_entity_tag (entity_table, entity_id, tag_id) (
      SELECT 'civicrm_contribution_recur', id, $recurTagId
      FROM civicrm_contribution_recur
      WHERE processor_id LIKE 'RECURRING GLOBALCOLLECT%'
      AND payment_token_id IS NULL
      AND contribution_status_id = $cancelledStatusId
    )
  ");
  CRM_Core_DAO::executeQuery("
    UPDATE civicrm_contribution_recur
    SET processor_id = '1',
      contribution_status_id = $completedStatusId,
      cancel_date = NULL
    WHERE processor_id LIKE 'RECURRING GLOBALCOLLECT%'
    AND payment_token_id IS NULL
    AND contribution_status_id = $cancelledStatusId
  ");
}


/**
 * Fix next_sched_contribution_date for canceled subs, as found by tags added
 * in last update. July and August both have 31 days, so we can just use the
 * cycle_day without complications.
 *
 * Bug: T199331
 */
function wmf_civicrm_update_7730() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery("
    UPDATE civicrm_contribution_recur ccr
    INNER JOIN civicrm_entity_tag et
      ON et.entity_id = ccr.id AND et.entity_table = 'civicrm_contribution_recur'
    INNER JOIN civicrm_tag t
      ON t.id = et.tag_id and t.name = 'RecurringRestartedUncharged'
    SET ccr.next_sched_contribution_date = CONCAT('2018-08-', ccr.cycle_day)
    WHERE ccr.cycle_day < 20;
  ");

  CRM_Core_DAO::executeQuery("
    UPDATE civicrm_contribution_recur ccr
    INNER JOIN civicrm_entity_tag et
      ON et.entity_id = ccr.id AND et.entity_table = 'civicrm_contribution_recur'
    INNER JOIN civicrm_tag t
      ON t.id = et.tag_id and t.name = 'RecurringRestartedUncharged'
    SET ccr.next_sched_contribution_date = CONCAT('2018-07-', ccr.cycle_day)
    WHERE ccr.cycle_day > 19;
  ");
}

/**
 * Enable contact layout editor.
 */
function wmf_civicrm_update_7740() {
  wmf_civicrm_reconcile_extensions();
}

/**
 * Set all old contributions with blank string or '0' in no_thank_you
 * to have no_thank_you = 'legacy_blank'. The source_type filter
 * should exclude everything that's come in via a queue.
 *
 * As of 2018-09-03, there are 77k contributions with '' or '0' in
 * no_thank_you, and with thankyou_date null.
 *
 * Bug: T97684
 */
function wmf_civicrm_update_7745() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery("
    UPDATE wmf_contribution_extra x
    INNER JOIN civicrm_contribution cc ON x.entity_id = cc.id
    SET x.no_thank_you = 'legacy_blank'
    WHERE no_thank_you IN ('', '0')
    AND thankyou_date IS NULL
  ");

}

/**
 * Uninstall 'globalcollect_audit'.
 */
function wmf_civicrm_update_7750() {
  module_disable(['globalcollect_audit']);
  drupal_uninstall_modules(['globalcollect_audit']);
}

/**
 * For all monthly donations canceled because of the repeated Merchant ID bug,
 * un-cancel them (resetting failure count), reset their next scheduled
 * contribution date to 2 months after start date, and add the
 * RecurringRestartedUncharged tag. All of these failed on the first scheduled
 * charge date, 1 month after start date.
 *
 * Bug: T201773
 */
function wmf_civicrm_update_7755() {
  global $databases;
  civicrm_initialize();
  $recurTagId = civicrm_api3('Tag', 'getvalue', array(
    'name' => 'RecurringRestartedUncharged',
    'used_for' => 'civicrm_contribution_recur',
    'return' => 'id'
  ));
  $drupal = $databases['default']['default']['database'];
  $contributionStatusId = CRM_Contribute_PseudoConstant::contributionStatus(NULL, 'name');
  $cancelledStatusId = CRM_Utils_Array::key('Cancelled', $contributionStatusId);
  $completedStatusId = CRM_Utils_Array::key('Completed', $contributionStatusId);
  $ctIdList = '(57990533, 57991947, 57995299, 57995622, 57997242, 58006880, ' .
    '58007549, 58112187, 58113086, 58113202, 58117262, 58215150, 58218626, ' .
    '58221282, 58223014, 58223512, 58228479, 58229787, 58232269, 58234072, ' .
    '58235105, 58235341, 58239642, 58242471, 58243295, 58243359, 58246799, ' .
    '58247903)';
  CRM_Core_DAO::executeQuery("
    INSERT INTO civicrm_entity_tag (entity_table, entity_id, tag_id) (
      SELECT 'civicrm_contribution_recur', cr.id, $recurTagId
      FROM civicrm_contribution_recur cr
      INNER JOIN civicrm_contribution c ON c.contribution_recur_id = cr.id
      INNER JOIN {$drupal}.contribution_tracking ct ON ct.contribution_id = c.id
      WHERE ct.id IN $ctIdList
      AND cr.contribution_status_id = $cancelledStatusId
    )
  ");
  CRM_Core_DAO::executeQuery("
    UPDATE civicrm_contribution_recur cr
    INNER JOIN civicrm_contribution c ON c.contribution_recur_id = cr.id
    INNER JOIN {$drupal}.contribution_tracking ct ON ct.contribution_id = c.id
    SET cr.next_sched_contribution_date = DATE_ADD(
      cr.start_date, INTERVAL 2 MONTH
    ),
    cr.failure_count = 0,
    cr.cancel_date = NULL,
    cr.contribution_status_id = $completedStatusId
    WHERE ct.id IN $ctIdList
    AND cr.contribution_status_id = $cancelledStatusId
  ");

}

/**
 * Fix opt_in values for PayPal donors cheated by form bug.
 * Looks like 1,341 people affected
 *
 * Bug: T204769
 */
function wmf_civicrm_update_7760() {
  return;
  global $databases;
  civicrm_initialize();
  $drupal = $databases['default']['default']['database'];
  CRM_Core_DAO::executeQuery("
    UPDATE civicrm_value_1_communication_4 comm
    INNER JOIN civicrm_contribution cc ON comm.entity_id = cc.contact_id
    INNER JOIN {$drupal}.contribution_tracking ct ON ct.contribution_id = cc.id
    SET comm.opt_in = 0
    WHERE comm.opt_in = 1
      AND ct.utm_source LIKE '%optIn0%'
      AND receive_date BETWEEN '2018-09-10' AND '2018-09-15'
      AND trxn_id LIKE 'PAYPAL%'
  ");
}

/**
 * Fix opt_in values for non-PayPal donors cheated by form bug.
 * Looks like 148 people affected
 *
 * Bug: T204769
 */
function wmf_civicrm_update_7761() {
  return;
  global $databases;
  civicrm_initialize();
  $drupal = $databases['default']['default']['database'];
  CRM_Core_DAO::executeQuery("
    UPDATE civicrm_value_1_communication_4 comm
    INNER JOIN civicrm_contribution cc ON comm.entity_id = cc.contact_id
    INNER JOIN {$drupal}.contribution_tracking ct ON ct.contribution_id = cc.id
    SET comm.opt_in = 0
    WHERE comm.opt_in = 1
      AND ct.utm_source LIKE '%optIn0%'
      AND receive_date BETWEEN '2018-08-07' AND '2018-09-15'
      AND trxn_id NOT LIKE 'PAYPAL%'
  ");
}

/**
 * Drop a redundant table. All the data in this table now lives in
 * civicrm_geocoder_zip_dataset
 */
function wmf_civicrm_update_7765() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery('DROP TABLE IF EXISTS `wmf_zip_geo`');
}

/**
 * Un-cancel PayPal subscriptions from a bogus audit file
 *
 * Bug: T206343
 */
function wmf_civicrm_update_7770() {
  require_once('paypal_fixes.php');
  wmf_civicrm_undo_bogus_paypal_cancel('2018-10-03 09:46:00', '2018-10-03 13:39:00');
}

/**
 * Un-cancel more PayPal subscriptions from another bogus audit file
 *
 * Bug: T206343
 */
function wmf_civicrm_update_7772() {
  require_once('paypal_fixes.php');
  wmf_civicrm_undo_bogus_paypal_cancel('2018-10-16 04:00:00', '2018-10-16 15:00:00');
}

/**
 * One last fix for opt_in null folks
 *
 * Bug: T204769
 */
function wmf_civicrm_update_7773() {
  return;
  global $databases;
  civicrm_initialize();
  $drupal = $databases['default']['default']['database'];
  CRM_Core_DAO::executeQuery("
    UPDATE civicrm_value_1_communication_4 comm
    INNER JOIN civicrm_contribution cc ON comm.entity_id = cc.contact_id
    INNER JOIN {$drupal}.contribution_tracking ct ON ct.contribution_id = cc.id
    SET comm.opt_in = 0
    WHERE comm.opt_in IS NULL
      AND ct.utm_source LIKE '%optIn0%'
      AND receive_date > '2018-08-01'
  ");

  CRM_Core_DAO::executeQuery("
    UPDATE civicrm_value_1_communication_4 comm
    INNER JOIN civicrm_contribution cc ON comm.entity_id = cc.contact_id
    INNER JOIN {$drupal}.contribution_tracking ct ON ct.contribution_id = cc.id
    SET comm.opt_in = 1
    WHERE comm.opt_in IS NULL
      AND ct.utm_source LIKE '%optIn1%'
      AND receive_date > '2018-08-01'
  ");
}

/**
 * Fix some PayPal donations that were mistakenly associated
 * with non-PayPal recurring records.
 *
 * Bug: T209008
 */
function wmf_civicrm_update_7781() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery("
    UPDATE civicrm_contribution c
    INNER JOIN civicrm_contribution_recur cr_wrong
      ON cr_wrong.id = c.contribution_recur_id
      AND (cr_wrong.trxn_id NOT LIKE 'I-%' AND cr_wrong.trxn_id NOT LIKE 'S-%')
    INNER JOIN wmf_contribution_extra x ON x.entity_id = c.id
    INNER JOIN civicrm_contribution_recur cr_right
      ON cr_right.contact_id = c.contact_id
      AND cr_right.amount = x.original_amount
      AND (cr_right.end_date IS NULL OR cr_right.end_date > '2018-09-01')
      AND (cr_right.trxn_id LIKE 'S-%')
    SET c.contribution_recur_id = cr_right.id
    WHERE c.trxn_id LIKE 'RECURRING PAYPAL%'
    AND c.id > 31850000
  ");
}

function wmf_civicrm_update_7782() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery("
    CREATE TEMPORARY TABLE rgoff AS
    SELECT id FROM (
      SELECT cr.id,
      DATEDIFF(DATE_ADD(DATE(max(receive_date) ), INTERVAL 1 month) , DATE(next_sched_contribution_date)) as date_diff
      FROM civicrm_contribution_recur cr
      LEFT JOIN civicrm_contribution c  on c.contribution_recur_id = cr.id
      WHERE end_date IS NULL
      AND cr.contribution_status_id <> 3
      AND cr.contribution_status_id <> 4
      AND c.trxn_id LIKE 'RECURRING GLOBALCOLLECT%'
      AND next_sched_contribution_date > '2016-01-01'
      AND frequency_unit = 'month' AND frequency_interval = 1
      GROUP BY cr.id DESC
     ) AS inn
    WHERE date_diff NOT BETWEEN -5 AND 5 AND date_diff > -28
  ");
  CRM_Core_DAO::executeQuery("
    CREATE TEMPORARY TABLE rgright AS
    SELECT rgoff.id, MAX(lcr.next_sched_contribution_date) AS correct_next_date
    FROM rgoff
    INNER JOIN log_civicrm_contribution_recur lcr ON lcr.id = rgoff.id
    WHERE lcr.log_date < '2018-11-06'
    GROUP BY rgoff.id
  ");
  CRM_Core_DAO::executeQuery("
    UPDATE civicrm_contribution_recur cr
    INNER JOIN rgright ON cr.id = rgright.id
    SET cr.next_sched_contribution_date = rgright.correct_next_date
  ");
}

/**
 * Add Lider and OCA payment instruments
 */
function wmf_civicrm_update_7785() {
  require_once 'update_payment_instruments.php';
  wmf_install_add_missing_payment_instruments();
}

/**
 * Update offline message template to match thank you letter.
 *
 * Notes in wmf_civicrm_update_7280 / T137496 still apply
 *
 * Bug T209895/ T211797 (running again for Endowment changes)
 */
function wmf_civicrm_update_7800() {
  require_once 'update_receipt.php';
  _wmf_civicrm_update_offline_receipt();
}

/**
 * Clean up duplicate transactions added by PayPal audit
 *
 * Bug: T209294
 */
function wmf_civicrm_update_7805() {
  civicrm_initialize();
  $donationsToDelete = CRM_Core_DAO::executeQuery("SELECT dupe.entity_id
FROM wmf_contribution_extra orig
INNER JOIN wmf_contribution_extra dupe
  ON orig.gateway='paypal'
  AND orig.gateway_txn_id = dupe.gateway_txn_id
  AND dupe.gateway='paypal_ec'
WHERE dupe.source_enqueued_time > '2018-10-01'
AND orig.source_enqueued_time > '2018-10-01'
AND dupe.source_type='audit'");
  while ($donationsToDelete->fetch()) {
    civicrm_api3('Contribution', 'delete', ['id' => $donationsToDelete->entity_id]);
  }
}

/**
 * Disable job to process smashpig recurring.
 *
 * We have job duplication between our cron and the scheduled job
 * triggered by the CiviCRM cron. Disable the Civi one.
 *
 * I also edited the mgd file that created the job to 'update' => 'never'
 * - this prevents itself from trying to reset any values that have changed
 * which might lead to it re-enabling itself - although I think that may not
 * happen as it doesn't specify 'is_active' & relies on defaults.
 *
 * In conjunction with deploying this we need to renable the cron
 *
 * Bug: T212727
 */
function wmf_civicrm_update_7810() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery("UPDATE civicrm_job SET is_active = 0 WHERE name = 'ProcessSmashPigRecurring'");
}

/**
 * Fix records for recurring donations mistakenly charged in USD.
 *
 * Until 2019-01-09, we had been charging recurring Ingenico donations in
 * USD, even when the original charge was in a foreign currency. And worse,
 * we were recording the donation as if we had charged them in the foreign
 * currency. This mismatch means the refund processor was freaking out
 * when it saw a refund for these donations.
 *
 * We filter for only installments 2+ by looking at the last 10 digits of
 * the transaction ID, which are 0000100001 for the first installment,
 * 0000200001 for the second, etc. Initial payments were charged in the
 * correct currency.
 *
 * Bug: T201473
 */
function wmf_civicrm_update_7815() {
  civicrm_initialize();
  $donationsToFix = CRM_Core_DAO::executeQuery("
    SELECT id, total_amount FROM civicrm_contribution
    WHERE trxn_id LIKE 'RECURRING INGENICO %'
    AND receive_date < '2019-01-09'
    AND LEFT(source, 3) <> 'USD'
    AND RIGHT(trxn_id, 10) <> '0000100001'
  ");
  $origCurrencyField = wmf_civicrm_get_custom_field_name('original_currency');
  $origAmountField = wmf_civicrm_get_custom_field_name('original_amount');
  while ($donationsToFix->fetch()) {
    civicrm_api3('Contribution', 'create', [
      'id' => $donationsToFix->id,
      'source' => "USD {$donationsToFix->total_amount}",
      $origCurrencyField => 'USD',
      $origAmountField => $donationsToFix->total_amount
    ]);
  }
}

/**
 * Enable Kam toolbar, civitutorial.
 */
function wmf_civicrm_update_7820() {
  wmf_civicrm_reconcile_extensions();
}

/**
 * Redo merges on contacts who have data not transferred across.
 *
 * (these are basically the result of merge jobs colliding & half-merging).
 *
 * Bug: T218061
 */
function wmf_civicrm_update_7830() {
  civicrm_initialize();
  $result = CRM_Core_DAO::executeQuery('
    SELECT DISTINCT contact_id
    FROM civicrm_contact c
    INNER JOIN civicrm_contribution cont ON contact_id = c.id
    WHERE c.is_deleted = 1
  ');
  $skippedContacts = [];
  while ($result->fetch()) {
    try {
      civicrm_api3('Merge', 'Redo', ['contact_id' => $result->contact_id]);
    } catch (Exception $e) {
      // I'm not necessarily expecting any to fail but who knows.
      $skippedContacts[] = $result->contact_id;
    }
  }
  // You can return a message but it only shows in the online update we don't use.
  if (function_exists('drush_print')) {
    drush_print(empty($skippedContacts) ? ts('OMG OMG it worked') : ts('Massive fail dude - contacts are' . implode(',', $skippedContacts)));
  }
}

/**
 * Add test processors.
 *
 * Each processor should have a live row & a test row.
 *
 * This fix should resolve the bug I saw
 * https://github.com/civicrm/civicrm-core/pull/13947
 *
 * But I think we should also fix our data.
 *
 * Bug: T218754
 */
function wmf_civicrm_update_7835() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery("

  INSERT INTO civicrm_payment_processor

  (`domain_id` ,
    `name` ,
    `description` ,
    `payment_processor_type_id` ,
    `is_active` ,
    `is_default`,
    `is_test`,
    `class_name`,
    `billing_mode`,
    `is_recur` ,
    `payment_type`,
    `payment_instrument_id`)

SELECT

  `domain_id` ,
  `name` ,
  `description` ,
  `payment_processor_type_id` ,
  `is_active` ,
  `is_default`,
  1 as `is_test`,
  `class_name`,
  `billing_mode`,
  `is_recur` ,
  `payment_type`,
  `payment_instrument_id`

 FROM civicrm_payment_processor");
}

/**
 * Enable thethe & remove the from existing sort names.
 *
 * Bug: T115536
 */
function wmf_civicrm_update_7840() {
  wmf_civicrm_reconcile_extensions();
  CRM_Core_DAO::executeQuery('
    UPDATE civicrm_contact
    SET sort_name = RIGHT(sort_name, LENGTH(sort_name) -4)
    WHERE sort_name LIKE "the %" AND contact_type = "Organization"
  ');

}
/**
 * Add recurring payment processor ids to contribution recur table.
 *
 * Bug: T218616
 */
function wmf_civicrm_update_7850() {
  civicrm_initialize();
  $processors = civicrm_api3('ContributionRecur', 'getoptions', ['field' => 'payment_processor_id'])['values'];
  foreach ($processors as $id => $name) {
    CRM_Core_DAO::executeQuery("
      UPDATE civicrm_contribution_recur cr
      LEFT JOIN civicrm_contribution c ON cr.id = c.contribution_recur_id
      LEFT JOIN wmf_contribution_extra w ON w.entity_id = c.id
      SET payment_processor_id = $id
      WHERE w.gateway = '{$name}'
    ");
  }
}

/**
 * Back-populate recurring cancel_reason.
 *
 * The logic here is that we find an cancelled recurrings & grab the earliest date they
 * became cancelled and then if that entry has no user id we assume it was an automated action.
 *
 * Bug: T218616
 */
function wmf_civicrm_update_7855() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery('ALTER TABLE log_civicrm_contribution_recur ADD index(contribution_status_id)');

  $maxId = CRM_CORE_DAO::singleValueQuery("SELECT max(id) FROM civicrm_contribution_recur");
  $batch = 5000;
  for ($startId = 0; $startId < $maxId; $startId += $batch) {
    $endId = $startId + $batch;
    // Most likely these are either
    // - smash pig max failures reached or
    // - paypal user initiated cancel.
    // We could put in more data based on that assumption but it feels like implying more certainty than we have.
    CRM_Core_DAO::executeQuery("
    UPDATE civicrm_contribution_recur cr INNER JOIN (

      SELECT cr.id, '(auto) backfilled automated cancel' as cancel_reason
      FROM log_civicrm_contribution_recur crlog
      INNER JOIN civicrm_contribution_recur cr ON cr.id = crlog.id
      INNER JOIN (
        SELECT crlog.id, min(crlog.log_date) as cancelled_date
        FROM log_civicrm_contribution_recur crlog
        INNER JOIN civicrm_contribution_recur cr ON cr.id = crlog.id
        # Cancelled
        WHERE crlog.contribution_status_id = 3
        AND crlog.log_action = 'Update'
        AND cr.id BETWEEN $startId AND $endId
        GROUP BY id
      ) as cancel_action
      ON crlog.id = cancel_action.id
      AND crlog.log_date = cancelled_date
      AND crlog.log_action = 'Update'
      WHERE ISNULL(crlog.log_user_id)
      AND cr.cancel_reason IS NULL

    ) as src ON src.id = cr.id

    SET cr.cancel_reason = src.cancel_reason
  ");

    // This second query looks for anything with an end date.
    // I have some reservations about this - can we make this judgement - or should we
    // a) leave blank of b) restricted to '(auto) backfilled automated end'
    CRM_Core_DAO::executeQuery("

    UPDATE civicrm_contribution_recur cr INNER JOIN (

      SELECT cr.id, '(auto) backfilled automated Expiration notification' as cancel_reason
      FROM log_civicrm_contribution_recur crlog
      INNER JOIN civicrm_contribution_recur cr ON cr.id = crlog.id
      INNER JOIN (
        SELECT crlog.id, min(crlog.log_date) as cancelled_date
        FROM log_civicrm_contribution_recur crlog
        INNER JOIN civicrm_contribution_recur cr ON cr.id = crlog.id
        # Completed, but with an end date
        WHERE crlog.end_date IS NOT NULL
        # Other than the 2 lines between the 2 comments & the message this is the same as the original.
        AND crlog.log_action = 'Update'
        AND cr.id BETWEEN $startId AND $endId
        GROUP BY id
      ) as cancel_action
      ON crlog.id = cancel_action.id
      AND crlog.log_date = cancelled_date
      AND crlog.log_action = 'Update'
      WHERE ISNULL(crlog.log_user_id)
      AND cr.cancel_reason IS NULL

    ) as src ON src.id = cr.id

    SET cr.cancel_reason = src.cancel_reason
  ");
  }
  CRM_Core_DAO::executeQuery('ALTER TABLE log_civicrm_contribution_recur DROP index contribution_status_id');

}

/**
 * Update default on is_locked field - this was in a civi update but we somehow missed it.
 *
 * Bug: T222559
 */
function wmf_civicrm_update_7860() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery("
    ALTER TABLE civicrm_option_group MODIFY COLUMN  is_locked TINYINT(4) NOT NULL DEFAULT 0 COMMENT 'A lock to remove the ability to add new options via the UI.'
  ");
}

/**
 * Null out some backfilled cancel reasons.
 *
 * The backfill looked at the 'act' of cancelling when determining what to do.
 * This relected our need to determine the 'user' but some were later uncancelled
 * due to data issues last year & this removes the cancel_reason from those.
 *
 * Bug: T218616
 */
function wmf_civicrm_update_7865() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery("
  UPDATE civicrm_contribution_recur cr
SET cancel_reason = NULL
WHERE cancel_reason IS NOT NULL and cancel_date IS NULL
  AND cancel_reason LIKE '%backfill%'
  AND contribution_status_id = 1");
}

/**
 * Update dlocal payment methods to support India
 *
 * Bug: T224514
 */
function wmf_civicrm_update_7870() {
  require_once 'update_payment_instruments.php';
  wmf_install_add_missing_payment_instruments();
}

/**
 * Add opt-in tracking fields.
 */
function wmf_civicrm_update_7875() {
  require_once 'update_custom_fields.php';
  _wmf_civicrm_update_custom_fields();
}

/**
 * Remove old calculated fields.
 *
 * Bug: T170972
 * Bug: T222958
 *
 * @throws \CiviCRM_API3_Exception
 */
function wmf_civicrm_update_7885() {
  civicrm_initialize();
  require_once 'update_custom_fields.php';
  $fields = _wmf_civicrm_get_wmf_donor_fields_to_remove();
  CRM_Core_DAO::executeQuery('DELETE FROM civicrm_custom_field WHERE name IN ("' . implode('", "', $fields) . '")');
  $alters = [];
  foreach ($fields as $index => $field) {
    if (CRM_Core_BAO_SchemaHandler::checkIfFieldExists('wmf_donor', $field)) {
      $alters[] = 'DROP COLUMN ' . $field;
    }
  }

  if (!empty($alters)) {
    CRM_Core_DAO::executeQuery('ALTER TABLE wmf_donor ' . implode(',',  $alters));
  }
  civicrm_api3('System', 'flush', ['triggers' => 0, 'session' => 0]);
}

/**
 * Add new calculated fields.
 *
 * Bug: T170972
 * Bug: T222958
 *
 * @throws \CiviCRM_API3_Exception
 */
function wmf_civicrm_update_7886() {
  require_once 'update_custom_fields.php';
  _wmf_civicrm_update_custom_fields();

}

/**
 * Add index to civicrm_activity.location.
 *
 * Bug: T228106
 */
function wmf_civicrm_update_7890() {
  civicrm_initialize();
  $tables = ['civicrm_activity' => ['location']];
  CRM_Core_BAO_SchemaHandler::createIndexes($tables);
}

/**
 * Set default of zero on pre-existing amount fields.
 *
 * I added the default in the install to match the others
 * but that puts live out of sync with dev environments.
 *
 * I tested on staging & just adding defaults to fields is nearly instant.
 *
 * Bug: T222958
 */
function wmf_civicrm_update_7895() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery('
    ALTER TABLE wmf_donor ALTER COLUMN lifetime_usd_total SET DEFAULT 0,
    ALTER COLUMN last_donation_usd SET DEFAULT 0,
    ALTER COLUMN last_donation_amount SET DEFAULT 0
  ');

}

/**
 * Update contacts with no completed contributions to have 0 for lifetime donations.
 *
 * The drush script to update the new fields looks for a non-zero value here & updates but
 * the calculation in the drush script is not updating the largest donation to be > 0 & the way
 * the script runs it is getting 'stuck' on ~300 with lifetime_usd_total > 0 despite having no
 * contributions or them all being refunded.
 *
 * I feel like a bigger dig doesn't feel warranted in terms of effort here.
 *
 * Bug: T222958
 *
 */
function wmf_civicrm_update_7900() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery('
    UPDATE wmf_donor
    LEFT JOIN civicrm_contribution c ON c.contact_id = wmf_donor.entity_id AND contribution_status_id = 1
    SET lifetime_usd_total = 0
    WHERE lifetime_usd_total > 0 AND largest_donation = 0 AND c.id IS NULL
  ');

}

/**
 * Update contacts with wmf_donor information but only refunded or no contributions.
 *
 * Per https://gerrit.wikimedia.org/r/#/c/wikimedia/fundraising/crm/+/527706/ we are now excluding refund adjustments
 * from calculations. In addition some contacts whose contributions were merged to another donor while triggers were off
 * incorrectly show an amount.
 *
 * Bug: T229273
 *
 * SELECT count(*), min(entity_id), max(entity_id)
 * FROM wmf_donor d
 * LEFT JOIN civicrm_contribution cont
 *   ON d.entity_id = cont.contact_id
 *   AND (cont.trxn_id NOT LIKE 'RFD%' OR cont.trxn_id IS NULL) AND contribution_status_id = 1
 * WHERE cont.id IS NULL and d.last_donation_date IS NOT NULL ;
 * +----------+----------------+----------------+
 * | count(*) | min(entity_id) | max(entity_id) |
 * +----------+----------------+----------------+
 * |    16750 |          98371 |       34696854 |
 */
function wmf_civicrm_update_7905() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery("
    UPDATE wmf_donor d
        LEFT JOIN civicrm_contribution cont
        ON
            d.entity_id = cont.contact_id
            AND (cont.trxn_id NOT LIKE 'RFD%' OR cont.trxn_id IS NULL)
            AND contribution_status_id = 1
    SET
         last_donation_date = NULL,
         last_donation_currency = NULL,
         last_donation_amount = 0,
         last_donation_usd = 0,
         lifetime_usd_total = 0,
         total_2006_2007 = 0,
         total_2007_2008 = 0,
         total_2008_2009 = 0,
         total_2009_2010 = 0,
         total_2010_2011 = 0,
         total_2011_2012 = 0,
         total_2012_2013 = 0,
         total_2013_2014 = 0,
         total_2014_2015 = 0,
         total_2015_2016 = 0,
         total_2016_2017 = 0,
         total_2017_2018 = 0,
         total_2018_2019 = 0,
         total_2019_2020 = 0,
         total_2020_2021 = 0,
         endowment_last_donation_date = NULL,
         first_donation_date = NULL,
         endowment_first_donation_date = NULL,
         first_donation_usd = 0,
         lifetime_including_endowment = 0,
         endowment_lifetime_usd_total = 0,
         number_donations = 0,
         endowment_number_donations = 0,
         largest_donation = 0,
         endowment_largest_donation = 0,
         date_of_largest_donation = NULL,
         total_2006 = 0,
         total_2007 = 0,
         total_2008 = 0,
         total_2009 = 0,
         total_2010 = 0,
         total_2011 = 0,
         total_2012 = 0,
         total_2013 = 0,
         total_2014 = 0,
         total_2015 = 0,
         total_2016 = 0,
         total_2017 = 0,
         change_2017_2018 = 0,
         total_2018 = 0,
         endowment_total_2018 = 0,
         endowment_total_2018_2019 = 0,
         change_2018_2019 = 0,
         total_2019 = 0,
         endowment_total_2019 = 0,
         endowment_total_2019_2020 = 0,
         change_2019_2020 = 0,
         total_2020 = 0,
         endowment_total_2020 = 0,
         endowment_total_2020_2021 = 0,
         change_2020_2021 = 0

    WHERE cont.id IS NULL and d.last_donation_date IS NOT NULL
  ");
}

/**
 * Replace any spaces in email addresses.
 *
 * I searched for emails with leading  & trailing emails & only found about 1200
 * so this seems unlikely to be the  full problem but fixing makes sense since
 * it would always be invalid.
 *
 * Bug: T231330
 */
function wmf_civicrm_update_7910() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery('
    UPDATE civicrm_email
    SET email = REPLACE(email, " ", "")
    WHERE email LIKE "% %"
  ');
}

/**
 * Move any prospecting records from deleted contacts to contacts they were merged to with none.
 *
 * There is an issue whereby seemingly some UI merges of contacts have not carried across the
 * prospecting records.
 *
 * There are some trickinesses here
 * 1) what to do if the prospect data is not missing but wholly or in part different?
 * 2) what to do if the contact has been merged multiple times.
 *
 * My current strategy is to ignore these issues & hope they go away.
 *
 * Specifically this update only deals with fixing the situation where the merged-to-record has
 * no row whatsoever in the prospect custom data table. There are 3918 contacts in this situation.
 * This is more than the 3215 where the deleted contact has 'some data' in one of the following 3  fields
 * - net worth
 * - family composition
 *  -income
 * and the merged-to-contact has NULL in all 3 fields, but less than the 4181 contacts have NULL or DIFFERENT
 * data in the 3 mentioned fields.
 *
 * I haven't dug too heavily into whether the extra 400 have all null info or some info - it seems
 * safe & sensible  to move whatever data there is across.
 *
 * In a token note of concern for contacts who have been through  multiple merges I'm iterating through
 * this as a loop - so if the contact I move their data too has been deleted then the next iteration will move their
 * data across to the contact that contact was merged to.
 *
 * I expect there to be some hundreds with different data left &  I will look at those next - once this 'noise'
 * is gone.
 *
 * Bug: T232636
 */
function wmf_civicrm_update_7915() {
  civicrm_initialize();
  $customGroupTable = civicrm_api3('CustomGroup', 'getvalue', [
    'name' => 'Prospect',
    'return' => 'table_name',
  ]);

  $fromSql = "
    $customGroupTable deleted_prospect_data
    INNER JOIN civicrm_contact deleted_contact ON deleted_prospect_data.entity_id = deleted_contact.id
    LEFT JOIN civicrm_activity_contact ac ON ac.contact_id = deleted_contact.id AND ac.record_type_id =3
    LEFT JOIN civicrm_activity a ON a.id = ac.activity_id
    LEFT JOIN civicrm_activity_contact new_contact ON new_contact.activity_id = a.id
      AND new_contact.record_type_id = 1
    LEFT JOIN $customGroupTable updated_prospect ON updated_prospect.entity_id = new_contact.contact_id
  ";

  $whereSQL = '
    WHERE deleted_contact.is_deleted = 1 AND activity_type_id = 87
    AND deleted_prospect_data.id IS NOT NULL
    AND updated_prospect.id IS NULL
   ';

  // This outer loop handles the possibility the inner loop may create more transfers.
  while (CRM_Core_DAO::singleValueQuery("SELECT count(*) FROM $fromSql $whereSQL")) {
    $row = CRM_Core_DAO::executeQuery("
      SELECT deleted_prospect_data.id, new_contact.contact_id
      FROM $fromSql
      LEFT JOIN log_{$customGroupTable} log ON log.id = deleted_prospect_data.id
          $whereSQL
      # How on earth do we prioritise these? The scenario is that several contacts might have been merged to
      # 'targetsmartless' contact? Probably unless the data is from last year's import it's much the same.
      # Joining in the log table to get the most recently modified is probably an OK solution.
      # it will get a few duplicate rows but we skip those later rather anyway.
      ORDER BY log.log_date DESC
      "
    );
    $updatedContacts = [];

    while ($row->fetch()) {
      if (isset($updatedContacts[$row->contact_id])) {
        // A previous update in the loop means the contact now has a row.
        continue;
      }
      // There is only about 3k rows so one interaction of individual inserts is OK for that number.
      // Doing mysql updates directly fails due to triggers getting all circular.
      CRM_Core_DAO::executeQuery("UPDATE $customGroupTable SET entity_id = {$row->contact_id} WHERE id = {$row->id}");
      $updatedContacts[$row->contact_id] = TRUE;
    }
  }
}

/**
 * Add indexes - these are present for new installs from 5.18.
 *
 * This will open up some much better deduping options - ie  dedupe
 * recently modified.
 */
function wmf_civicrm_update_7920() {
  civicrm_initialize();
  $tables = ['civicrm_contact' => ['created_date', 'modified_date']];
  CRM_Core_BAO_SchemaHandler::createIndexes($tables);
}

/**
 * Add setting to move communication preferences to the extension.
 *
 * Bug: T235450
 *
 * @throws \CiviCRM_API3_Exception
 */
function wmf_civicrm_update_7925() {
  civicrm_initialize();
  civicrm_api3('Setting', 'create', [
    'deduper_resolver_bool_prefer_yes' => ['on_hold', 'do_not_email', 'do_not_phone', 'do_not_mail', 'do_not_sms', 'do_not_trade', 'is_opt_out'],
  ]);
}


/**
 * T235212 fix financial trxn record for contributions missing
 * to_financial_account_id, and create account associations for payment
 * methods missing them.
 *
 */
function wmf_civicrm_update_7930() {
  civicrm_initialize();
  $depositFinancialAccountID = civicrm_api3('FinancialAccount', 'getvalue', array(
    'return' => 'id',
    'name' => 'Deposit Bank Account',
  ));

  $cashFinancialTypeID = civicrm_api3('FinancialType', 'getvalue', array(
    'return' => 'id',
    'name' => 'Cash',
  ));
  CRM_Core_DAO::executeQuery(
    "UPDATE
     civicrm_contribution con
     LEFT JOIN civicrm_entity_financial_trxn eft ON (eft.entity_id = con.id AND eft.entity_table = 'civicrm_contribution')
     INNER JOIN civicrm_financial_trxn ft ON ft.id = eft.financial_trxn_id

     SET ft.to_financial_account_id = %1

     WHERE ft.to_financial_account_id IS NULL AND con.financial_type_id = %2",
    array(
      1 => array($depositFinancialAccountID, 'Integer'),
      2 => array($cashFinancialTypeID, 'Integer'),
    )
  );
  $methodsMissingMaps = CRM_Core_DAO::executeQuery(
    "SELECT ov.*
     FROM civicrm_option_group og
     INNER JOIN civicrm_option_value ov
        ON og.name='payment_instrument'
        AND ov.option_group_id = og.id
     LEFT JOIN civicrm_entity_financial_account efa
        ON efa.entity_id = ov.id
        AND efa.entity_table='civicrm_option_value'
     WHERE efa.id IS NULL"
  );
  while($methodsMissingMaps->fetch()) {
    civicrm_api3('EntityFinancialAccount', 'create', array(
      'entity_id' => $methodsMissingMaps->id,
      'entity_table' => 'civicrm_option_value',
      'account_relationship' => 'Asset Account is',
      'financial_account_id' => 'Deposit Bank Account',
    ));
  }
}

/**
 * Add dedupe tools settings to handle opt_in & source.
 *
 * Bug T232037
 *
 * @throws \CiviCRM_API3_Exception
 */
function wmf_civicrm_update_7935() {
  civicrm_initialize();
  civicrm_api3('Setting', 'create', ['deduper_resolver_field_prefer_preferred_contact' => ['contact_source', wmf_civicrm_get_custom_field_name('opt_in')]]);
  civicrm_api3('Setting', 'create', ['deduper_resolver_preferred_contact_resolution' => ['most_recent_contributor']]);
  civicrm_api3('Setting', 'create', ['deduper_resolver_preferred_contact_last_resort' => 'most_recently_created_contact']);
}

/**
 * Add some indexes that are missing.
 *
 * These are on relatively small tables so haven't lept out but I hit a query
 * I couldn't due due to the missing index on civicrm_mailing_stats.mailing_id
 * and figured while I'm at it I should add to civicrm_group. The table is small so
 * I only noticed the lack of index when the server was on go-slow. Both tables are small
 * enough  this should be near-instant.
 *
 * Bug: T236955
 */
function wmf_civicrm_update_7940() {
  civicrm_initialize();
  $tables = ['civicrm_mailing_stats' => ['mailing_id'], 'civicrm_group' => ['cache_date', 'refresh_date']];
  CRM_Core_BAO_SchemaHandler::createIndexes($tables);
}

/**
 * Fix cycle day for monthly conversions
 *
 * Monthly convert was inappropriately setting cycle day to 1.  Set it to the same day of the month
 * as the start date per intended functionality.
 *
 * Bug: T239627
 */
function wmf_civicrm_update_7950() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery('
    UPDATE civicrm_contribution_recur
    SET cycle_day = day(start_date)
    WHERE start_date > "2019-09-01" AND cycle_day <> day(start_date) AND trxn_id like "%INGENICO%"
    AND cycle_day = 1 AND start_date = DATE_ADD(create_date, INTERVAL 1 MONTH)
  ');
}

/**
 * Fix recurring dates
 *
 * Set close ones so they are charged immediately, further away ones to next month
 *
 * Bug: T240272
 */
function wmf_civicrm_update_7960() {
  civicrm_initialize();
  // Ones for this month
  CRM_Core_DAO::executeQuery('
    UPDATE civicrm_contribution_recur
    SET cancel_date = NULL,cancel_reason = NULL, end_date = NULL, contribution_status_id = 1, failure_count = 0, next_sched_contribution_date = "2019-12-11 00:00"
    WHERE payment_processor_id = 5 AND contribution_status_id = 3
    AND cancel_reason = "(auto) maximum failures reached"
    AND cancel_date > "2019-12-06"
  ');

  // Ones that are just being charged next month
  CRM_Core_DAO::executeQuery('
    UPDATE civicrm_contribution_recur
    SET cancel_date = NULL,cancel_reason = NULL, end_date = NULL, contribution_status_id = 1, failure_count = 0, next_sched_contribution_date = DATE_SUB(DATE_ADD(next_sched_contribution_date, INTERVAL 1 MONTH), INTERVAL 2 DAY)
    WHERE payment_processor_id = 5 AND contribution_status_id = 3
    AND cancel_reason = "(auto) maximum failures reached"
    AND cancel_date > "2019-11-20" AND cancel_date < "2019-12-06"
  ');
}

/**
 * Add indexes to civicrm_acl_cache.modified_date.
 *
 * Despite being basically empty this table is involved in deadlocks
 * frequently.
 *
 * I've added this index upstream
 * https://github.com/civicrm/civicrm-core/pull/16144
 * It should be super quick to run so won't require an outage.
 *
 * I'm looking into further ways to improve contention on this table
 * https://lab.civicrm.org/dev/core/issues/1486
 *
 */
function wmf_civicrm_update_7965() {
  civicrm_initialize();
  $tables = ['civicrm_acl_cache' => ['modified_date']];
  CRM_Core_BAO_SchemaHandler::createIndexes($tables);
}

/**
 * Change name of wmf deduper extension.
 */
function wmf_civicrm_update_7972() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery('UPDATE civicrm_extension SET name = "Deduper", full_name = "deduper", label = "Deduper", file = "deduper" WHERE full_name = "org.wikimedia.dedupetools"');
  civicrm_api3('Extension', 'refresh', []);
}

/**
 * Fix bad contribution_recur data from PayPal October 2018 cancel-storm
 *
 * Bug: T217379
 */
function wmf_civicrm_update_7980() {
  civicrm_initialize();
  $contributionStatusId = CRM_Contribute_PseudoConstant::contributionStatus(NULL, 'name');
  $cancelledStatusId = CRM_Utils_Array::key('Cancelled', $contributionStatusId);
  $completedStatusId = CRM_Utils_Array::key('Completed', $contributionStatusId);

  CRM_Core_DAO::executeQuery("
    UPDATE civicrm_contribution_recur
    SET
      contribution_status_id = $completedStatusId,
      cancel_date = NULL
    WHERE (
      trxn_id LIKE 'I-%' OR trxn_id LIKE 'S-%'
    )
    AND cancel_date BETWEEN '2018-10-24 00:00:00' AND '2018-10-24 23:59:59'
    AND next_sched_contribution_date > '2019-12-18 00:00:00'
    AND contribution_status_id = $cancelledStatusId
  ");
}

/**
 * Set no-thank-you-reason field to NULL for manually entered Donor-Advised-Fund donations who have emails.
 *
 * It appears Engage needed to, and didn't, remove the no-thank-you-reason field value to trigger emails.
 *
 * Confirmation of the date range to include
 * https://phabricator.wikimedia.org/T233374#5808098
 *
 * Bug: T233374
 *
 * @throws \CiviCRM_API3_Exception
 */
function wmf_civicrm_update_7985() {
  civicrm_initialize();
  $giftDataTable = civicrm_api3('CustomGroup', 'getvalue', ['name' => 'Gift_Data', 'return' => 'table_name']);
  CRM_Core_DAO::executeQuery("
    UPDATE civicrm_contribution c
    INNER JOIN civicrm_email e ON c.contact_id = e.contact_id AND e.is_primary = 1
    LEFT JOIN wmf_contribution_extra w ON w.entity_id = c.id
    LEFT JOIN $giftDataTable g ON g.entity_id = c.id
    SET no_thank_you = NULL
    WHERE no_thank_you = 'Manually Entered'
    AND campaign = 'Donor Advised Fund'
    AND email LIKE '%' #a bit precautionary given the inner join on the record existing.
    AND thankyou_date IS NULL
    AND receive_date > '2019-11-01'
  ");
}

/**
 * Move any prospecting records from deleted contacts to contacts they were merged to with none.
 *
 * This is a re-run from wmf_civicrm_update_7915 and there are comments on that one.
 *
 * My analysis in https://phabricator.wikimedia.org/T232636#5818528
 * suggests we can catch another 443 records doing this & the others might not be worth it.
 *
 * UI changes should mean unintentional prospect data loss is no longer occurring.
 *
 * Bug: T232636
 */
function wmf_civicrm_update_7990() {
  wmf_civicrm_update_7915();
}

/**
 * Fix re-numbering of activity types.
 *
 * Our last update suffered from https://lab.civicrm.org/dev/core/issues/1498
 *
 * In digging log_civicrm_managed I find that we lost a handle of entities which were re-created.
 *
 * 1) A bunch of report templates - these are referenced in civicrm_report_instance by path
 * so it doesn't matter
 *
 * 2) 2 activity types
 *   - unsubscribe value 99 was deleted & 155 created
 *   - contact_type_changed from 109 to 156
 *
 * Useful queries:
 *
 * SELECT entity_id FROM log_civicrm_managed WHERE log_action='Delete' AND log_date > '2020-02-01'
 * SELECT DISTINCT value, name, label FROM log_civicrm_option_value  WHERE id IN (SELECT entity_id FROM log_civicrm_managed WHERE log_action='Delete' AND log_date > '2020-02-01');
 *
 * Bug: T245090
 *
 * @throws \CiviCRM_API3_Exception
 */
function wmf_civicrm_update_7995() {
  civicrm_initialize();
  $ids = [99 => 155, 109 => 156];
  $optionGroupID = civicrm_api3('OptionGroup', 'getvalue', ['return' => 'id', 'name' => 'activity_type']);
  foreach ($ids as $oldID => $newID) {
    CRM_Core_DAO::executeQuery("UPDATE civicrm_option_value SET value = $oldID WHERE value = $newID AND option_group_id = $optionGroupID");
    CRM_Core_DAO::executeQuery("UPDATE civicrm_activity SET activity_type_id = $oldID WHERE activity_type_id = $newID");
  }
}

/**
 * Drop log of omnimail progress.
 *
 * This needs to be done after https://gerrit.wikimedia.org/r/#/c/wikimedia/fundraising/crm/+/571845/
 * is deployed & in conjunction with a before and after db size check. (we can bundle the
 * db size check with the next few updates.
 *
 * Bug: T244934
 */
function wmf_civicrm_update_8000() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery('DROP TABLE IF EXISTS log_civicrm_omnimail_job_progress');
}

/**
 * Drop log of wmf_donor table.
 *
 * We exclude wmf_donor form logging but we still have data from when we didn't.
 *
 * Note searching our trigger file DOES show that we reference wmf_donor but only for
 * purposes of updating civicrm_contact.modified_date - which is probably is a good thing.
 * The string log_wmf_donor is not present.
 *
 * Also we want to action this in conjunction with measuring db size changes.
 *
 * Bug: T245086
 */
function wmf_civicrm_update_8005() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery('DROP TABLE IF EXISTS log_wmf_donor');
}

/**
 * Truncate log_civicrm table.
 *
 * The data in this table adds  no value  over & above  the log tables.
 * It's 32 GB. I'm not sure it will build back up fast enough to warrant us doing anything
 * to prevent that - I think getting rid of what is there might be enough for now.
 *
 * Upstream https://lab.civicrm.org/dev/core/issues/1586
 *
 * Also we want to action this in conjunction with measuring db size changes.
 *
 * Bug: T245085
 */
function wmf_civicrm_update_8010() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery('TRUNCATE TABLE civicrm_log');
}

/**
 * Disable slow system checks.
 *
 * This allows us to remove the code that hacks the whole subsystem out & just
 * run the ones that don't hurt performance. I ran them all with logging on to pick what to
 * disable. Output:
 *
 * Feb 18 14:43:19  [info] calling checkLocaleSupportsAddressParsing
 *
 * Feb 18 14:43:19  [info] finished checkLocaleSupportsAddressParsing
 *
 * Feb 18 14:43:19  [info] calling checkPhpVersion
 *
 * Feb 18 14:43:19  [info] finished checkPhpVersion
 *
 * Feb 18 14:43:19  [info] calling checkPhpMysqli
 *
 * Feb 18 14:43:19  [info] finished checkPhpMysqli
 *
 * Feb 18 14:43:19  [info] calling checkMysqlTime
 *
 * Feb 18 14:43:19  [info] finished checkMysqlTime
 *
 * Feb 18 14:43:19  [info] calling checkDebug
 *
 * Feb 18 14:43:19  [info] finished checkDebug
 *
 * Feb 18 14:43:19  [info] calling checkOutboundMail
 *
 * Feb 18 14:43:19  [info] finished checkOutboundMail
 *
 * Feb 18 14:43:19  [info] calling checkDomainNameEmail
 *
 * Feb 18 14:43:19  [info] finished checkDomainNameEmail
 *
 * Feb 18 14:43:19  [info] calling checkDefaultMailbox
 *
 * Feb 18 14:43:19  [info] finished checkDefaultMailbox
 *
 * Feb 18 14:43:19  [info] calling checkLastCron
 *
 * Feb 18 14:43:19  [info] finished checkLastCron
 *
 * Feb 18 14:43:19  [info] calling checkUrlVariables
 *
 * Feb 18 14:43:19  [info] finished checkUrlVariables
 *
 * Feb 18 14:43:19  [info] calling checkDirVariables
 *
 * Feb 18 14:43:19  [info] finished checkDirVariables
 *
 * Feb 18 14:43:19  [info] calling checkDirsWritable
 *
 * Feb 18 14:43:19  [info] finished checkDirsWritable
 *
 * Feb 18 14:43:19  [info] calling checkVersion
 *
 * Feb 18 14:43:19  [info] finished checkVersion
 *
 * Feb 18 14:43:19  [info] calling checkExtensionUpgrades
 *
 * Feb 18 14:43:19  [info] finished checkExtensionUpgrades
 *
 * Feb 18 14:43:19  [info] calling checkDbVersion
 *
 * Feb 18 14:43:19  [info] finished checkDbVersion
 *
 * Feb 18 14:43:19  [info] calling checkDbEngine
 *
 * Feb 18 14:43:19  [info] finished checkDbEngine
 *
 * Feb 18 14:43:19  [info] calling checkReplyIdForMailing
 *
 * Feb 18 14:43:19  [info] finished checkReplyIdForMailing
 *
 * Feb 18 14:43:19  [info] calling checkMbstring
 *
 * Feb 18 14:43:19  [info] finished checkMbstring
 *
 * Feb 18 14:43:19  [info] calling checkEnvironment
 *
 * Feb 18 14:43:19  [info] finished checkEnvironment
 *
 * Feb 18 14:43:19  [info] calling checkResourceUrl
 *
 ****** Feb 18 14:43:24  [info] finished checkResourceUrl
 *
 * Feb 18 14:43:24  [info] calling checkMysqlUtf8mb4
 *
 * Feb 18 14:43:24  [info] finished checkMysqlUtf8mb4
 *
 * Feb 18 14:43:24  [info] calling checkFinancialAclReport
 *
 * Feb 18 14:43:24  [info] finished checkFinancialAclReport
 *
 * Feb 18 14:43:24  [info] calling checkOptionGroupValues
 *
 * Feb 18 14:43:24  [info] finished checkOptionGroupValues
 *
 * Feb 18 14:43:24  [info] calling checkPriceFields
 *
 * Feb 18 14:43:24  [info] finished checkPriceFields
 *
 * Feb 18 14:43:24  [info] calling checkIndices
 *
 * Feb 18 14:43:24  [info] finished checkIndices
 *
 * Feb 18 14:43:24  [info] calling checkMissingLogTables
 *
 * Feb 18 14:43:24  [info] finished checkMissingLogTables
 *
 * Feb 18 14:43:24  [info] calling checkLogFileIsNotAccessible
 *
 * Feb 18 14:43:24  [info] finished checkLogFileIsNotAccessible
 *
 * Feb 18 14:43:24  [info] calling checkUploadsAreNotAccessible
 *
 ***** Feb 18 14:43:34  [info] finished checkUploadsAreNotAccessible
 *
 * Feb 18 14:43:34  [info] calling checkDirectoriesAreNotBrowseable
 *
 ***** Feb 18 14:44:34  [info] finished checkDirectoriesAreNotBrowseable
 *
 * Feb 18 14:44:34  [info] calling checkFilesAreNotPresent
 *
 * Feb 18 14:44:34  [info] finished checkFilesAreNotPresent
 *
 * Feb 18 14:44:34  [info] calling checkRemoteProfile
 *
 * Feb 18 14:44:34  [info] finished checkRemoteProfile
 *
 * Feb 18 14:44:34  [info] calling checkCxnOverrides
 *
 * Feb 18 14:44:34  [info] finished checkCxnOverrides
 *
 * Feb 18 14:44:34  [info] calling checkOrphans
 *
 * Feb 18 14:44:34  [info] finished checkOrphans
 *
 * Feb 18 14:44:34  [info] calling checkSchema
 *
 * Feb 18 14:44:34  [info] finished checkSchema
 *
 * @throws \Civi\API\Exception\UnauthorizedException
 */
function wmf_civicrm_update_8015() {
  civicrm_initialize();
  $slowChecks = [
    'checkResourceUrl',
    'checkUploadsAreNotAccessible',
    'checkDirectoriesAreNotBrowseable',
    // These 2 did not show up as slow above but I'm pretty sure it's because the results
    // were already cached - they DO rely on crossing the firewall
    'checkVersion',
    'checkExtensions',
    // Let's disable this too as we are deliberately not running cron.
    'checkLastCron',
  ];
  foreach ($slowChecks as $slowCheck) {
    \Civi\Api4\StatusPreference::create()
      ->addValue('name', $slowCheck)
      ->addValue('is_active', 0)
      ->setCheckPermissions(FALSE)
      ->execute();
  }
}

/**
 * Update contribution recur statuses.
 *
 * Use the new statuses we negotiated in Barcelona so that we
 * are no longer misusing the old ones (& nno longer need civi hacks to support that).
 *
 * Note this is likely to also address Michael's issues about not being able to cancel
 * 'Failed' because they will be 'Failing' instead - which is not caught.
 *
 * Bug: T244326
 *
 * @throws \CiviCRM_API3_Exception
 */
function wmf_civicrm_update_8020() {
  civicrm_initialize();
  $statuses = array_flip(civicrm_api3('ContributionRecur', 'getoptions', [
    'field' => "contribution_recur_contribution_status_id",
  ])['values']);

  CRM_Core_DAO::executeQuery(
    "UPDATE civicrm_contribution_recur
    SET contribution_status_id = {$statuses['Processing']}
    WHERE contribution_status_id = {$statuses['In Progress']}"
  );
  CRM_Core_DAO::executeQuery(
    "UPDATE civicrm_contribution_recur
    SET contribution_status_id = {$statuses['Failing']}
    WHERE contribution_status_id = {$statuses['Failed']}"
  );
}

/**
 * Get rid of old review tags.
 *
 * See https://phabricator.wikimedia.org/T245577#5895651 for analysis
 *
 * Bug: T245577
 *
 * @throws \CiviCRM_API3_Exception
 */
function wmf_civicrm_update_8025() {
  civicrm_initialize();

  $tagsToDelete = [
    'Quick autoreviewed',
    'Autoreviewed - Unique',
    'Manually reviewed - Revert address',
    'Manually reviewed - Revert name',
    'Manually reviewed - Revert email',
    'Manually reviewed - Perform action',
    'Manually reviewed - Revert language',
  ];

  // these tags don't exist across all environments so let's add some checks.
  $quickAutoReviewTagExists = CRM_Core_DAO::singleValueQuery('SELECT id FROM civicrm_tag WHERE name = "' . $tagsToDelete[0] . '"');
  $otherTagsInSQL = implode('","', array_slice($tagsToDelete, 1, 6));
  $otherTagsExists = CRM_Core_DAO::singleValueQuery('SELECT id FROM civicrm_tag WHERE name IN ("' . $otherTagsInSQL . '")');

  if ($quickAutoReviewTagExists !== NULL) {
    // https://www.namasteui.com/mysql-group_concat-maximum-length/
    CRM_Core_DAO::executeQuery('SET SESSION group_concat_max_len = 10000000');
    $autoReviewTagID = CRM_Core_DAO::singleValueQuery('SELECT id FROM civicrm_tag WHERE name = "Quick autoreviewed"');
    $batchLimit = 500;

    while (CRM_Core_DAO::singleValueQuery('SELECT id FROM civicrm_entity_tag WHERE tag_id = ' . $autoReviewTagID . ' LIMIT 1')) {

      $ids = CRM_Core_DAO::singleValueQuery(
        "SELECT GROUP_CONCAT(id) FROM (SELECT id FROM civicrm_entity_tag WHERE tag_id = $autoReviewTagID LIMIT $batchLimit) as t"
      );
      CRM_Core_DAO::executeQuery('DELETE FROM civicrm_entity_tag WHERE id IN (' . $ids . ')');
      CRM_Core_DAO::executeQuery('DELETE FROM log_civicrm_entity_tag WHERE id IN (' . $ids . ')');
    }
  }

  if ($otherTagsExists !== NULL) {
    CRM_Core_DAO::executeQuery('DELETE FROM civicrm_tag WHERE name IN ("' . implode('","', $tagsToDelete) . '")');
  }
}

/**
 * Remove defunct contribution recur statuses
 *
 * Bug: T245326
 *
 * @throws \CiviCRM_API3_Exception
 */
function wmf_civicrm_update_8030() {
  civicrm_initialize();
  civicrm_api3('OptionValue', 'get', [
    'sequential' => 1,
    'option_group_id' => "contribution_recur_status",
    'name' => ['IN' => ["Settled", "Paid", "Refunded", "Partially paid", "Chargeback", "Pending refund"]],
    'api.OptionValue.delete' => [],
  ]);
}

/**
 * Create ts 2020 export group.
 *
 * This creates a group for the contacts to be updated in the 2020
 * ts export. From testing on staging it is possible to actually export this many rows
 * and by putting them in a group we give MG a chance to dedupe first if they wish.
 *
 * Bug: T247624
 *
 * @throws \CiviCRM_API3_Exception
 */
function wmf_civicrm_update_8035() {
  civicrm_initialize();
  $groupID = (int) civicrm_api3('Group', 'create', [
    'name' => 'targetsmart_export_2020',
    'title' => 'Target smart export 2020',
    'description' => 'Contacts to be exported for target smart this year',
  ])['id'];
  $communicationPreferencesTableName = civicrm_api3('CustomGroup', 'getvalue', ['return' => 'table_name', 'name' => 'Communication']);
  CRM_Core_DAO::executeQuery(
    "INSERT INTO civicrm_group_contact (group_id, status, contact_id)
    SELECT $groupID, 'Added', wmf.entity_id
    FROM wmf_donor AS wmf
    INNER JOIN civicrm_contact AS c ON c.id = wmf.entity_id
    INNER JOIN civicrm_address AS a ON (c.id = a.contact_id AND a.is_primary = 1)
    LEFT JOIN $communicationPreferencesTableName cv ON cv.entity_id = wmf.entity_id
    INNER JOIN civicrm_email e ON e.contact_id = c.id AND e.is_primary = 1 AND e.on_hold IS NOT NULL

    WHERE
      c.contact_type = 'Individual'
      AND a.country_id = 1228
      AND a.street_address IS NOT NULL
      # This complex clause gets the earliest of endowment_first_donation_date & first_donation_date
      # and ensures it is greater than 1 Jul 2019
      # effectively 'first gave this financial year'
      AND IF(wmf.first_donation_date IS NULL OR wmf.endowment_first_donation_date IS NULL,
         COALESCE(wmf.first_donation_date, wmf.endowment_first_donation_date),
         LEAST(wmf.first_donation_date,wmf.endowment_first_donation_date)) >= '2019-07-01'
      AND c.is_deleted = 0

      # Yep 3 forms of opt in / out & we have to be careful about NULL
      AND c.is_opt_out = 0
      AND (cv.do_not_solicit = 0 OR cv.do_not_solicit IS NULL)
      AND (cv.opt_in = 1 OR cv.opt_in IS NULL)

      # total of the 2 fields is greater than 5.
      AND (wmf.total_2019_2020 + wmf.endowment_total_2019_2020 ) >= 5

      # I took a look to see if there were many that needed deduping and
      # this list stood out as being intentionally invalid addresses.
      AND email NOT IN (
        'na@na.com',
        'name@domain.com',
        'no@gmail.com',
        'no@no.com',
        'noemail@gmail.com',
        'noemail@noemail.com',
        'noemail@yahoo.com',
        'none@none.com',
        'noneofyourbusiness@gmail.com',
        'nope@nope.com',
        'nothanks@gmail.com',
        'a@b.com'
      )
  ");

}

/**
 * Remove activities relating to deleted-by-merge contacts.
 *
 * See https://lab.civicrm.org/dev/core/-/issues/1644
 * for longer term plan.
 *
 * Also note we are not yet cleaning up log records but we
 * could revisit that. Generally I didn't clean up log records
 * when we deleted our contacts & thought that would be a later round (
 * maybe a policy could be 6 months later).
 *
 * Bug T245088
 */
function wmf_civicrm_update_8040() {
  civicrm_initialize();
  // 87
  $activityTypeID = CRM_Core_PseudoConstant::getKey('CRM_Activity_BAO_Activity', 'activity_type_id', 'Contact Deleted by Merge');
  // 3
  $recordTypeID = CRM_Core_PseudoConstant::getKey('CRM_Activity_BAO_ActivityContact', 'record_type_id', 'Activity Targets');
  $limit = 5000;
  while (CRM_Core_DAO::singleValueQuery(
"SELECT a.id FROM civicrm_activity a LEFT JOIN civicrm_activity_contact ac
       ON a.id = ac.activity_id AND record_type_id = $recordTypeID
       WHERE ac.id IS NULL AND activity_type_id =  $activityTypeID LIMIT 1")
  ) {
    // https://www.namasteui.com/mysql-group_concat-maximum-length/
    CRM_Core_DAO::executeQuery('SET SESSION group_concat_max_len = 10000000');
    $ids = CRM_Core_DAO::singleValueQuery("SELECT GROUP_CONCAT(id) FROM (SELECT a.id FROM civicrm_activity a LEFT JOIN civicrm_activity_contact ac
       ON a.id = ac.activity_id AND record_type_id = $recordTypeID
       WHERE ac.id IS NULL AND activity_type_id =  $activityTypeID LIMIT $limit) as q");
    CRM_Core_DAO::executeQuery("DELETE FROM civicrm_activity WHERE id IN ($ids)");
  }

}

/**
 * Change datetime fields to timestamps.
 *
 * Stop system status warnings and create greater congruity between timezones.
 *
 * Bug T248900
 */

function wmf_civicrm_update_8050() {
  civicrm_initialize();
  $fields = [
    ['table' => 'civicrm_job', 'name' =>'last_run', 'default' => 'NULL'],
    ['table' => 'civicrm_mailing_event_bounce', 'name' =>'time_stamp', 'default' => 'CURRENT_TIMESTAMP'],
    ['table' => 'civicrm_mailing_event_confirm', 'name' =>'time_stamp', 'default' => 'CURRENT_TIMESTAMP'],
    ['table' => 'civicrm_mailing_event_delivered', 'name' =>'time_stamp', 'default' => 'CURRENT_TIMESTAMP'],
    ['table' => 'civicrm_mailing_event_forward', 'name' =>'time_stamp', 'default' => 'CURRENT_TIMESTAMP'],
    ['table' => 'civicrm_mailing_event_opened', 'name' =>'time_stamp', 'default' => 'CURRENT_TIMESTAMP'],
    ['table' => 'civicrm_mailing_event_reply', 'name' =>'time_stamp', 'default' => 'CURRENT_TIMESTAMP'],
    ['table' => 'civicrm_mailing_event_subscribe', 'name' =>'time_stamp', 'default' => 'CURRENT_TIMESTAMP'],
    ['table' => 'civicrm_mailing_event_trackable_url_open', 'name' =>'time_stamp', 'default' => 'CURRENT_TIMESTAMP'],
    ['table' => 'civicrm_mailing_event_unsubscribe', 'name' =>'time_stamp', 'default' => 'CURRENT_TIMESTAMP'],
    ['table' => 'civicrm_mailing', 'name' =>'created_date', 'default' => 'NULL'],
    ['table' => 'civicrm_mailing', 'name' =>'scheduled_date', 'default' => 'NULL'],
    ['table' => 'civicrm_mailing', 'name' =>'approval_date', 'default' => 'NULL'],
    ['table' => 'civicrm_mailing_abtest', 'name' =>'created_date', 'default' => 'CURRENT_TIMESTAMP'],
    ['table' => 'civicrm_mailing_job', 'name' =>'scheduled_date', 'default' => 'NULL'],
    ['table' => 'civicrm_mailing_job', 'name' =>'start_date', 'default' => 'NULL'],
    ['table' => 'civicrm_mailing_job', 'name' =>'end_date', 'default' => 'NULL'],
    ['table' => 'civicrm_mailing_spool', 'name' =>'added_at', 'default' => 'NULL'],
    ['table' => 'civicrm_mailing_spool', 'name' =>'removed_at', 'default' => 'NULL'],
    ['table' => 'civicrm_subscription_history', 'name' =>'date', 'default' => 'CURRENT_TIMESTAMP']
  ];
  foreach ( $fields as $field ){
    $query = "ALTER TABLE {$field['table']} CHANGE {$field['name']} {$field['name']} TIMESTAMP NULL DEFAULT {$field['default']}";
    drush_print( "Converting field {$field['table']}.{$field['name']} to TIMESTAMP\n" );
    CRM_Core_DAO::executeQuery($query);
    drush_print( "Converted field {$field['table']}.{$field['name']} to TIMESTAMP\n" );
  }
}

/**
 * Update is_deceased to be required and =0.
 *
 * This is a core update. It's kinda slow so better to run at our convenience during the outage.
 *
 * In addition I identified 3 indexes that seemed clear cut to drop. Note doing them as separate drop statements
 * will avoid dev environment issues - but it might slow down the running.
 */
function wmf_civicrm_update_8055() {
  civicrm_initialize();
  CRM_Core_DAO::executeQuery('UPDATE civicrm_contact SET is_deceased = 0 WHERE is_deceased IS NULL');
  CRM_Core_DAO::executeQuery('
     ALTER TABLE civicrm_contact
     MODIFY COLUMN is_deceased TINYINT NOT NULL DEFAULT 0'
  );
  // This index is not described in the schema do would not exist on new installs (probably by omission
  // since it was added in an upgrade script, but it's also an index that is not really helpful
  // and each index takes hundreds of MB on the disk on these large tables (even absent any data to
  // index)
  CRM_Core_BAO_SchemaHandler::dropIndexIfExists('civicrm_contact', 'index_image_url');
  // These indexes are created when dedupe rules use 'length' as a match criteria. However, we tell people
  // never to do that as the queries bypass all indexes due to them using LENGTH() in the query.
  // These are relics of a bygone dedupe effort.
  CRM_Core_BAO_SchemaHandler::dropIndexIfExists('civicrm_contact', 'dedupe_index_last_name_7');
  CRM_Core_BAO_SchemaHandler::dropIndexIfExists('civicrm_contact', 'dedupe_index_household_name_5');
}

/**
 * Enable Matching Gifts extension.
 * Enable cividatatranslate.
 */
function wmf_civicrm_update_8060() {
  wmf_civicrm_reconcile_extensions();
}

/**
 * Add message Template for recurring failures
 *
 * @throws \API_Exception
 *
 * Bug: T230064
 */
function wmf_civicrm_update_8065() {
  civicrm_initialize();
  $subject = file_get_contents(__DIR__ . '/templates/recurring_failed_message.subject.txt');
  $msgText = file_get_contents(__DIR__ . '/templates/recurring_failed_message.text.txt');
  $htmlText = file_get_contents(__DIR__ . '/templates/recurring_failed_message.html.txt');

  \Civi\Api4\MessageTemplate::create()->setCheckPermissions(FALSE)->setValues([
    'msg_text' => $msgText,
    'msg_html' => $htmlText,
    'msg_subject' => $subject,
    'workflow_name' => 'recurring_failed_message',
  ])->execute();

}

/**
 * Edit message Template for recurring failures
 * Adds link to acoustic unsubscribe page
 *
 * @throws \API_Exception
 *
 * Bug: T256162
 */
function wmf_civicrm_update_8068() {
  civicrm_initialize();
  $htmlText = file_get_contents(__DIR__ . '/templates/recurring_failed_message.html.txt');

  \Civi\Api4\MessageTemplate::update()->setCheckPermissions(FALSE)->addWhere('workflow_name', '=', 'recurring_failed_message')->setValues([
    'msg_html' => $htmlText,
  ])->execute();

}

/**
 * Add index to civicrm_country.iso_code.
 *
 * To hone the silverpop queries we really want to join on this so we need an index.
 *
 * Bug: T253152
 */
function wmf_civicrm_update_8070() {
  civicrm_initialize();
  $tables = ['civicrm_country' => ['iso_code']];
  CRM_Core_BAO_SchemaHandler::createIndexes($tables);
}

/**
 * Drop foreign keys on acl cache tables.
 *
 * These tables are always empty on our site but they show up in locking queries when truncated.
 * I believe the foreign key means that the contact table gets involved in ways it would
 * not without the key.
 *
 * Bug: T258661
 */
function wmf_civicrm_update_8075() {
  civicrm_initialize();
  $constraintsToDrop = [
    'FK_civicrm_acl_cache_contact_id' => 'civicrm_acl_cache',
    'FK_civicrm_acl_contact_cache_contact_id' => 'civicrm_acl_contact_cache',
    'FK_civicrm_acl_contact_cache_user_id' => 'civicrm_acl_contact_cache',
  ];
  foreach ($constraintsToDrop as $key => $table) {
    $tableSQL = CRM_Core_DAO::executeQuery('SHOW CREATE TABLE ' . $table);
    $tableSQL->fetch();
    if (stripos($tableSQL->Create_Table, 'CONSTRAINT `' . $key) !== FALSE) {
      CRM_Core_DAO::executeQuery("ALTER TABLE $table DROP FOREIGN KEY $key");
    }
  }
}

/*
 * Edit message Template for recurring failures
 * Updates Ways to Give link with utm medium
 *
 * @throws \API_Exception
 *
 * Bug: T256184
 */
function wmf_civicrm_update_8080() {
  civicrm_initialize();
  $htmlText = file_get_contents(__DIR__ . '/templates/recurring_failed_message.html.txt');

  \Civi\Api4\MessageTemplate::update()->setCheckPermissions(FALSE)->addWhere('workflow_name', '=', 'recurring_failed_message')->setValues([
    'msg_html' => $htmlText,
  ])->execute();
}

/**
 * Add new translated message Templates for recurring failures
 * Japanese, Swedish, and French to start
 *
 * @throws \API_Exception
 *
 * Bug: T256184
 */
function wmf_civicrm_update_8081() {
  civicrm_initialize();
  // When I inserted Japanese on staging it failed as the charset was latin....
  CRM_Core_DAO::executeQuery('ALTER TABLE civicrm_strings CONVERT TO CHARACTER SET utf8');
  // Also utf8mb4_unicode_ci supports more characters... We have to be careful as you can't join
  // utf8mb4_unicode_ci columns onto utf8_unicode_ci fields without an index bypass
  // but the strings column can reasonably be expected to never be used in a join.
  CRM_Core_DAO::executeQuery("
    ALTER TABLE civicrm_strings MODIFY `string` longtext NOT NULL COMMENT 'Translated string', COLLATE utf8mb4_unicode_ci;
  ");
  $languages = ['ja', 'fr', 'sv'];
  foreach ($languages as $language) {
    wmf_civicrm_insert_failure_message_translation($language);
  }
}

/*
 * Reset next_sched_contribution date for ingenio recurrings with installments
 * Also set installments=0 and payment_status_id=5 (In Progress)
 *
 * @throws \API_Exception
 *
 * Bug: T264954
 */
function wmf_civicrm_update_8085() {
  civicrm_initialize();

  // From 9/2 to 9/20
  CRM_Core_DAO::executeQuery("
    UPDATE civicrm_contribution_recur
    SET installments=0, contribution_status_id=5, next_sched_contribution_date = DATE_ADD(modified_date, INTERVAL 1 MONTH)
    WHERE payment_processor_id = 5
    AND installments > 0
    AND next_sched_contribution_date IS NULL
    AND contribution_status_id = 1
    AND modified_date > '2020-09-02'
  ");

  // From 8/20 to 9/1
  CRM_Core_DAO::executeQuery("
    UPDATE civicrm_contribution_recur
    SET installments=0, contribution_status_id=5, next_sched_contribution_date = DATE_ADD(modified_date, INTERVAL 2 MONTH)
    WHERE payment_processor_id = 5
    AND installments > 0
    AND next_sched_contribution_date IS NULL
    AND contribution_status_id = 1
    AND modified_date < '2020-09-02'
  ");
}

/*
 * Fix the fixed next_sched_contribution date for ingenio recurrings that fall an hour to soon
 *
 * @throws \API_Exception
 *
 * Bug: T264954
 */
function wmf_civicrm_update_8090() {
  civicrm_initialize();

  CRM_Core_DAO::executeQuery("
    UPDATE civicrm_contribution_recur
    LEFT JOIN civicrm_contribution ON civicrm_contribution.contribution_recur_id = civicrm_contribution_recur.id
    SET next_sched_contribution_date = DATE_ADD(next_sched_contribution_date, INTERVAL 1 DAY)
    WHERE civicrm_contribution_recur.next_sched_contribution_date = '2020-11-03'
    AND civicrm_contribution.receive_date > '2020-10-10'
  ");
}

/**
 * Add civicrm_managed records for our wmf reports.
 *
 * We are converting them to being loaded through a mgd file.
 * However, since they already exist we need to add the mgd row on the prod
 * db - not required for dev dbs as the mgd will work when they don't already exist.
 *
 * This does not need to be transitioned to drupal code.
 *
 * @throws \API_Exception
 */
function wmf_civicrm_update_8095() {
  civicrm_initialize();
  OptionValue::delete(FALSE)->setWhere([
    ['option_group_id:name', '=', 'report_template'],
    ['name', '=', 'CRM_Report_Form_Contribute_Trends'],
  ])->execute();

  $reportsToKeep = OptionValue::get(FALSE)->setWhere([
    ['option_group_id:name', '=', 'report_template'],
    ['name', 'IN', ['CRM_Report_Form_Contribute_WmfLybunt', 'CRM_Report_Form_Contribute_GatewayReconciliation']],
   ])->setSelect(['id', 'name'])->execute();
  $nameMap = [
    'CRM_Report_Form_Contribute_GatewayReconciliation' => 'WMF gateway reconciliation report - used by Pats Pena',
    'CRM_Report_Form_Contribute_WmfLybunt' => 'WMF LYBUNT report (possibly dead)',
  ];
  foreach ($reportsToKeep as $report) {
    CRM_Core_DAO::executeQuery("
      INSERT INTO civicrm_managed (module, name, entity_type, entity_id)
      VALUES('wmf-civicrm', '{$nameMap[$report['name']]}', 'ReportTemplate', {$report['id']})
   ");
  }
}
