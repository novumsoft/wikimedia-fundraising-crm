<?php

require_once 'recurring.inc';
require_once 'tracking.inc';
require_once 'civicrm_api_check.inc';

/**
 * return a map of option value (id) => option name
 */
function civicrm_api_option_group($group_name, $key = null)
{
	static $cached_group = array();
	if (!array_key_exists($group_name, $cached_group))
	{
		$api = civicrm_api_classapi();
		$api->OptionValue->Get(array(
			'option_group_name' => $group_name,
		));
		$cached_group[$group_name] = array();
		$option_values = $api->values();
		foreach ($option_values as $row)
		{
			$cached_group[$group_name][$row->value] = $row->name;
		}
	}
	if ($key)
	{
		// In this case, just lookup name and return the option value
		$forwards = array_flip($cached_group[$group_name]);
		return $forwards[$key];
	}
	return $cached_group[$group_name];
}

function civicrm_option_group_id( $group_name ) {
    $api = civicrm_api_classapi();
    $success = $api->OptionGroup->Get(array(
        'name' => $group_name,
    ));
    if ( $success && $api->values ) {
        return $api->values[0]->id;
    }
}

function civicrm_api_contribution_status($key = null)
{
	return civicrm_api_option_group('contribution_status', $key);
}

function civicrm_api_classapi()
{
	civicrm_initialize();
	if (module_load_include('php', 'civicrm', '../api/class.api') === FALSE)
	{
		watchdog('civicrm_api', t('Failed to load civicrm api classes'), array(), WATCHDOG_ERROR);
	}
	else
	{
		return new civicrm_api3();
	}
}

/**
 * Determines the settlement currency for a given donation.
 * Argument is a queue message or a civicrm contribution array.
 */
function wmf_civicrm_get_settlement_currency($transaction)
{
	return 'USD';
}

/**
 * Given the date a payment was settled (in unix seconds), recalculate the
 * amount in USD using the exchange rate at that moment.  Put this amount in a
 * custom field.
 * Then, set the civi amounts and currencies to reflect the real settlement
 * currency and amount.
 *
 * Return the contribution array with these extra fields merged in.
 */
function wmf_civicrm_settle( $contribution, $settled_timestamp = null )
{
    if ( $settled_timestamp === null ) {
        // Get the stored date
        // FIXME wmf_civicrm_contribution_get_custom_values('settlement_date');
        $field = wmf_civicrm_get_custom_field_name( 'settlement_date' );
        $params = array(
            'entityID' => $contribution['id'],
            $field => 1
        );
        $result = CRM_Core_BAO_CustomValueTable::getValues( $params );
        $settlement_db_date = $result[$field];
        $settled_timestamp = strtotime( $settlement_db_date );
        $settlement_db_date = wmf_common_date_unix_to_sql( $settled_timestamp );
    } else {
        $settlement_db_date = wmf_common_date_unix_to_sql( $settled_timestamp );
    }

    list($original_currency, $original_amount) = explode(" ", $contribution['source']);
    $total_usd = round(exchange_rate_convert($original_currency, $original_amount, $settled_timestamp), 2);

    $custom_values = array(
        'total_usd' => $total_usd,
        'settlement_date' => $settlement_db_date,
    );
    wmf_civicrm_set_custom_field_values($contribution['id'], $custom_values);

    $settled_currency = wmf_civicrm_get_settlement_currency( $contribution );
    if ( $contribution['currency'] != $settled_currency ) {
        $settlement_convert =
            exchange_rate_convert( $settled_currency, 1, $settled_timestamp );
        $contribution['total_amount'] = round( $contribution['total_amount'] * $settlement_convert, 2 );
        $contribution['fee_amount'] = round( $contribution['fee_amount'] * $settlement_convert, 2 );
        $contribution['net_amount'] = round( $contribution['net_amount'] * $settlement_convert, 2 );

        $contribution['currency'] = $settled_currency;

        $contribution['version'] = 3; //WTF

        $contribution_result = civicrm_api( "Contribution", "Create", $contribution );
        if ( array_key_exists( 'is_error', $contribution_result ) && $contribution_result['is_error'] != 0 ) {
            throw new WmfException( "IMPORT_CONTRIB", "Couldn't update contribution with new settlement info. Original error: {$contribution_result['error_message']}. txn_id: {$contribution['trxn_id']}" );
        }
    }

    return array_merge( $contribution, $custom_values );
}

// FIXME all of these custom field helpers share flaws: they do not consider entity type, or custom group name
function wmf_civicrm_contribution_get_custom_values( $contribution_id, $names )
{
    $names = (array)$names;
    $params[ 'entityID' ] = $contribution_id;
    foreach ( $names as $name ) {
        $field = wmf_civicrm_get_custom_field_name( $name );
        $params[ $field ] = 1;
        $field_map[ $field ] = $name;
    }
    $result = CRM_Core_BAO_CustomValueTable::getValues( $params );
    foreach ( $result as $field => $value ) {
        if ( array_key_exists( $field, $field_map ) ) {
            $ret[ $field_map[ $field ] ] = $value;
        }
    }
    return $ret;
}

// FIXME: contribution_set_custom_values
function wmf_civicrm_set_custom_field_values($entity_id, $map)
{
    $params = array(
        'entityID' => $entity_id,
    );
    $custom_fields = wmf_civicrm_get_custom_field_map(array_keys($map));
    foreach ($map as $field_name => $value)
    {
        $params[$custom_fields[$field_name]] = $value;
    }
    $result = CRM_Core_BAO_CustomValueTable::setValues($params);
    if (!empty($result['is_error']))
    {
        throw new WmfException( 'CIVI_CONFIG',
            t( 'Failed to set custom values: id !id, error: !err', array( '!id' => $entity_id, '!err' => $result['error_message'] ) )
        );
    }
}

function wmf_civicrm_get_custom_field_map( $field_names, $group_name = null )
{
    static $custom_fields = array();
    foreach ($field_names as $name)
    {
        if (empty($custom_fields[$name]))
        {
            $id = CRM_Core_BAO_CustomField::getCustomFieldID( $name, $group_name );
            $custom_fields[$name] = "custom_{$id}";
        }
    }

    return $custom_fields;
}

function wmf_civicrm_get_custom_field_name( $field_name ) {
    $custom_fields = wmf_civicrm_get_custom_field_map( array( $field_name ) );
    return $custom_fields[ $field_name ];
}

/**
 * Try to import a transaction message into CiviCRM, otherwise
 * throw an exception.
 */
function wmf_civicrm_contribution_message_import( &$msg ) {
    $msg = wmf_civicrm_verify_message_and_stage($msg);

    // insert the contact information
    $contact = wmf_civicrm_message_contact_insert( $msg );

    // Insert the location record
    $location = wmf_civicrm_message_location_insert( $msg, $contact );

    // Insert the contribution record.
    $contribution = wmf_civicrm_message_contribution_insert( $msg, $contact );

    if ( isset( $msg[ 'recurring' ] ) && $msg[ 'recurring' ] == 1 ) {
        watchdog( 'queue2civicrm_import', 'Attempting to insert recurring record.'); //BLAH
        wmf_civicrm_message_contribution_recur_insert( $msg, $contact['id'], $contribution );
    }

    // Tag contact for review
    try {
        $tag = wmf_civicrm_tag_contact_for_review( $contact );
    } catch (WmfException $ex) {
        // XXX copying old logic, continues without a review tag
    }

    // Map the tracking record to the CiviCRM contribution
    // @FIXME what do we do if this returns false?  nothing at the moment...
    wmf_civicrm_message_update_contribution_tracking( $msg, $contribution );

    return $contribution;
}

/**
 * Insert the contribution record
 * 
 * Serves as a standard way for message processors to handle contribution
 * insertion.
 * 
 * @param array $msg
 * @param array $contact
 * @param integer $recur_id   See `civicrm_contribution`.`contribution_recur_id`
 * @param integer $effort_id  The effort id - the number of successful payments for recurring payments
 * @return array
 */
function wmf_civicrm_message_contribution_insert( $msg, $contact, $recur_id=NULL, $effort_id=NULL )
{
    civicrm_initialize();

    $transaction = WmfTransaction::from_message( $msg );
    $transaction->recur_sequence = $effort_id;
    $trxn_id = $transaction->get_unique_id();

    $msg['contribution_type'] = wmf_civicrm_get_message_contribution_type($msg);
    $contribution_type_id = wmf_civicrm_get_civi_id( 'contribution_type_id', $msg['contribution_type'] );

    //XXX always redundant?
    if ( !array_key_exists( "payment_instrument", $msg ) ){
        $msg['payment_instrument'] = wmf_civicrm_get_message_payment_instrument( $msg );
    }
    $payment_instrument_id = wmf_civicrm_get_civi_id( 'payment_instrument_id', $msg['payment_instrument'] );
    if ( !$payment_instrument_id )
    {
        throw new WmfException("INVALID_MESSAGE", "No payment type found for message." );
    }

    $contribution = array(
        'contact_id' => $contact[ 'id' ],
        'total_amount' => $msg['gross'],
        'contribution_type_id' => $contribution_type_id,
        'payment_instrument_id' => $payment_instrument_id,
        'fee_amount' => $msg['fee'],
        'net_amount' => $msg['net'],
        'trxn_id' => $trxn_id,
        'receive_date' => wmf_common_date_unix_to_civicrm( $msg['date'] ),
        'currency' => $msg['currency'],
        'source' => $msg['original_currency'] . ' ' . $msg['original_gross'],
        'contribution_recur_id' => $recur_id,
        'check_number' => $msg['check_number'],
        'letter_code' => $msg['letter_code'],

        // API required fields
        'version' => '3'
    );

    // Add the thank you date when it exists and is not null (e.g.: we're importing from a check)
    if ( array_key_exists( 'thankyou_date', $msg ) && is_numeric( $msg[ 'thankyou_date' ] ) ) {
        $contribution[ 'thankyou_date' ] = wmf_common_date_unix_to_civicrm( $msg['thankyou_date'] );
    }

    watchdog( 'wmf_civicrm', 'Contribution array for civicrm_contribution_add(): ' . print_r($contribution, TRUE), NULL, WATCHDOG_DEBUG);

    $contribution_result = civicrm_api( "Contribution", "Create", $contribution );
    
    watchdog( 'wmf_civicrm', 'Contribution result from civicrm_contribution_add(): ' . print_r($contribution_result, TRUE), NULL, WATCHDOG_DEBUG);
    
    if ( array_key_exists( 'is_error', $contribution_result ) && $contribution_result['is_error'] != 0 ) {
        throw new WmfException( 'INVALID_MESSAGE',
            t( 'Cannot create contribution: !error.', array( '!error' => $contribution_result['error_message'] ) )
        );
    }
  
    /**
    *  Apply custom field defaults.
    *
    *  Hopefully the Civi API will eventually handle custom fields in the
    *  above "Create" call.
    *
    * At the moment, all custom fields get default values for online contribution EXCEPT for 'Donor Comment'.
    *
    * NOTE: the custom field for "Gift_Information" indicates that check number is stored here.  It is not.
    */

    $comment = ( isset( $msg[ 'comment' ] ) ) ? $msg[ 'comment'] : '';
    $lettercode = ( $msg[ 'letter_code' ] ) ? $msg[ 'letter_code'] : NULL;
    $gateway_account = array_key_exists( 'gateway_account', $msg ) ? $msg[ 'gateway_account' ] : '';

    // n.b. Data field names are legacy, and do not necessarily match the labels.
    $custom_vars = array(
        'Contribution_Comments' => $comment,
        'Gift_Data' => $lettercode,
        'gateway_account' => $gateway_account,
    );
    if ( array_key_exists( 'gift_source', $msg ) ) {
        $custom_vars['Campaign'] = $msg['gift_source'];
    }
    if ( array_key_exists( 'direct_mail_appeal', $msg ) ) {
        $custom_vars['Appeal'] = $msg['direct_mail_appeal'];
    }
    if ( array_key_exists( 'restrictions', $msg ) ) {
        $custom_vars['Fund'] = $msg['restrictions'];
    }
    if ( array_key_exists( 'import_batch_number', $msg ) ) {
        $custom_vars['import_batch_number'] = $msg['import_batch_number'];
    }

    wmf_civicrm_set_custom_field_values( $contribution_result[ 'id' ], $custom_vars );

    return $contribution_result[ 'values' ][ $contribution_result[ 'id' ] ];
}

/**
 * @fixme TODO: make the v3 API calls use the wrapper function
 *
 * @param $type
 * @param $name
 * @return bool
 */
function wmf_civicrm_get_civi_id($type, $name)
{
    static $civi_ids = array();
    $params = array('name' => $name);
    $dummy = array();
    
    if(array_key_exists($type, $civi_ids) && array_key_exists($name, $civi_ids[$type])) {
        return $civi_ids[$type][$name];
    }

    switch ($type) {
        case 'contribution_type_id':
            //fixme: This is probably the upside-down way to do it. Really ought to go through the API.
            //
            $result = CRM_Contribute_BAO_ContributionType::retrieve($params, $dummy);
            if (!is_null($result)){
                $civi_ids[$type][$name] = $result->id;
                watchdog('wmf_civicrm', "Found id for contribution_type $name: " . $civi_ids[$type][$name]);
            } else {
                //make it. Or, throw an error here. Either way.
                //XXX nonono
                watchdog('wmf_civicrm', "Id for contribution_type $name not found. Creating...");
                $params['description'] = '';
                $params['accounting_code'] = strtoupper($name);
                $params['is_deductible'] = 1;
                $params['is_active'] = 1;
                $result = CRM_Contribute_BAO_ContributionType::add($params, $dummy);
                $civi_ids[$type][$name] = $result->id;
                watchdog('wmf_civicrm', "New id for contribution_type $name :" . $civi_ids[$type][$name]);
            }
            $id = $civi_ids[$type][$name];
            if (empty($id)) {
                throw new WmfException( "CIVI_CONFIG",
                    t( 'Contribution Type "!name" not found!', array( '!name' => $name ) )
                );
            }
            return $id;
        case 'payment_instrument_id':
            require_once 'api/v3/OptionValue.php';
            $group_id = civicrm_api3_option_value_get(
                array('option_group_name' => 'payment_instrument', 'label'=> $name, 'version' => '3'));
            if($group_id['count'] == 1){
                $civi_ids[$type][$name] = $group_id['values'][strval($group_id['id'])]['value'];
                watchdog('wmf_civicrm', "Found value for payment_instrument $name :" . $civi_ids[$type][$name]);
                return $civi_ids[$type][$name];
            } else {
                throw new WmfException("CIVI_CONFIG", t("Payment Instrument '!name' not found!", array("!name" => $name)));
            }
            break;
        case 'tag_id':
            require_once 'api/v3/Tag.php';
            $tag_id = civicrm_api3_tag_get(array('name'=> $name, 'version' => '3'));
            if (is_array($tag_id) && array_key_exists('id', $tag_id)){
                $civi_ids[$type][$name] = $tag_id['id'];
                watchdog('wmf_civicrm', "Found id for Entity Tag $name :" . $civi_ids[$type][$name]);
                return $civi_ids[$type][$name];
            } else {
                throw new WmfException("CIVI_CONFIG", t("Entity Tag '!name' not found!", array("!name" => $name)));
            }
        default:
            throw new WmfException("CIVI_CONFIG", t("Civi lookup for type '!type' not implemented", array("!type" => $type)));
    }
}

function wmf_civicrm_get_message_contribution_type( $msg ) {
	$gateway = strtolower( $msg['gateway'] );
    if ( $gateway === 'merkle' ) {
		return 'merkle';
	} elseif ( $gateway === 'arizonalockbox' ) {
        return 'Arizona Lockbox';
    } else {
		return 'cash';
	}
}

/**
 * Determines which civi-only payment instrument is appropriate for the current 
 * message, and resturns the civi payment instrument's human-readable display 
 * string (if it exists).   
 *
 * TODO lookup table
 */
function wmf_civicrm_get_message_payment_instrument( $msg )
{
    civicrm_initialize();

    $payment_instrument = null;
    
    if ( array_key_exists( 'payment_method', $msg ) && trim( $msg['payment_method'] ) != '' ){
    
        switch( strtolower( $msg[ 'payment_method' ] ) ){
            case 'check':
                $payment_instrument = 'Check';
                break;
            case 'bt':
                $payment_instrument = 'Bank Transfer';
                break;
            case 'cc':
                $payment_instrument = 'Credit Card';	
                switch ( strtolower( $msg['payment_submethod'] ) ){
                    case 'visa':
                        $payment_instrument .= ': Visa';
                        break;
                    case 'mc':
                        $payment_instrument .= ': MasterCard';
                        break;
                    case 'amex':
                        $payment_instrument .= ': American Express';
                        break;
                    case 'maestro':
                        $payment_instrument .= ': Maestro';
                        break;
                    case 'solo':
                        $payment_instrument .= ': Solo';
                        break;
                    case 'laser':
                        $payment_instrument .= ': Laser';
                        break;
                    case 'jcb':
                        $payment_instrument .= ': JCB';
                        break;
                    case 'discover':
                        $payment_instrument .= ': Discover';
                        break;
                    case 'cb':
                        $payment_instrument .= ': Carte Bleue';
                        break;
                }
                break;
            case 'dd':
                $payment_instrument = 'Direct Debit';
                break;
            case 'ew':
                switch( strtolower( $msg['payment_submethod'] ) ){
                    case 'ew_paypal':
                        $payment_instrument = 'Paypal';
                        break;
                    case 'ew_webmoney':
                        $payment_instrument = 'Webmoney';
                        break;
                    case 'ew_moneybookers':
                        $payment_instrument = 'Moneybookers';
                        break;
                    case 'ew_cashu':
                        $payment_instrument = 'Cashu';
                        break;
                    case 'ew_yandex':
                        $payment_instrument = 'Yandex';
                        break;
                }
                break;
            case 'obt':
                if ( strtolower( $msg['payment_submethod'] === 'bpay' ) ){
                    $payment_instrument = 'Bpay';
                }
                break;
            case 'rtbt':
                switch( strtolower( $msg['payment_submethod'] ) ){
                    case 'rtbt_nordea_sweden':
                        $payment_instrument = 'Nordea';
                        break;
                    case 'rtbt_ideal':
                        $payment_instrument = 'iDeal';
                        break;
                    case 'rtbt_enets':
                        $payment_instrument = 'Enets';
                        break;
                    case 'rtbt_sofortuberweisung':
                        $payment_instrument = 'Sofort';
                        break;
                    case 'rtbt_eps':
                        $payment_instrument = 'EPS';
                        break;
                }
                break;
            case 'cash':
                $payment_instrument = 'Cash';
                //'cash_boleto' - Only one right now. I assume there might be more later? 
                switch ( strtolower( $msg['payment_submethod'] ) ){
                    case 'cash_boleto': 
                        $payment_instrument = 'Boleto';
                        break;
                }
                break;	
            case 'payflowpro':
                if ( strtolower( $msg['gateway'] ) === 'payflowpro' ){
                    $payment_instrument = 'Credit Card';
                }
                break;
        }
        
    }
    if ( !$payment_instrument
            and array_key_exists( 'gateway', $msg )
    ) {
        switch ( strtolower( $msg['gateway'] ) ) {
        case 'amazon':
            $payment_instrument = 'Amazon';
            if ( array_key_exists( 'payment_method', $msg ) and strtolower( $msg['payment_method'] ) !== 'amazon' ) {
                watchdog( 'wmf_civicrm', 'payment_method constraint violated: gateway Amazon, but method=@method ; gateway_txn_id=@id', array( '@method' => $msg['payment_method'], '@id' => $msg['gateway_txn_id'] ), WATCHDOG_DEBUG );
            }
            break;
        case 'paypal':
            $payment_instrument = 'Paypal';
            if ( array_key_exists( 'payment_method', $msg ) and strtolower( $msg['payment_method'] ) !== 'paypal' ) {
                watchdog( 'wmf_civicrm', 'payment_method constraint violated: gateway Paypal, but method=@method ; gateway_txn_id=@id', array( '@method' => $msg['payment_method'], '@id' => $msg['gateway_txn_id'] ), WATCHDOG_DEBUG );
            }
            break;
        }
    }

    //I was going to check to make sure the target gateway was a real thing, but: Hello, overhead. No.
    return $payment_instrument;
}

/**
 * Normalize contribution amounts
 * 
 * Do exchange rate conversions and set appropriate fields for CiviCRM
 * based on information contained in the message.
 *
 * Upon exiting this function, the message is guaranteed to have these fields:
 *    currency - settlement currency
 *    original_currency - currency remitted by the donor
 *    gross - settled total amount
 *    original_gross - remitted amount in original currency
 *    fee - processor fees, when available
 *    net - gross less fees
 *
 * @param $msg
 * @return array
 */
function wmf_civicrm_normalize_contribution_amounts( $msg ) {

    if ( ( empty( $msg['gross'] ) or empty( $msg['currency'] ) )
        and ( empty( $msg['original_gross'] ) or empty( $msg['original_currency'] ) )
    ) {
        // just... don't
        return $msg;
    }

    if ( empty( $msg['original_gross'] ) ) {
        $msg['original_gross'] = $msg['gross'];
    }
    if ( empty( $msg['original_currency'] ) ) {
        $msg['original_currency'] = $msg['currency'];
    }

    if ( !array_key_exists('fee', $msg) && !array_key_exists('net', $msg) ) {
        $msg['fee'] = '0.00';
        $msg['net'] = $msg['gross'];
    } elseif ( !array_key_exists('fee', $msg) && array_key_exists('net', $msg) ) {
        $msg['fee'] = $msg['gross'] - $msg['net'];
    } elseif ( array_key_exists('fee', $msg) && !array_key_exists('net', $msg) ) {
        $msg['net'] = $msg['gross'] - $msg['fee'];
    }

    $settlement_currency = wmf_civicrm_get_settlement_currency($msg);
    try {
        $settlement_convert = exchange_rate_convert($msg['original_currency'], 1, $msg['date']) / exchange_rate_convert($settlement_currency, 1, $msg['date']);
    }
    catch (ExchangeRatesException $ex) {
        throw new WmfException( 'INVALID_MESSAGE', "UNKNOWN_CURRENCY: '{$msg['original_currency']}': " . $ex->getMessage() );
    }

    // round the amounts and do exchange rate conversion
    $msg['fee'] = round( $msg['fee'] * $settlement_convert, 2 );
    $msg['gross'] = round( $msg['gross'] * $settlement_convert, 2 );
    $msg['net'] = round( $msg['net'] * $settlement_convert, 2 );
    $msg['currency'] = $settlement_currency;

    return $msg;
}

function wmf_civicrm_verify_message_and_stage($msg)
{
    $msg = wmf_civicrm_normalize_msg( $msg );

    $required = array(
        'email',
        'gross',
        'currency',
        'gateway',
        'gateway_txn_id',
    );

    $err = array();
    foreach ($required as $key){
        if ( empty( $msg[$key] ) ) {
            $err[] = "Required Field '$key' not found in message.";
        }
    }

    if (floatval($msg['net']) <= 0 || floatval($msg['gross']) <= 0)
    {
        $err[] = "Positive amount required.";
    }

    if (!empty($err)) {
        throw new WmfException( 'CIVI_REQ_FIELD', $err );
    }

    $max_lengths = array(
        'check_number' => 255,
        'city' => 64,
        'email' => 254,
        'first_name' => 64,
        'last_name' => 64,
        'middle_name' => 64,
        'organization_name' => 128,
        'postal_code' => 64,
        'street_address' => 96,
        'supplemental_address_1' => 96,
        'supplemental_address_2' => 96,
    );
    foreach ( $max_lengths as $key => $limit ) {
        if ( strlen( $msg[$key] ) > $limit ) {
            throw new WmfException( 'INVALID_MESSAGE', "Field '{$key}' is too long." );
        }
    }

    //Now check to make sure this isn't going to be a duplicate message for this gateway.
    if ( wmf_civicrm_get_contributions_from_gateway_id( $msg['gateway'], $msg['gateway_txn_id'] ) ) {
        throw new WmfException( 'DUPLICATE_CONTRIBUTION', "Contribution already exists. Ignoring message." );
    }

    return $msg;
}

/**
 * Insert the contact record
 * 
 * Serves as a standard way for message processors to handle contact
 * insertion.  By passing a contact id, a contact can be updated.
 * 
 * @param array $msg
 * @param int $contact_id
 * @return array
 */
function wmf_civicrm_message_contact_insert( $msg, $contact_id=NULL ) {
    // Set defaults for optional fields in the message
    if ( !array_key_exists( 'contact_type', $msg ) ) {
        $msg['contact_type'] = "Individual";
    } elseif ( $msg['contact_type'] != "Individual" && $msg['contact_type'] != "Organization" ) {
        // looks like an unsupported type was sent, revert to default
        watchdog( 'wmf_civicrm', 'Non-supported contact_type received: %type', array( '%type' => print_r( $msg['contact_type'], true )), WATCHDOG_INFO );
        $msg['contact_type'] = "Individual";
    }

    if ( !array_key_exists( 'contact_source', $msg ) ) {
        $msg['contact_source'] = "online donation";
    }

    // Honor the opt-out checkbox, if present, else, set default
    if ( !array_key_exists( 'optout', $msg ) ) {
        $msg['optout'] = 0;
    }
  
    // Create the contact record
	$fname = substr( trim( $msg['first_name'] ), 0, 64 );
	$mname = substr( trim( $msg['middle_name'] ), 0, 64 );
	$lname = substr( trim( $msg['last_name'] ), 0, 64 );
    $contact = array(
        'id' => $contact_id,
        'contact_type' => $msg['contact_type'],
        'first_name' => $fname,
        'middle_name' => $mname,
        'last_name' => $lname,
        'sort_name' => substr( trim( $lname . ', ' . $fname, ' ,' ), 0, 128 ),
        'display_name' => substr( $fname . ' ' . $lname, 0, 128 ),
        'do_not_trade' => $msg['anonymous'],
        'is_opt_out' => '0', // $msg['optout'], // we don't offer an option to unsub on contrib, eliminate bugs
        'contact_source' => $msg['contact_source'],

        // API required fields
        'version' => '3'
    );
    if ( strtolower( $msg['contact_type'] ) == "organization" ){
        unset( $contact['first_name'] );
        unset( $contact['middle_name'] );
        unset( $contact['last_name'] );

        $contact['sort_name'] = $msg['organization_name'];
        $contact['display_name'] = $msg['organization_name'];
        $contact['organization_name'] = $msg['organization_name'];
    }
    if ( empty($msg['language']) ) {
        // guess from contribution_tracking data
        $tracking = wmf_civicrm_get_contribution_tracking( $msg );
        if ( $tracking and !empty($tracking['language']) ) {
            if ( strpos( $tracking['language'], '-' ) ) {
                // If we are already tracking variant, use that
                list( $language, $variant ) = explode( '-', $tracking['language'] );
                $contact['preferred_language'] = $language . '_' . strtoupper( $variant );
            } else {
                $contact['preferred_language'] = $tracking['language'];
                if ( !empty($tracking['country']) ) {
                    $contact['preferred_language'] .= '_' . $tracking['country'];
                }
            }
        } else {
            // FIXME: wish we had the contact_id here :(
            watchdog( 'wmf_civicrm', 'Failed to guess donor\'s preferred language, falling back to some hideous default', NULL, WATCHDOG_INFO );
        }
    } else {
        $contact['preferred_language'] = strtolower(substr($msg['language'], 0, 2));
        if ( !empty( $msg['country'] ) ) {
            $contact['preferred_language'] .= '_' . strtoupper(substr($msg['country'], 0, 2));
        }
    }

    // Attempt to insert the contact
    $contact_result = civicrm_api( "Contact", "Create", $contact );

    if ( $contact_id == NULL ){
        watchdog( 'wmf_civicrm', 'Result for adding contact: %contact', array( '%contact' => print_r( $contact_result, true )), WATCHDOG_DEBUG );
    } else {
        watchdog( 'wmf_civicrm', 'Result for updating contact: %contact', array( '%contact' => print_r( $contact_result, true )), WATCHDOG_DEBUG );
    }

    if ( array_key_exists( 'is_error', $contact_result ) && $contact_result['is_error'] != 0 ){
        throw new WmfException( "IMPORT_CONTACT", "Contact could not be added. Aborting import. Contact data was " . print_r($contact, true) . " Original error: " . $contact_result['error_message'] );
    }
    return $contact_result;
}

/**
 * Update the contact record
 * 
 * Serves as a standard way for message processors to handle contact
 * updates.
 * 
 * @param array $msg
 * @param int $contact_id
 * @return array
 */
function wmf_civicrm_message_contact_update( $msg, $contact_id )
{
    //FIXME: reverse the way these functions delegate.  Or eliminate -_insert.
    return wmf_civicrm_message_contact_insert( $msg, $contact_id );
}

/**
 * Insert the location record
 * 
 * Serves as a standard way for message processors to handle location
 * insertion.
 * 
 * @param array $msg
 * @param array $contact
 */
function wmf_civicrm_message_location_insert( $msg, $contact ) {
    wmf_civicrm_message_location_update( $msg, $contact );
}

/**
 * Update the location record
 * 
 * Serves as a standard way for message processors to handle location
 * updates.
 * 
 * @param array $msg
 * @param array $contact
 */
function wmf_civicrm_message_location_update( $msg, $contact ) {
    wmf_civicrm_message_email_update( $msg, $contact[ 'id' ] );
    wmf_civicrm_message_address_update( $msg, $contact[ 'id' ] );
}

function wmf_civicrm_message_email_update( $msg, $contact_id ) {
    // unset the email address if the default is used
    // this enables us to properly dedupe contacts later on
    if( empty( $msg['email'] ) or $msg[ 'email' ] === 'nobody@wikimedia.org' ){
        return;
    }

    $loc_type_id = wmf_civicrm_get_default_location_type_id();

    $email_params = array(
        'contact_id' => $contact_id,
        'email' => $msg[ 'email' ],
        'is_primary' => 1,
        'is_billing' => 1,
        'location_type_id' => $loc_type_id,
        'version' => 3,
    );

    $result = civicrm_api( "Email", "Create", $email_params );
    if ( array_key_exists( 'is_error', $result ) && $result['is_error'] != 0 ) {
        throw new WmfException( 'IMPORT_CONTACT', "Couldn't store email for the contact.", $result );
    }
}

function wmf_civicrm_message_address_update( $msg, $contact_id ) {
    $loc_type_id = wmf_civicrm_get_default_location_type_id();

    // We can do these lookups a bit more efficiently than Civi
    $country_id = wmf_civicrm_get_country_id( $msg[ 'country' ] );

    $address_params = array(
        'contact_id' => $contact_id,
        'location_type_id' => $loc_type_id,
        'is_primary' => 1,
        'street_address' => $msg['street_address'],
        'supplemental_address_1' => $msg['supplemental_address_1'],
        'city' => $msg['city'],
        'postal_code' => $msg['postal_code'],
        'country_id' => $country_id,
        'country' => $msg[ 'country' ],
        'is_billing' => 1,
        'version' => 3,
    );

    if ( !empty( $msg['state_province'] ) ) {
        $address_params['state_province'] = $msg['state_province'];
        $address_params['state_province_id'] = wmf_civicrm_get_state_id( $country_id, $msg['state_province'] );
    }

    // FIXME: api does not offer control over fixAddress flag
    //$result = civicrm_api( "Address", "Create", $address_params );
    //if ( array_key_exists( 'is_error', $result ) && $result['is_error'] != 0 ) {

    $result = CRM_Core_BAO_Address::add( $address_params, false );
    if ( !$result ) {
        throw new WmfException( 'IMPORT_CONTACT', "Couldn't store address for the contact.", $result );
    }
}

function wmf_civicrm_get_default_location_type_id() {
    $default_location_type = CRM_Core_BAO_LocationType::getDefault();
    return $default_location_type->id;
}

function wmf_civicrm_get_country_id( $raw ) {
	// ISO code, or outside chance this could be a lang_COUNTRY pair
	if ( preg_match( '/^([a-z]+_)?([A-Z]{2})$/', $raw, $matches ) ) {
		$code = $matches[2];

		$iso_cache = CRM_Core_PseudoConstant::countryIsoCode();
		$id = array_search( strtoupper( $code ), $iso_cache );
		if ( $id !== FALSE ) {
			return $id;
		}
	} else {
		$country_cache = CRM_Core_PseudoConstant::country( false, false );
		$id = array_search( $raw, $country_cache );
		if ( $id !== false ) {
			return $id;
		}
	}

	watchdog( 'wmf_civicrm',
		"Cannot find country: [%txt]",
		array( '%txt' => $raw ),
		WATCHDOG_NOTICE
	);
}

/**
 * Find correct state for insertion
 * 
 * When passing CiviCRM a state abbreviation, odd things can happen - like getting the right abbreviation, but the wrong state
 * So we'll pull back the correct state/province name based off of a user's country/state abbreviation
 */
function wmf_civicrm_get_state( $country, $state )
{
    if ( strlen( $country ) == 2 ) {
        $query = "SELECT s.name AS state_name FROM civicrm_country c, civicrm_state_province s WHERE s.country_id=c.id AND c.iso_code = :country AND s.abbreviation = :state";
    } else {
        $query = "SELECT s.name AS state_name FROM civicrm_country c, civicrm_state_province s WHERE s.country_id=c.id AND c.name = :country AND s.abbreviation = :state";
    }
    $dbs = wmf_civicrm_get_dbs();
    $dbs->push( 'civicrm' );
    $result = db_query( $query, array( ':country' => $country, ':state' => $state ) );
    if ( $result->rowCount() === 1 ){
        $state = $result->fetch()->state_name;
    }

    return $state;
}

function wmf_civicrm_get_state_id( $country_id, $state )
{
    $query = <<<EOS
SELECT id
FROM civicrm_state_province s
WHERE
    s.country_id = :country_id
    AND ( s.abbreviation = :state OR s.name = :state )
EOS;
    $dbs = wmf_civicrm_get_dbs();
    $dbs->push( 'civicrm' );
    $result = db_query( $query, array( ':country_id' => $country_id, ':state' => $state ) );
    if ( $result->rowCount() === 1 ){
        return $result->fetch()->id;
    }
    watchdog( 'wmf_civicrm',
        "Cannot find state: [%state] (country %country)",
        array( '%state' => $state, '%country' => $country_id ),
        WATCHDOG_NOTICE
    );
}



/**
 * Normalize the queued message
 * 
 * Decodes the message and updates some of the message fields in ways 
 * that are consistent with how we need to insert data into CiviCRM.
 * This should be useful by other modules processing contribution messages 
 * out of the queue.
 * 
 * @param mixed $msg
 * @return array
 */
function wmf_civicrm_normalize_msg( $msg ) {
    // Decode the message body.
    if ( !is_array( $msg ) ) {
        $msg = json_decode( $msg->body, true );
    }

    //defaults: Keys that aren't actually required, but which will cause some portion of the code to complain
    //if they don't exist (even if they're blank).
    // FIXME: don't use defaults.  Access msg properties using a functional interface.
    $defaults = array(
        'date' => time(), //defaulting to now. @fixme: if you can think of a better thing to do in the name of historical exchange rates.
        'first_name' => '',
        'middle_name' => '',
        'last_name' => '',
        'organization_name' => '',
        'email' => '',
        'street_address' => '',
        'supplemental_address_1' => '',
        'supplemental_address_2' => '',
        'city' => '',
        'country' => '',
        'state_province' => '',
        'postal_code' => '',
        'check_number' => null,
        'letter_code' => null,
        'thankyou_date' => null,
        'recurring' => null,
        'utm_campaign' => null,
    );
    $msg = $msg + $defaults;
    
    //handle the payment instrument without altering the original message
    //(just in case any downstream logic needs to switch on the raw data)
    $msg['payment_instrument'] = wmf_civicrm_get_message_payment_instrument( $msg );

    // if we're missing a contrib id, insert new record to the table
    // this can happen if a user somehow makes a trxn from outside the normal workflow
    // checks are ignored as they were completely offline
    if ( !isset( $msg[ 'contribution_tracking_id' ] ) ) {
        if ( array_key_exists( 'payment_method', $msg ) && strtoupper( $msg['payment_method'] ) != "CHECK" ) {

            watchdog( 'wmf_civicrm', 'Contribution missing contribution_tracking_id', array(), WATCHDOG_DEBUG );
            //@fixme: For the regular transactions, this has been moved to the staging function. This needs to happen in recurring also, and then it can be removed here.
            $anonymous = ( array_key_exists( 'anonymous', $msg) && $msg['anonymous'] == true && strtoupper( $msg['anonymous'] ) != "FALSE" ) ? 1 : 0;
            $optout = ( array_key_exists( 'optout', $msg ) && $msg['optout'] == true && strtoupper( $msg['optout'] ) != "FALSE" ) ? 1 : 0;

            $contribution_tracking_id = wmf_civicrm_insert_contribution_tracking( '..' . $msg['payment_method'], 'civicrm', wmf_common_date_unix_to_sql( $msg['date'] ), null, $optout, $anonymous ); //ACK! this should not be handled this way! should be dynamic!
            watchdog( 'wmf_civicrm', 'Newly inserted contribution tracking id: @id', array( '@id' => $contribution_tracking_id ), WATCHDOG_DEBUG );
            $msg['contribution_tracking_id'] = $contribution_tracking_id;
        }
    }

    // Convert times to Unix timestamps.
    if ( !is_numeric( $msg['date'] ) ) {
        $msg['date'] = strtotime($msg['date']);
    }
    // if all else fails, fall back to now.
    if ( empty( $msg['date'] ) ) {
        $msg['date'] = time();
    }

    if ( $msg['recurring'] and !isset( $msg['start_date'] ) ) {
        $msg['start_date'] = $msg['date'];
        $msg['create_date'] = $msg['date'];
    }

    if ( !empty( $msg['thankyou_date'] ) ) {
        if ( !is_numeric( $msg['thankyou_date'] ) ) {
            $unix_time = strtotime( $msg['thankyou_date'] );
            if ( $unix_time !== false ) {
                $msg['thankyou_date'] = $unix_time;
            } else {
                watchdog( 'wmf_civicrm', 'Could not parse thankyou date: @date from @id', array( '@date' => $msg['thankyou_date'], '@id' => $msg['contribution_tracking_id'] ), WATCHDOG_DEBUG );
                unset( $msg['thankyou_date'] );
            }
        }
    }

    if ( empty( $msg['first_name'] ) and empty( $msg['last_name'] ) ) {
        $msg['first_name'] = 'Chester';
        $msg['last_name'] = 'McDefault';
    }

    // Check for special flags
    if ( !empty( $msg['utm_campaign'] ) ) {
        switch ( $msg['utm_campaign'] ) {
        case 'NY2013':
            //TODO: expose direct_mail_appeal custom field in the UI
            $msg['direct_mail_appeal'] = "New York Event 2013";
            break;
        case 'NYCShaku2013':
            $msg['direct_mail_appeal'] = "Shaku - NYC Event 2013";
            break;
        case 'SF2013':
            $msg['direct_mail_appeal'] = "San Francisco Event 2013";
            break;
        case 'Mossman':
            $msg['direct_mail_appeal'] = "Sheila Mossman";
            break;
        default:
                // pass
            break;
        }
    }

    $msg['anonymous'] = ((!empty( $msg['anonymous'] ) && strtoupper($msg['anonymous'] ) !== "FALSE") ? 1 : 0);
    $msg['optout'] = ((empty( $msg['optout'] ) || $msg['optout'] === 0 || $msg['optout'] === '0' || strtoupper( $msg['optout'] ) === "FALSE") ? 0 : 1);

    // set the correct amount fields/data and do exchange rate conversions.
    $msg = wmf_civicrm_normalize_contribution_amounts( $msg );

    watchdog( 'wmf_civicrm', 'Contribution (normalized):<pre>' . check_plain(print_r($msg, TRUE)) . '</pre>', NULL, WATCHDOG_INFO );

    return $msg;
}

/**
 * Insert the tag record
 * 
 * Serves as a standard way for message processors to handle tag
 * insertion.
 * 
 * @param array $contact
 * @return array
 */
function wmf_civicrm_tag_contact_for_review( $contact )
{
    require_once 'api/v2/EntityTag.php';

    $review_tag_id = wmf_civicrm_get_civi_id('tag_id', 'Review');

    $tag = array(
        'tag_id' => $review_tag_id,
        'contact_id' => $contact[ 'id' ]
    );
    $tag_result = civicrm_entity_tag_add( $tag );
    return $tag_result;
}

/**
 * Pulls all records in the wmf_contribution_extras table that match the gateway
 * and gateway transaction id.
 * @param string $gateway
 * @param string $gateway_txn_id
 * @return mixed array of result rows, or false if none present.
 * @throws WmfException
 */
function wmf_civicrm_get_contributions_from_gateway_id( $gateway, $gateway_txn_id ){
	$gateway = strtolower( $gateway );
	$query = "SELECT cx.*, cc.* FROM wmf_contribution_extra cx LEFT JOIN civicrm_contribution cc 
		ON cc.id = cx.entity_id 
		WHERE gateway = %1 AND gateway_txn_id = %2";

    $dao = CRM_Core_DAO::executeQuery( $query, array(
        1 => array( $gateway, 'String' ),
        2 => array( $gateway_txn_id, 'String' ),
    ) );
	return wmf_civicrm_dao_to_list( $dao );
}

function wmf_civicrm_get_child_contributions_from_gateway_id( $gateway, $gateway_txn_id ){
	$gateway = strtolower( $gateway );
	$query = "SELECT cx.*, cc.* FROM wmf_contribution_extra cxp 
		INNER JOIN wmf_contribution_extra cx ON cxp.entity_id = cx.parent_contribution_id 
		LEFT JOIN civicrm_contribution cc ON cc.id = cx.entity_id 
		WHERE cxp.gateway = %1 AND cxp.gateway_txn_id = %2";

    $dao = CRM_Core_DAO::executeQuery( $query, array(
        1 => array( $gateway, 'String' ),
        2 => array( $gateway_txn_id, 'String' ),
    ) );
	return wmf_civicrm_dao_to_list( $dao );
}


function wmf_civicrm_boost_performance() {
    civicrm_initialize();
    $config = CRM_Core_Config::singleton();
    $config->doNotResetCache = 1;
}

function wmf_civicrm_set_thankyou_date_to_epoch( $contribution_id ){
    $api = civicrm_api_classapi();
    $result = $api->Contribution->Create( array(
        'id' => $contribution_id,
        'thankyou_date' => '1970-01-01 00:00:00',
        'version' => 3,
    ) );

	if ( !$result ) {
		watchdog('thank_you', 'Updating TY date to epoch failed: ' . $api->errorMsg(), array(), WATCHDOG_ERROR);
		return false;
	} else {
		watchdog('thank_you', 'TY date set to epoch sucessfully', array(), WATCHDOG_INFO);
		return true;
	}
}

/**
 * Sets the civi records to reflect a contribution refund.
 *
 * The original contribution is set to status "Refunded", and a negative and
 * equal refund contribution is created.  This contribution will be linked
 * to the original through the parent_contribution_id field, and will have
 * status "Pending" unless the $refund_completed argument is true.
 *
 * $refund_type should be 'refund' or 'chargeback', for now we simply dump
 * this string into the "source" field of the negative contribution.
 *
 * If $original_amount and $original_currency are provided, they will be
 * checked against the original contribution and an exception thrown on a
 * mismatch.  If the original amount has been zeroed we reconstruct the
 * contribution using the currency and amount from function parameters.
 *
 * returns the refund contribution id.
 */
function wmf_civicrm_mark_refund(
    $contribution_id,
    $refund_type = 'refund',
    $refund_completed = false,
    $refund_date = null,
    $refund_gateway_txn_id = null,
    $original_currency = null,
    $original_amount = null
) {
    $api = civicrm_api_classapi();

    $success = $api->Contribution->Get( array(
        'id' => $contribution_id,
        'version' => 3,
    ) );
    if ( !$success ) {
        throw new WmfException( 'INVALID_MESSAGE', "Could not load contribution: $contribution_id, " . $api->errorMsg() );
    } elseif ( !$api->values() ) {
        throw new WmfException( 'INVALID_MESSAGE', "No such contribution: $contribution_id" );
    }
    $result = $api->values;
    $contribution = array_pop($result);

    // Look for existing refunds
    $query = "
SELECT id FROM wmf_contribution_extra
WHERE
    parent_contribution_id = %1";

    $dao = CRM_Core_DAO::executeQuery( $query, array(
        1 => array( $contribution_id, 'Integer' ),
    ) );
    if ( $dao->fetch() ) {
        throw new WmfException( 'DUPLICATE_CONTRIBUTION', "Contribution is already refunded: $contribution_id" );
    }

    // Look for existing refunds
    $query = "
SELECT id FROM wmf_contribution_extra
WHERE
    entity_id = %1 AND COALESCE(parent_contribution_id, 0)";

    $dao = CRM_Core_DAO::executeQuery( $query, array(
        1 => array( $contribution_id, 'Integer' ),
    ) );
    if ( $dao->fetch() ) {
        throw new WmfException( 'INVALID_MESSAGE', "Contribution to refund is itself a refund: $contribution_id" );
    }

    // Should we restore?
    if ( (floatval( $contribution->total_amount ) == 0
            or $contribution->contribution_source === "RFD")
        and $original_currency and $original_amount > 0
    ) {
        //FIXME!: call this from the contribution save hook. $round parameter. 
        $contribution->total_amount = round( exchange_rate_convert(
            $original_currency, $original_amount,
            strtotime( $contribution->receive_date )
        ), 2 );

        $api->Contribution->Create( array(
            'id' => $contribution_id,

            'source' => "{$original_currency} {$original_amount}",
            'total_amount' => $contribution->total_amount,

            'version' => 3,
        ) );
    } else {
        list($actual_currency, $actual_amount) = explode(" ", $contribution->contribution_source);
        if ( ($original_currency && round($original_currency, 2) != round($actual_currency, 2))
            || ($original_amount && round($original_amount, 2) != round($actual_amount, 2)) )
        {
            throw new WmfException( 'INVALID_MESSAGE', "Payment amount specified did not match original contribution: $contribution_id" );
        }

        $original_currency = $actual_currency;
        $original_amount = $actual_amount;
    }

    $transaction = WmfTransaction::from_unique_id( $contribution->trxn_id );
    if ( $refund_gateway_txn_id ) {
        $transaction->gateway_txn_id = $refund_gateway_txn_id;
    }
    $transaction->is_refund = true;
    $refund_unique_id = $transaction->get_unique_id();

    # FIXME: remove debug line,
    watchdog( 'wmf_civicrm', "Refund date: " . var_export( $refund_date, true ), NULL, WATCHDOG_INFO );

    if ( $refund_date === null ) {
        $refund_date = time();
    } elseif ( !is_numeric( $refund_date ) ) {
        $refund_date = strtotime( $refund_date );
    }

    $refund_status = ( $refund_completed ? 'Completed' : 'Pending' );
    $refund_params = array(
        'contact_id' => $contribution->contact_id,
        'total_amount' => 0 - $contribution->total_amount,
        'contribution_type_id' => wmf_civicrm_get_civi_id( 'contribution_type_id', $refund_type ),
        'receive_date' => gmdate( 'Y-m-d H:i:s', $refund_date ),
        'contribution_status_id' => civicrm_api_contribution_status( $refund_status ),
        'contribution_source' => "$original_currency -{$original_amount}",
        'thankyou_date' => '1970-01-01 00:00:00',
        'trxn_id' => $refund_unique_id,

        // API required fields
        'version' => '3'
    );
    if ( !$api->Contribution->Create($refund_params) ) {
        throw new WmfException( 'IMPORT_CONTRIB', "Failed to create refund contribution for: $contribution_id, " . $api->errorMsg() );
    }
    $result = $api->values;
    $refund = array_pop($result);

    $parent_custom_values = wmf_civicrm_contribution_get_custom_values( $contribution_id, array(
        'gateway_account',
    ) );

    $custom_values = array(
        'gateway_account' => $parent_custom_values['gateway_account'],
        'parent_contribution_id' => $contribution->id,
        'finance_only' => 1,
    );
    wmf_civicrm_set_custom_field_values($refund->id, $custom_values);

    $custom_values = array(
        'finance_only' => 1,
    );
    wmf_civicrm_set_custom_field_values($contribution->id, $custom_values);

    $update_params = array(
        'id' => $contribution->id,
        'contribution_status_id' => civicrm_api_contribution_status( 'Refunded' ),

        'version' => 3,
    );
    if ( !$api->Contribution->Create($update_params) ) {
        throw new WmfException( 'IMPORT_CONTRIB', "Cannot mark original contribution as refunded: $contribution_id, " . db_error() );
    }

    return $refund->id;
}

/**
 * Update civi records to track gateway status change events.
 *
 * If more recent information is in the database, ignore the event
 * unless it is a Refund.
 *
 * For refund events, mark the refund using our helper function.
 *
 * Raw gateway status is stored in a custom field.
 */
function wmf_civicrm_set_gateway_status( int $contribution_id, string $raw_status, string $normalized_status = null, int $timestamp = null )
{
    civicrm_initialize();

    if ( $normalized_status !== null ) {
        $contribution = new CRM_Contribute_BAO_Contribution();
        $contribution->id = $contribution_id;
        if ( !$contribution->find( true ) ) {
            throw new WmfException( 'INVALID_MESSAGE', "Contribution not found: $contribution_id" );
        }

        $status_id = civicrm_api_contribution_status( $normalized_status );
        if ( $status_id === null ) {
            watchdog('wmf_civicrm', "Normalized status does not exist: {$normalized_status}", array(), WATCHDOG_ERROR);
        }
    }

    // this is sort of audit-specific logic
    if ( $normalized_status === 'Refunded' ) {
        // We restore the old status id in case this refund action was less recent
        // than current info in the db.  If the data conditional below succeeds, we
        // set the status to 'refunded' again.
        $old_status_id = $contribution->contribution_status_id;
        try {
            wmf_civicrm_mark_refund( $contribution_id, 'chargeback', true );
        } catch ( WmfException $e ) {
            watchdog('wmf_civicrm', "Cannot create a refund for: {$contribution_id}", array(), WATCHDOG_ERROR);
        }
        $contribution->find( true );
        $contribution->contribution_status_id = $old_status_id;
        $contribution->save();
    }

    if ( $timestamp === null ) {
        $gateway_date = gmdate( 'YmdHis' );
    } else {
        $gateway_date = gmdate( 'YmdHis', $timestamp );
    }

    $original_custom_values = wmf_civicrm_contribution_get_custom_values( $contribution_id, array(
        'gateway_date',
    ) );
    $last_timestamp = strtotime( $original_custom_values['gateway_date'] );
    $last_gateway_date = wmf_common_date_unix_to_sql( $last_timestamp );

    if ( $last_gateway_date >= $gateway_date ) {
        watchdog('wmf_civicrm', "Not updating contribution, because a more recent gateway status change has been recorded: {$contribution_id}", array(), WATCHDOG_INFO);
        return;
    }

    $custom_values['gateway_date'] = $gateway_date;
    $custom_values['gateway_status_raw'] = $raw_status;
    wmf_civicrm_set_custom_field_values($contribution_id, $custom_values);

    if ( $normalized_status !== null ) {
        $contribution->contribution_status_id = $status_id;
    }
    $contribution->save();
}

/**
 * Dedupe helper.
 */
function wmf_civicrm_merge_contacts( $main_contact_id, $other_contact_id ) {
    $api = civicrm_api_classapi();

    $cidRefs = CRM_Dedupe_Merger::cidRefs();
    $eidRefs = CRM_Dedupe_Merger::eidRefs();
    $moveTables = array_merge( array_keys( $cidRefs ), array_keys( $eidRefs ) );

    CRM_Dedupe_Merger::moveContactBelongings( $main_contact_id, $other_contact_id, $moveTables );

    $api->Contact->delete( array(
        'contact_id' => $other_contact_id,
        'version' => 3
    ) );
}

/**
 * Implementation of hook_civicrm_merge, adds our custom tables.
 */
function wmf_civicrm_civicrm_merge( $type, &$refs ) {
    switch ( $type ) {
    case 'cidRefs':
        $contact_types = array( "Contact" );
        $contact_types = array_merge( CRM_Contact_BAO_ContactType::basicTypes(), $contact_types );
        foreach ( $contact_types as &$type ) {
            $type = "'" . $type . "'";
        }
        $contact_types = implode( ", ", $contact_types );

        $sql = <<<EOS
SELECT table_name
FROM civicrm_custom_group
WHERE extends IN ( $contact_types )
EOS;
        $dao = CRM_Core_DAO::executeQuery( $sql );
        while ( $dao->fetch() ) {
            $refs[ $dao->table_name ][] = 'entity_id';
        }
        break;
    }
}

/**
 * Implementation of hook_civicrm_post, used to update contribution_extra fields
 */
function wmf_civicrm_civicrm_post( $op, $type, $id, &$contribution ) {
    switch ( $op ) {
    case 'create':
    case 'edit':
        if ( $type === 'Contribution' ) {
            $extra = array();

            if ( $contribution->trxn_id ) {
                try {
                    $transaction = WmfTransaction::from_unique_id( $contribution->trxn_id );
                    $extra['gateway'] = strtolower( $transaction->gateway );
                    $extra['gateway_txn_id'] = $transaction->gateway_txn_id;
                } catch ( WmfException $ex ) {
                    watchdog( 'wmf_civicrm', "Failed to parse trxn_id: {$contribution->trxn_id}, " . $ex->getMessage() );
                }
            }

            if ( $contribution->source ) {
                list( $original_currency, $original_amount ) = explode( " ", $contribution->source );
                $extra['original_currency'] = $original_currency;
                $extra['original_amount'] = $original_amount;
            }

            if ( $extra ) {
                wmf_civicrm_set_custom_field_values( $id, $extra );
            }
        }
        break;
    }
}

/**
 * Implementation of hook_civicrm_contactListQuery, this is short-circuiting
 * the normal quicksearch to workaround bad queries which take several minutes...
 * filesort...  This should be fixed upstream in this issue:
 *    http://issues.civicrm.org/jira/browse/CRM-12326
 */
function wmf_civicrm_civicrm_contactListQuery( &$query, $name, $context, $id ) {
	$query = <<<EOS
SELECT DISTINCT(id), data, sort_name, email
FROM
(
    (
        SELECT
            civicrm_contact.id,
            CONCAT_WS( ' :: ', sort_name, email ) AS data,
            sort_name,
            email
        FROM civicrm_contact
        LEFT JOIN civicrm_email
			ON ( civicrm_email.contact_id = civicrm_contact.id AND civicrm_email.is_primary = 1 )
        WHERE
            civicrm_contact.sort_name LIKE '{$name}%'
            AND civicrm_contact.is_deleted = 0
    ) UNION (
        SELECT
            civicrm_contact.id,
            CONCAT_WS( ' :: ', sort_name, email ) AS data,
            sort_name,
            email
        FROM civicrm_email
        JOIN civicrm_contact
            ON civicrm_email.contact_id = civicrm_contact.id
        WHERE
            civicrm_email.email LIKE '{$name}%'
            AND civicrm_contact.is_deleted = 0
            AND civicrm_email.is_primary = 1
    )
) AS t
LIMIT 0, 10
EOS;
}

/**
 * Get a grip on multiple database connections.
 *
 * @return db_switcher
 */
function wmf_civicrm_get_dbs() {
    return new db_switcher();
}

function wmf_civicrm_dao_to_list( $dao ) {
    $result = array();
    while ( $dao->fetch() ) {
        $result[] = $dao->toArray();
    }
    return $result;
}

/**
 * Implements hook_civicrm_validate
 *
 * FIXME: temporary request, revert when RLewis no longer needs it
 */
function wmf_civicrm_civicrm_validate( $formName, &$fields, &$files, &$form ) {
    $errors = array();

    switch ( $formName ) {
    case 'CRM_Contribute_Form_Contribution':
        $date = strptime( $fields['receive_date'], "%m/%d/%Y" );
        $azl_type_id = wmf_civicrm_get_civi_id( 'contribution_type_id', "Arizona Lockbox" );
        $custom_field_name = wmf_civicrm_evil_get_custom_field_in_form( 'postmark_date', $fields );
        if ( !$custom_field_name ) {
            return;
        }

        if (
            // The receive_date is in Dec, 2013
            $date['tm_year'] === (2013 - 1900) and $date['tm_mon'] == (12 - 1)
            // And it came in through the Arizona Lockbox check imports
            and $fields['contribution_type_id'] === $azl_type_id
        ) {
            // And the postmark date is missing
            if ( !$fields[$custom_field_name] ) {
                $errors[$custom_field_name] = t("You forgot the postmark date!");
            }
        }
        break;
    }

    return ( empty($errors) ? true : $errors );
}

/**
 * @param string $name custom field name
 * @param array $fields k/v fields as they are passed to CiviCRM form hooks
 *
 * @return string evil mangled name, like "custom_21_123332"
 */
function wmf_civicrm_evil_get_custom_field_in_form( $name, $fields ) {
    $custom_field_stump = wmf_civicrm_get_custom_field_name( $name ) . '_';
    foreach ( $fields as $key => $value ) {
        if ( 0 === strpos( $key, $custom_field_stump ) ) {
            return $key;
        }
    }
    watchdog( 'wmf_civicrm', 'Form is missing your precious custom field.', NULL, WATCHDOG_ERROR );
    return null;
}
