<?php
// include common functions
require_once( drupal_get_path( 'module', 'recurring_globalcollect' ) . '/recurring_globalcollect_common.inc' );

/**
 * Implementation of hook_menu().
 */
function recurring_globalcollect_menu() {
  $items = array();
  
  $items['admin/config/recurring_globalcollect'] = array(
    'title' => 'Recurring GlobalCollect Processor',
    'access arguments' => array('administer recurring_globalcollect'),
    'file' => 'system.admin.inc',
    'file path' => drupal_get_path('module', 'system'),
    'access arguments' => array('administer contribution_audit'),
  );

  $items['admin/config/recurring_globalcollect/configure'] = array(
    'title' => 'Configure',
    'access arguments' => array('administer recurring_globalcollect'),
    'description' => 'Configure message queue interface.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('recurring_globalcollect_settings'),
  );

  $items['admin/config/recurring_globalcollect/search'] = array(
    'title' => 'Search',
    'access arguments' => array('administer recurring_globalcollect'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('recurring_globalcollect_search_by_order_id_form'),
  );

  $items['admin/config/recurring_globalcollect/test'] = array(
    'title' => 'Test',
    'access arguments' => array('administer recurring_globalcollect'),
    'page callback' => 'recurring_globalcollect_test',
  );

  return $items;
}

function recurring_globalcollect_test() {

  $return = 'No testing available at this time.';
  return $return;
}

/**
 * Implementation of hook_permission().
 */
function recurring_globalcollect_permission() {
  return array(
    'administer recurring_globalcollect' => array(
      'title' => t('Administer Recurring GlobalCollect'),
    ),
  );
}

/**
 * Callback for menu path "admin/config/recurring_globalcollect".
 */
function recurring_globalcollect_settings() {
  $form = array();

  $defaultTestUrl = buildDefaultTestUrl();
  
  $form[ 'recurring_globalcollect' ][ 'globalcollect_url' ] = array(
    '#maxlength' => 255,
    '#type' => 'textfield',
    '#title' => t('Global Collect Url'),
    '#required' => FALSE,
    '#default_value' => variable_get('globalcollect_url', $defaultTestUrl),
    '#description' => t( 'The url to the Global Collect Gateway.' ),
  );

  $form['recurring_globalcollect_merchant_id'] = array(
    '#type' => 'textfield',
    '#title' => t('Global Collect Merchant ID'),
    '#required' => FALSE,
    '#default_value' => variable_get('recurring_globalcollect_merchant_id', 0),
  );

  $form['recurring_globalcollect_failure_retry_rate'] = array(
    '#type' => 'textfield',
    '#title' => t('Failure retry rate'),
    '#required' => TRUE,
    '#default_value' => variable_get('recurring_globalcollect_failure_retry_rate', 1),
    '#description' => t('Enter the number of days to wait until retrying.'),
  );

  $form['recurring_globalcollect_failures_before_cancellation'] = array(
    '#type' => 'textfield',
    '#title' => t('Failures before subscription is cancelled'),
    '#required' => TRUE,
    '#default_value' => variable_get('recurring_globalcollect_failures_before_cancellation', 3),
    '#description' => t('Enter the number of attempts to wait until the subscription is cancelled..'),
  );

  $form['recurring_globalcollect_run_missed_days'] = array(
    '#type' => 'textfield',
    '#title' => t('Catch up missed days'),
    '#required' => TRUE,
    '#default_value' => variable_get('recurring_globalcollect_run_missed_days', 3),
    '#description' => t('Enter the number of days in the past to start batching payments that were missed in the past X days.'),
  );

  $form['recurring_globalcollect_batch_max'] = array(
    '#type' => 'textfield',
    '#title' => t('Maximum number of payments to batch'),
    '#required' => TRUE,
    '#default_value' => variable_get('recurring_globalcollect_batch_max', 100),
    '#description' => t('The maximum batch size cannot be overridden from drush.'),
  );

  $form['recurring_globalcollect_batch'] = array(
    '#type' => 'select',
    '#title' => t('Number of payments to process in the cron job. If set to 0, the cron job will do nothing.'),
    '#required' => TRUE,
    '#default_value' => variable_get('recurring_globalcollect_batch', 0),
    '#description' => t('This may be overridden with: `drush rg --batch=10`'),
    '#options' => array(
      0 => 0,
      1 => 1,
      5 => 5,
      10 => 10,
      20 => 20,
      30 => 30,
      40 => 40,
      50 => 50,
      75 => 75,
      100 => 100,
    ),
  );
  
  return system_settings_form($form);
}

/**
 * recurring_globalcollect_batch_process
 *
 * This is the entry function for this module.
 *
 * This function is invoked here: drush_recurring_globalcollect() 
 * @see drush_recurring_globalcollect() 
 *
 * Validation is performed here: drush_recurring_globalcollect_validate()
 * @see drush_recurring_globalcollect_validate()
 *
 * @param array $options 
 * - $options['batch'] The number of contributions to process. If empty or not set or zero, no contributions will be processed.
 * - $options['date'] @uses strtotime()
 * - $options['url'] Used for testing and overriding the url
 */
function recurring_globalcollect_batch_process($options = array()) {

  // The number of contributions to process
  if ( array_key_exists( 'batch', $options ) ) {
    $batch = intval( $options['batch'] );
  } else {
    $batch = intval( variable_get('recurring_globalcollect_batch', 0) );
  }

  $run_missed_days = (integer) variable_get('recurring_globalcollect_run_missed_days', 0);
  
  watchdog('recurring_globalcollect', 'Attempting to process up to ' . $batch . ' recurring contribution(s).');

  $contribution_batch = wmf_civicrm_get_next_sched_contribution($batch, 'now', $run_missed_days);
  watchdog(
    'recurring_globalcollect',
    'Query returned @count messages to process',
    array('@count' => count($contribution_batch))
  );
  $result = recurring_globalcollect_batch_charge($contribution_batch, $options);

  $processed = count($result['succeeded']) + count($result['failed']);
  if ($processed > 0) {
    $message = "Processed $processed contribution(s).";
    if ( $result['failed'] ) {
        $message .= " Encountered ".count($result['failed'])." failures.";
    }
    watchdog('recurring_globalcollect', $message);
  }
  else {
    watchdog('recurring_globalcollect', 'No contributions processed.');
  }

  // Process retries
  watchdog('recurring_globalcollect', 'Attempting to retry up to ' . $batch . ' previously failed contribution(s).');
  $retry_batch = recurring_globalcollect_get_failure_retry_batch($batch, 'now', $run_missed_days);
  watchdog(
    'recurring_globalcollect',
    'Query returned @count messages to process',
    array('@count' => count($contribution_batch))
  );
  $result = recurring_globalcollect_batch_charge($retry_batch, $options);

  $processed = count($result['succeeded']) + count($result['failed']);
  if ($processed > 0) {
    $message = "Retried $processed contribution(s).";
    if ( $result['failed'] ) {
        $message .= " Encountered ".count($result['failed'])." failures.";
    }
    watchdog('recurring_globalcollect', $message);
  } else {
    watchdog('recurring_globalcollect', 'No retries processed.');
  }
}

/**
 * Remove one item from the queue and process it.
 *
 * @param  array  $options
 *
 * $options:
 * - string  $date The date to process.
 *
 * You are not allowed to process future dates. This generates an error
 *
 * $options['date'] @uses strtotime()
 *
 * The default date to process is today.
 *
 * The default process is next_sched_contribution.
 *
 * If you pick an incorrect process, an error will be generated.
 *
 * @uses recurring_globalcollect_process_error()
 * @uses recurring_globalcollect_process_validate_options()
 *
 * @return  boolean  Returns false on error. Returns true if contributions were processed. Returns false if no contributions are ready to be processed.
 */
function recurring_globalcollect_batch_charge($contribution_batch, $options = array())
{
  $succeeded = array();
  $failed = array();
  foreach ($contribution_batch as $contribution_recur)
  {
      try {
          recurring_globalcollect_charge($contribution_recur->id, $options);
          $succeeded[] = $contribution_recur;
      }
      catch ( WmfException $e )
      {
          $failed[] = $contribution_recur;
          if ( !$e->isNoEmail() ) {
              wmf_common_failmail( 'recurring_globalcollect', $e, $contribution_recur );
          }
          if ( $e->isFatal() ) {
              break;
          }
      }
      catch (Exception $e) {
          $message = 'Batch processing aborted: ' . $e->getMessage();
          $e = new WmfException( 'UNKNOWN', $message, $contribution_recur);
          $failed[] = $contribution_recur;
          break;
      }
  }

  return array(
      'succeeded' => $succeeded,
      'failed' => $failed,
  );
}

/**
 * Connect to GlobalCollect and process recurring charge
 *
 * @param int $contribution_recur_id
 * @param array $options Accepts the following optional keys:
 *      contribution_tags - array of tags to associate with the contribution
 *
 * @throws WmfException if the payment fails or any other error occurs.
 */
function recurring_globalcollect_charge( $contribution_recur_id, $options = array() ){
  watchdog( 'recurring_globalcollect', "Processing recurring charge: {$contribution_recur_id}" );

  $gotLock = _recurring_globalcollect_update_record_in_progress($contribution_recur_id);
  if ( !$gotLock ) {
    $message = t('Failed to mark record as in progress');
    throw new WmfException( 'CIVI_CONFIG', $message );
  }

  $subscription = recurring_globalcollect_get_payment_by_id( $contribution_recur_id );
  $transaction = WmfTransaction::from_unique_id( $subscription->trxn_id );
  $contribution_tracking_id = recurring_get_contribution_tracking_id( array(
	'txn_type' => 'subscr_payment',
	'subscr_id' => $subscription->trxn_id,
	'payment_date' => strtotime( "now" ),
  ) );
  $values = array(
      'amount' => $subscription->amount,
      'effort_id' => $subscription->processor_id + 1,
      'order_id' => $transaction->gateway_txn_id,
      'currency_code' => $subscription->currency,
      'payment_product' => '',
      'language' => 'en',
      'contribution_tracking_id' => $contribution_tracking_id,
      // Avoiding some more code.
      'referrer' => 'dummy',
  );
  $adapter = DonationInterface::createAdapter( 'GlobalCollect', $values );

  // FIXME hack.  This is getting overriden by sad.
  $adapter->addRequestData( array(
      'effort_id' => $subscription->processor_id + 1,
  ) );

  $transactionResponse = $adapter->do_transaction( 'Recurring_Charge' );
  $result = PaymentResult::fromResults(
    $transactionResponse,
    $adapter->getFinalStatus()
  );

  if ( $result->isFailed() || $result->getErrors() ) {
    _recurring_globalcollect_update_record_failure($contribution_recur_id);
    throw new WmfException( 'PAYMENT_FAILED', 'recurring charge failed', $result);
  }

  // If success, add a record to the contribution table and send a thank you email.
  // Mark this donation as successful, and reschedule it for next month
  // This is done before anything else, otherwise any errors that occur while storing the contribution
  // record in civi might cause this subscription to end up in a weird state and not recur correctly.
  // If storing the donation in civi fails, that's not a big deal, we'll get the data eventually
  // by reconciling the data we get from the payment processor.
  _recurring_globalcollect_update_record_success( $contribution_recur_id );

  $msg = recurring_globalcollect_create_message( $contribution_recur_id );

  wmf_civicrm_contribution_message_import( $msg );
}

/**
 * Create and return a message which is a payment on the given subscription
 *
 * @param int $contribution_recur_id Civi subscription record ID
 *
 * @return array queue message for a new payment
 */
function recurring_globalcollect_create_message( $contribution_recur_id ) {
    $contribution_recur = (array)recurring_globalcollect_get_payment_by_id( $contribution_recur_id );
    $initial_contribution = wmf_civicrm_get_initial_recurring_contribution( $contribution_recur_id );
    if ( !$initial_contribution ) {
        throw new WmfException( 'INVALID_RECURRING', "No initial contribution for this subscription" );
    }

    try {
        $transaction = WmfTransaction::from_unique_id( $contribution_recur['trxn_id'] );
    } catch ( Exception $ex ) {
        throw new WmfException( 'INVALID_RECURRING', $ex->getMessage(), $contribution_recur );
    }

    $msg = array(
    // Copy stuff from the subscription, and increment the EFFORTID
        'amount' => $contribution_recur['amount'],
        'contact_id' => $contribution_recur['contact_id'],
        'effort_id' => $contribution_recur['processor_id'],
        'order_id' => $transaction->gateway_txn_id,
        'currency_code' => $contribution_recur['currency'],
        'payment_product' => '',
        'financial_type_id' => $initial_contribution['financial_type_id'],
        // Setting both until we are sure contribution_type_id is not being used anywhere.
        'contribution_type_id' => $initial_contribution['financial_type_id'],

        'payment_instrument_id' => $initial_contribution['payment_instrument_id'],

        'gateway' => 'globalcollect',
        'gross' => $contribution_recur['amount'],
        'currency' => $contribution_recur['currency'],
        'gateway_txn_id' => $transaction->gateway_txn_id . '-' . $contribution_recur['processor_id'],
        'payment_method' => 'cc',
        'payment_submethod' => '',
        'date' => time(),

        'contribution_tags' => isset( $options['contribution_tags'] ) ? $options['contribution_tags'] : array(),

        'contribution_recur_id' => $contribution_recur['id'],
        'recurring' => true,

        //FIXME: ignored cos we already have a contact
        'email' => 'nobody@wikimedia.org',
    );

    wmf_common_set_message_source( $msg, 'direct', 'Recurring GlobalCollect' );

    return $msg;
}

/**
 * Create the form to search for subscriptions by order id.
 * TODO: deprecate
 */ 
function recurring_globalcollect_search_by_order_id_form() {

  $form['submit'] = array(
    '#value' => 'Search by order id',
    '#type' => 'submit'
  );
  
  $form['order_id'] = array(
    '#type' => 'textfield',
    '#title' => 'Order id',
    '#default_value' => '',
    '#required' => TRUE
  );
  
  return $form;
}

/** 
 * Implementation of hook_form_submit
 *
 * Submits a form to search for subscriptions by order id.
 */
function recurring_globalcollect_search_by_order_id_form_submit($form, &$form_state) {
  
  $order_id = isset( $form_state['values']['order_id'] ) ? (integer) $form_state['values']['order_id'] : 0;
  
  $record = _recurring_globalcollect_get_subscription_by_order_id($order_id);
  
  if ( $record === false ) {
  
    $message = 'No results found.';
    
  } else {
    $display_name = isset( $record['display_name'] ) ? $record['display_name'] : 'Unknown donor';
    $trxn_id = isset( $record['trxn_id'] ) ? $record['trxn_id'] : '';
    $cid = isset( $record['contact_id'] ) ? $record['contact_id'] : '';
    
    // Create a link to the recurring contribution for the donor.
    $link = '<a href="?q=civicrm/contact/view&reset=1&selectedChild=contribute&cid=' . urlencode($cid) . '#Contributions">' . htmlspecialchars($display_name) . '</a>';
    $message = 'Found the contact [' . $link . '] for the order id [ ' . $order_id . ' ] and with the transaction id [ ' . htmlspecialchars($trxn_id) . ' ]';
  }
  
  drupal_set_message($message);
}
