<?php 

define( 'CONTRIBUTION_AUDIT_WR1_PARSER_DIR', '/usr/local/src/Wr1Parser/' );
define( 'CONTRIBUTION_AUDIT_WR1_FILES_DIR', '/usr/local/src/Wr1_files/' );
define( 'CONTRIBUTION_AUDIT_LOG_FILES_DIR', '/usr/local/src/logs/' );
define( 'CONTRIBUTION_AUDIT_PLUSMINUS', 7 );
define( 'CONTRIBUTION_AUDIT_TEST_MODE', true );
define( 'CONTRIBUTION_AUDIT_FAKE_DB', false );
define( 'GC_AUDIT_MAKE_FNAME', 'John' );
define( 'GC_AUDIT_MAKE_LNAME', 'Doe' );
define( 'GC_AUDIT_MAKE_EMAIL', 'nobody@wikimedia.org' );
define( 'GC_AUDIT_MAKE_STREET', '123 Fake Street' );
define( 'GC_AUDIT_MAKE_CITY', 'Springfield' );

/**
 * Implementation of hook_menu()
 */
function globalcollect_audit_menu() {
  $items = array();
  
  $items['admin/config/contribution_audit/globalcollect_audit'] = array(
    'title' => 'Globalcollect Audit',
    'description' => t('Configure globalcollect audit settings.'),
    'access arguments' => array('administer contribution_audit'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array( 'globalcollect_audit_settings' ),
  );
  
  return $items;
}

/**
 * Callback for menu
 */
function globalcollect_audit_settings() {
  $form['globalcollect_audit_wr1_parser_dir']  = array(
    '#type' => 'textfield',
    '#title' => t( 'Path to directory containing WR1 parser classes' ),
    '#required' => TRUE,
    '#default_value' => variable_get( 'globalcollect_audit_wr1_parser_dir', CONTRIBUTION_AUDIT_WR1_PARSER_DIR ),
  );
  $form['globalcollect_audit_wr1_files_dir']  = array(
    '#type' => 'textfield',
    '#title' => t( 'Path to directory containing WR1 files' ),
    '#required' => TRUE,
    '#default_value' => variable_get( 'globalcollect_audit_wr1_files_dir', CONTRIBUTION_AUDIT_WR1_FILES_DIR ),
  );
  $form['globalcollect_audit_log_files_dir']  = array(
    '#type' => 'textfield',
    '#title' => t( 'Path to directory containing WMF GlobalCollect log files' ),
    '#required' => TRUE,
    '#default_value' => variable_get( 'globalcollect_audit_log_files_dir', CONTRIBUTION_AUDIT_LOG_FILES_DIR ),
  );
  $form['globalcollect_audit_log_files_dir_secondary']  = array(
    '#type' => 'textfield',
    '#title' => t( 'Alternate path to directory containing WMF GlobalCollect log files' ),
    '#required' => TRUE,
    '#default_value' => variable_get( 'globalcollect_audit_log_files_dir_secondary', CONTRIBUTION_AUDIT_LOG_FILES_DIR ),
  );
  $form['globalcollect_audit_test_mode']  = array(
    '#type' => 'checkbox',
    '#title' => t( 'When this box is checked, no stomp messages will be sent.' ),
    '#required' => TRUE,
    '#default_value' => variable_get( 'globalcollect_audit_test_mode', CONTRIBUTION_AUDIT_TEST_MODE ),
  );
  $form['globalcollect_audit_plusminus']  = array(
    '#type' => 'textfield',
    '#title' => t( 'Plus or minus search (in days)' ),
    '#required' => TRUE,
    '#default_value' => variable_get( 'globalcollect_audit_plusminus', CONTRIBUTION_AUDIT_PLUSMINUS ),
  );
  $form['globalcollect_audit_make_fname']  = array(
    '#type' => 'textfield',
    '#title' => t( 'Missing Transactions: First Name' ),
    '#required' => TRUE,
    '#default_value' => variable_get( 'globalcollect_audit_make_fname', GC_AUDIT_MAKE_FNAME ),
  );
  $form['globalcollect_audit_make_lname']  = array(
    '#type' => 'textfield',
    '#title' => t( 'Missing Transactions: Last Name' ),
    '#required' => TRUE,
    '#default_value' => variable_get( 'globalcollect_audit_make_lname', GC_AUDIT_MAKE_LNAME ),
  );
  $form['globalcollect_audit_make_email']  = array(
    '#type' => 'textfield',
    '#title' => t( 'Missing Transactions: Email' ),
    '#required' => TRUE,
    '#default_value' => variable_get( 'globalcollect_audit_make_email', GC_AUDIT_MAKE_EMAIL ),
  );
  $form['globalcollect_audit_make_street']  = array(
    '#type' => 'textfield',
    '#title' => t( 'Missing Transactions: Street' ),
    '#required' => TRUE,
    '#default_value' => variable_get( 'globalcollect_audit_make_street', GC_AUDIT_MAKE_STREET ),
  );
  $form['globalcollect_audit_make_city']  = array(
    '#type' => 'textfield',
    '#title' => t( 'Missing Transactions: City' ),
    '#required' => TRUE,
    '#default_value' => variable_get( 'globalcollect_audit_make_city', GC_AUDIT_MAKE_CITY ),
  );
  return system_settings_form( $form );
}


/**
 * Find Globalcollect transactions not recorded in civicrm_contribution
 */
function globalcollect_audit_find_missing_gc_trxns( $transactions ) {
	$missing_trxns = array( );

	$dbs = wmf_civicrm_get_dbs();

	// check for matching ids - if it doesnt match, it's missing
	globalcollect_audit_echo( "Checking for missing transactions" );
	foreach ( array_keys( $transactions ) as $order_id ) {
		$error = false;
		$found = false;
		if ( wr1_is_negative_txn( $transactions[$order_id] ) ) {
			//look for this transaction's positive counterpart before we go 
			//looking for the refund, becuase we need the whole civi transaction ID.
			//Remember to regrind the order_id, though. At this point, it's got a negative in front of it. 
			$matches = wmf_civicrm_get_contributions_from_gateway_id( 'globalcollect', wr1_order_id( $transactions[$order_id] ) );
			if ( !$matches ) {
				globalcollect_audit_log_error( "Could not find parent (or any related) transaction for refund/chargeback " . wr1_order_id( $transactions[$order_id] ) . print_r( $transactions[$order_id], true ) , 'MISSING_PARENT' );
				$error = true;
			} else {
				//Make sure the match we have is a base transaction. 
				$parent = null;
				foreach ( $matches as $index => $match ) {
					if ( trim( $match['parent_contribution_id'] ) === '' ) {
						if ( !is_null( $parent ) ) {
							globalcollect_audit_log_error( "Too many parents for refund/chargeback $order_id", 'PARENT_OVERFLOW' );
							$error = true;
						} else {
							$parent = $match;
							$copy_fields = array(
								'entity_id', //for the parent!
								'contribution_type_id',
								'payment_instrument_id',
								'gateway_account',
							);
							foreach ( $copy_fields as $field ){
								$transactions[$order_id][$field] = trim( $match[$field] );
							}
						}
					}
				}
				
				if ( !$error && is_null( $parent ) ){
					globalcollect_audit_log_error( "Could not find parent transaction for refund/chargeback " . wr1_order_id( $transactions[$order_id] ) . print_r( $transactions[$order_id], true ), 'MISSING_PARENT' );
					$error = true;
				}
				
				if ( !$error && !is_null( $parent['contribution_recur_id'] ) ){
					//this is a recurring transaction, and we're not cool enough to handle that yet. Defer to later.
					globalcollect_audit_log_error( "Not cool enough to handle recurring refunds/chargebacks yet for " . wr1_order_id( $transactions[$order_id] ) . print_r( $transactions[$order_id], true ), 'RECURRING_CBK' );
					$error = true; //well, not really an "error", per se, but we do want to ignore this for now.
				}

				$matches = wmf_civicrm_get_child_contributions_from_gateway_id( 'globalcollect', wr1_order_id( $transactions[$order_id] ) );
				if ( !$error && is_array( $matches ) && count( $matches ) ) {
					$im_a = wmf_civicrm_get_civi_id( 'contribution_type_id', wr1_get_negative_type( $transactions[$order_id] ) );
					foreach ( $matches as $match ) {
						//None of these are themselves parents. 
						//check to make sure they're not the same type of thing we are.
						if ( $im_a === $match['contribution_type_id'] ) {
							$found = true; //already went there.
						} else {
							globalcollect_audit_log_error( "Refund/Chargeback Collision on order id " . wr1_order_id( $transactions[$order_id] ), 'CBK+RFD' );
							$error = true;
							//TODO: Seems like some kind of alert should happen 
							//here if there's a sibling transaction, but at this
							//point in time for all we know, this is totally normal...
						}
					}
				}
			}
		} elseif ( wmf_civicrm_get_contributions_from_gateway_id( "globalcollect", $order_id ) ) {
			$found = true;
		}
		
		if ( $found && !$error ){
			globalcollect_audit_echo( '.' );
			watchdog( 'globalcollect_audit', 'Found Globalcollect: @id', array( '@id' => $order_id ), WATCHDOG_DEBUG );
		}
		if ( $error && !$found ){
			globalcollect_audit_echo( 'X' );
			//the exact thing that happened should already have been logged up the page a bit.
		}
		if ( !$found && !$error ) {
			globalcollect_audit_echo( '!' );
			$missing_trxns[$order_id] = $transactions[$order_id];
			watchdog( 'globalcollect_audit', 'Missing Globalcollect: @tx_id @pm, @pc', array(
				"@tx_id" => $order_id,
				"@pm" => $transactions[$order_id]['Payment-method'],
				"@pc" => wr1_currency( $transactions[$order_id] ) ), WATCHDOG_DEBUG );
		}
		if ( $found && $error ){
			globalcollect_audit_echo( 'Hit the programmer with a rolled-up newspaper. This shouldn\'t be possible.' );
			die();
		}
	}

	globalcollect_audit_echo( count( $missing_trxns ) . " missing records from a possible " . count( $transactions ) . " total records found." );
	return $missing_trxns;
}

/**
 * So, that happened. My bad. 
 * I'm keeping this function around, because it can currently be used (in only 
 * one very specific way, inspired to track one incident, but we may need to 
 * very rapidly expand on this in the future) to track fuckups.
 * Nothing is referencing this function: You'd only use it in a realtime 
 * emergency, and then in a very live-hackey kind of way. 
 * 
 * Once again: NOTHING COMMITTED SHOULD EVER REFERENCE THIS FUNCTION.
 * 
 * The particular fuckup this was written to track, was how many transactions 
 * were added to civi as "recurring", when the server XML used to create the
 * transaction (contained in the log files) clearly said that was never the case.
 */
function globalcollect_audit_track_fuckup(){
	$directory = '/home/khorn/recurring_extra/';
	$csv = $directory . 'recurring.csv';
	$testme = file($csv, FILE_SKIP_EMPTY_LINES);
	$ids = array();
	foreach( $testme as $line ){
		$temp = explode(',', $line);
		$ids[$temp[0]][] = $temp[1];
	}
	globalcollect_audit_echo( print_r($ids, true) );
	
	$processed_id_count = 0;
	$found_ids_count = 0;
	$recurring_count = 0;
	$not_recurring_count = 0;
	$unfound = array();
	
	
	foreach ( $ids as $date => $id_array ){
		$logname = $directory . $date . '_iop.log';
		$logname2 = $directory . wmf_common_date_add_days( $date, 1 ) . '_iop.log';
		foreach ( $id_array as $grepforme ){
			globalcollect_audit_echo('.');
			$processed_id_count += 1;
			$cmd = "grep <ORDERID>" . trim($grepforme) . "</ORDERID> $logname";

			globalcollect_audit_echo( __FUNCTION__ . ' ' . $cmd, true );
			$ret = array();
			exec( escapeshellcmd($cmd), $ret, $errorlevel );
			//echo $cmd . "\n";
			
			if ( !count( $ret ) ){
				$cmd = "grep <ORDERID>" . trim($grepforme) . "</ORDERID> $logname2";

				globalcollect_audit_echo( __FUNCTION__ . ' ' . $cmd, true );
				$ret = array();
				exec( escapeshellcmd($cmd), $ret, $errorlevel );
			}
	
			if ( count( $ret ) > 0 ){
				$found_ids_count += 1;
				if ( strstr( $ret[0], "<ORDERTYPE>4" ) ){
					$recurring_count += 1;
				} else {
					$not_recurring_count += 1;
				}
			} else {
				$unfound[$date][] = trim($grepforme);
			}
		}
		
	}
	
	globalcollect_audit_echo("Processed $processed_id_count");
	globalcollect_audit_echo("Found $found_ids_count");
	globalcollect_audit_echo("Unfound ids: " . print_r( $unfound, true ));
	globalcollect_audit_echo("Recurring Count $recurring_count");
	globalcollect_audit_echo("Not Recurring Count $not_recurring_count");
	die();
	
}


function globalcollect_audit_parse_all_wr1(){
	civicrm_initialize();

	//output data about the current user if we're running verbose
	globalcollect_audit_echo( print_r( posix_getpwuid( posix_getuid() ), true ), true );

	$actual_start_time = microtime(true);
	$test_mode = variable_get( 'globalcollect_audit_test_mode', CONTRIBUTION_AUDIT_TEST_MODE );
	
	$wr1_files = globalcollect_audit_get_all_wr1_files();
	
	$missing = array();
	$errorful_transactions = array();
	
	$missing = globalcollect_audit_find_more_missing($wr1_files);
	if ( !$missing ){
		globalcollect_audit_echo("No missing transactions found. Done!");
		return;
	}
	
	$counts = array();
	
	//Here is the place where we should take care of all the negatives.
	$missing = globalcollect_audit_mark_rfd_cbk( $missing );
	
	while ( count( $missing ) && globalcollect_audit_can_continue() ) {
		$local_found_ids = array();
		$log = globalcollect_audit_get_next_log( $missing, $counts );
		if ( is_null( $log ) ){
			continue;
		}

		globalcollect_audit_echo("Trying log $log");
		$tried_count = 0;
		foreach ( $missing as $order_id => $data ){
			++$tried_count;
			$date = wr1_date( $data );
			if ( is_null($date) ){
				globalcollect_audit_echo('X');
				continue;
			}
			$logdata = globalcollect_audit_get_log_data_by_order_id( $order_id, $log );
			if ( is_null( $logdata ) ){
				globalcollect_audit_echo('X');
				continue;
			}
			if ($logdata === false){
				globalcollect_audit_echo('.');;
				continue;
			}

			//This isn't going to work unless you're connecting to a database that has the row you're looking for. 
			$missing_txn_message = globalcollect_audit_format_data_for_stomp( $data, $logdata['donor_data'], $logdata['contribution_id'] );
			if ( is_null( $missing_txn_message ) ){
				//log this out in a list of troubled transactions. 
				$info = array(
					'contribution_id' => $logdata['contribution_id'],
					'log' => $log,
					'data' => $data,
					'logdata' => $logdata,
				);
				$errorful_transactions[] = $info;
				globalcollect_audit_echo('X');
				continue;
			}

			if ( $test_mode ){
				$local_found_ids[] = $order_id;
				globalcollect_audit_echo('!');
			} else {
				if ( globalcollect_audit_send_stomp( 'donations', $missing_txn_message ) ){
					watchdog('globalcollect_audit', __FUNCTION__ . ': Message sent to stomp successfully: ' . print_r( $missing_txn_message, true ), array(), WATCHDOG_INFO);
					$local_found_ids[] = $order_id;
					globalcollect_audit_echo('!');
				} else {
					$wd_message = __FUNCTION__ . ': Sending message to stomp failed: ' . print_r( $missing_txn_message, true );
					$drush_message = "Failed sending STOMP message to queue.";
					globalcollect_audit_log_error( $wd_message, "STOMP_BAD_SEND", $drush_message );
					return;
				}
			}

		}
		globalcollect_audit_echo("\n");
		
		//Output here, and add these stats to the data ball. 
		$logdate = globalcollect_audit_get_log_date_by_file($log);
		$counts[$logdate] = count( $local_found_ids );
		globalcollect_audit_echo($counts[$logdate] . " records found in $log");
		if ( $counts[$logdate] > 0 ){ //stop the log noise...
			globalcollect_audit_results_ball( array('Transactions Found', $log), $counts[$logdate] );
		}
		
		//now, we unset the array keys we found, so as not to corrupt the foreach we were in.
		foreach ($local_found_ids as $id) {
			unset($missing[$id]);
		}
		
	}
	//And loop. 
		
	//if we're running in make_missing mode, do that.
	$make_missing = variable_get( 'globalcollect_audit_make_missing', false );
	if ( $make_missing && count( $missing ) ){
		//make all the remaining missing transactions with data defaults. 
		foreach ( $missing as $order_id => $data ) {
			$missing_txn_message = globalcollect_audit_format_data_for_stomp( $data );
			
			//but then we have to send the transaction...
			if ( $test_mode ){
				$local_built_ids[] = $order_id;
				globalcollect_audit_echo('!');
			} else {
				if ( globalcollect_audit_send_stomp( 'donations', $missing_txn_message ) ){
					watchdog('globalcollect_audit', __FUNCTION__ . ': Message sent to stomp successfully: ' . print_r( $missing_txn_message, true ), array(), WATCHDOG_INFO);
					$local_built_ids[] = $order_id;
					globalcollect_audit_echo('!');
				} else {
					$wd_message = __FUNCTION__ . ': Sending message to stomp failed: ' . print_r( $missing_txn_message, true );
					$drush_message = "Failed sending STOMP message to queue.";
					globalcollect_audit_log_error( $wd_message, "STOMP_BAD_SEND", $drush_message );
					return;
				}
			}
		}
	}

	if ( count( $errorful_transactions ) ){
		globalcollect_audit_echo("Errorful Transactions: " . print_r( $errorful_transactions, true ));
		globalcollect_audit_results_ball( array('Final', 'Errors'), count($errorful_transactions) );
	}
	
	//more log noise killing
	foreach ( $counts as $log => $count ){
		if ( $count === 0 ){
			unset( $counts[$log] );
		}
	}
	
	globalcollect_audit_echo("Transactions found by log:" . print_r( $counts, true ));
	globalcollect_audit_echo("Still Missing: " . count($missing) . ".");
	if ( count($missing) ){
		globalcollect_audit_echo(" Good luck with that.");
		globalcollect_audit_results_ball( array('Final', 'Missing'), count($missing) );
	}
	globalcollect_audit_echo("\n");
	
	$time = microtime(true) - $actual_start_time;
	globalcollect_audit_echo("Total Runtime: $time");
	globalcollect_audit_results_ball( array('Final', 'Runtime'), $time );
}

/**
 * Finds more missing transactions to rebuild, in the remaining wr1 files. 
 * @staticvar bool $run_all_wr1 Whether or not we're configured to operate in 
 * Run All mode.  
 * @param array $wr1_files An array of full paths to wr1 files
 * @return mixed an array of entries in the wr1 files that are not present in 
 * civicrm
 */
function globalcollect_audit_find_more_missing(&$wr1_files){
	static $run_all_wr1 = null;
	
	if (is_null($run_all_wr1)){
		$run_all_wr1 = variable_get( 'globalcollect_audit_run_all_wr1', false );
	}
	
	$missing = array();
	
	while ( ( $run_all_wr1 || !count( $missing ) ) && count( $wr1_files ) ){
		$local_missing = array();
		$file = array_shift( $wr1_files );
		$wr1_data = globalcollect_audit_parse_wr1_file($file);
		
		if ( $wr1_data ){
			$local_missing = globalcollect_audit_find_missing_gc_trxns( $wr1_data );
			$missing += $local_missing;
			globalcollect_audit_results_ball(array('Missing at Start', $file), count($local_missing));
		}
		
		if ( !count( $local_missing ) ){
			globalcollect_audit_move_completed_wr1( $file );
		} 
	}
	
	if ( !count($missing) ){
		return false;
	} else {
		return $missing;
	}
}

/**
 * Just parse one wr1 file. 
 * @staticvar string $parser_directory The directory where the parser lives.
 * @param string $file Absolute location of the wr1 you want to parse
 * @return mixed An array of wr1 data, or false
 */
function globalcollect_audit_parse_wr1_file( $file ){
	static $parser_directory = null;
	if (is_null($parser_directory)){
		$parser_directory = variable_get( 'globalcollect_audit_wr1_parser_dir', CONTRIBUTION_AUDIT_WR1_PARSER_DIR );
	}
	require_once( $parser_directory . 'Wr1DataRecord.php' );
	
	$wr1_data = array();
	globalcollect_audit_echo("Parsing $file");

	$wr1_parser = new Wr1DataFileParser( $file );
	$start_time = microtime(true);
	foreach( $wr1_parser->getRecordIterator() as $record ) {	
		globalcollect_audit_echo( wr1_echochar( $record ) );
		$order_id = wr1_order_id( $record );
		if ( wr1_is_negative_txn( $record ) ){
			//have to do this to avoid collisions between the original and the chargeback / refund / whatever
			$order_id = '-' . $order_id;
		} 
		$wr1_data[ $order_id ] = $record;
	} 
	globalcollect_audit_echo("\n");
	$time = microtime(true) - $start_time;
	globalcollect_audit_echo("$file parsed in $time");
	if ( count( $wr1_data ) ){
		return $wr1_data;
	}
	return false;
}


function globalcollect_audit_format_data_for_stomp( $wr1, $donor_data = null, $contribution_tracking_id = null ){
	$fake_db = variable_get( 'globalcollect_audit_fake_db', CONTRIBUTION_AUDIT_FAKE_DB );
	$make_missing = variable_get( 'globalcollect_audit_make_missing', false );
	//you should probably make sure the data between the two sources match up before we do anything else
	
	//just knowing we _can_ make missing transactions isn't enough. We need to 
	//know if this particular one is still missing.
	$this_transaction_is_missing = false;
	if ( is_null($donor_data) ){
		//set this as true down the page a bit when ctid is missing. We could be 
		//running in some kind of half-missing mode.
		$this_transaction_is_missing = true;
	}
	
	$unstaged_amount = 0;
	
	if ( $this_transaction_is_missing && $make_missing ) {
		$donor_data = globalcollect_audit_make_default_donor_data( $wr1 );
	} 
	
	//if we have $donor_data, make sure it's rational
	if ( !$this_transaction_is_missing && ( (int)wr1_amount($wr1) !== (int)$donor_data['AMOUNT'] ) ){
		$amount_problem = true;
		if ( array_key_exists( 'Over-under-amount-local', $wr1 ) && (int)$wr1['Over-under-amount-local'] > 0 ){
			//then the mismatch is expected, and with a little more checking...
			// Invoice-amount-deliv = what we think it is.
			// Payment-amount = what actually happened.
			if ( (int)$wr1['Invoice-amount-deliv'] === (int)$donor_data['AMOUNT']  ){
				$unstaged_amount = (int)wr1_amount($wr1)/100; //it's a GC thing.
				$amount_problem = false;
			}
		} 
		if ( $amount_problem ) {
			$message = __FUNCTION__ . " $contribution_tracking_id Payment amount mismatch! Aborting.";
			globalcollect_audit_log_error( $message, "WR1_DATA_FORMAT" );
			return null;
		}
	} 

	$unstaged_amount = (int)wr1_amount($wr1)/100; //it's a GC thing.
	
	if ( !$this_transaction_is_missing && ( wr1_currency( $wr1 ) !== $donor_data['CURRENCYCODE'] )  ){
		$message = __FUNCTION__ . " $contribution_tracking_id Currency code mismatch! Aborting. ";
		globalcollect_audit_log_error( $message, "WR1_DATA_FORMAT" );
		return null;
	}
	
	$recurring = false;
	if ( array_key_exists( 'ORDERTYPE', $donor_data ) && $donor_data['ORDERTYPE'] == '4' ){
		$recurring = true;
	}
	
	//in case only our second half is missing...
	if ( is_null( $contribution_tracking_id ) ){
		$this_transaction_is_missing = true;
	}
	
	if ( $this_transaction_is_missing && $make_missing ){
		$contribution_tracking = globalcollect_audit_make_contribution_tracking_data( $wr1 );
	} 
	
	if ( !$this_transaction_is_missing ) {
		if ( !$fake_db ) {
			$contribution_tracking = globalcollect_audit_get_contribution_tracking_data( $contribution_tracking_id );
		} else {
			$contribution_tracking = globalcollect_audit_get_contribution_tracking_data( 1 );
		}
		if ( $contribution_tracking ){
			$payment_method_utm = explode( '.', $contribution_tracking['utm_source'] );
			$payment_method_utm = $payment_method_utm[2];

			$idiotic_date_format = $contribution_tracking['ts'];
			$real_timestamp = date_parse( $idiotic_date_format );

			$contribution_tracking['ts'] = mktime( 
				$real_timestamp['hour'], 
				$real_timestamp['minute'], 
				$real_timestamp['second'], 
				$real_timestamp['month'], 
				$real_timestamp['day'], 
				$real_timestamp['year']
			);
			//echo " $idiotic_date_format = $real_timestamp \n";

		} else {
			$payment_method_utm = null;
		}
	}

	$payment_submethod = false;
	if ( !$this_transaction_is_missing && array_key_exists( 'PAYMENTPRODUCTID', $donor_data ) ){
		$payment_info = globalcollect_audit_get_payment_submethod($donor_data['PAYMENTPRODUCTID']);
		$payment_method = $payment_info['group'];
		$payment_submethod = $payment_info['code'];
		if ( !$fake_db && $payment_method != $payment_method_utm ){
			$message = __FUNCTION__ . " Payment Method Mismatch on $contribution_tracking_id. UTM indicates '$payment_method_utm', but xml was sent for '$payment_method'. Using xml value.";
			globalcollect_audit_log_error( $message, "WR1_DATA_FORMAT" );
			//this is not fatal, so don't return here. 
		}
	}
	
	if ( $this_transaction_is_missing ){
		$payment_info = globalcollect_audit_make_payment_method_info( $wr1 );
		if ( array_key_exists( 'payment_method', $payment_info ) ){
			$payment_method = $payment_info['payment_method'];
		} else {
			$message = __FUNCTION__ . " Making missing records: Failed to find a payment method for " . $wr1['Payment-method'];
			globalcollect_audit_log_error( $message, "WR1_DATA_FORMAT" );
			return null;
		}
		if ( array_key_exists( 'payment_submethod', $payment_info ) ){
			$payment_submethod = $payment_info['payment_submethod'];
		}
	}
	
	//start it off with the stuff that's always there...
	$stomp_data = array(
		'contribution_tracking_id' => $contribution_tracking_id,
		'gateway' => 'globalcollect',
		'gross' => $unstaged_amount,
		'payment_method' => $payment_method,
	);
	
	if ( $payment_submethod ){
		$stomp_data['payment_submethod'] = $payment_submethod;
	}
	
	if( $recurring ){
		$stomp_data['recurring'] = 1;
	}
	
	if ( $make_missing ){
		$stomp_data['audit_hole'] = true;
	}
	
	
	//now, we have three sources for this mess: $wr1, $donor_data, and $contribution_tracking. Map 'em.
	$stomp_field_map = array(
		'optout' => array( 'contribution_tracking', 'optout' ),
		'anonymous' => array( 'contribution_tracking', 'anonymous' ),
		'comment' => array( 'contribution_tracking', 'note' ), //I think.
		'size',
		'premium_language',
		'utm_source' => array( 'contribution_tracking', 'utm_source' ),
		'utm_medium' => array( 'contribution_tracking', 'utm_medium' ),
		'utm_campaign' => array( 'contribution_tracking', 'utm_campaign' ),
		'language' => array( 'contribution_tracking', 'language' ), //probably the best one to use. 
		'referrer' => array( 'contribution_tracking', 'referrer' ),
		'email' => array( 'donor_data', 'EMAIL' ),
		'first_name' => array( 'donor_data', 'FIRSTNAME' ),
		'middle_name',
		'last_name' => array( 'donor_data', 'SURNAME' ),
		'street_address' => array( 'donor_data', 'STREET' ),
		'city' => array( 'donor_data', 'CITY' ),
		'state' => array( 'donor_data', 'STATE' ),
		'country' => array( 'donor_data', 'COUNTRYCODE' ),
		'postal_code' => array( 'donor_data', 'ZIP' ),
		'gateway_txn_id' => array( 'donor_data', 'ORDERID' ),
		'response', //? Maybe some dummy value for "found it in the audit phase"
		'currency' => array( 'donor_data', 'CURRENCYCODE' ),
		'date' => array( 'contribution_tracking', 'ts' ), //double-check how the dates work
	);
	
	foreach ( $stomp_field_map as $key => $location ){
		if( is_array( $location ) ){
			$source = $location[0];
			$source_key = $location[1];
			if ( is_array( ${$source} ) && array_key_exists( $source_key, ${$source} ) ){
				$stomp_data[$key] = ${$source}[$source_key];
			} else {
				$stomp_data[$key] = '';
			}
		} else {
			$stomp_data[$location] = '';
		}
	}
	
	return $stomp_data;


}

/**
 * Makes default donor data according to current run config, if the message 
 * cannot be rebuilt from logs. 
 * @param array $wr1 Transaction parsed into an array
 * @return array Donor data with appropriate keys
 */
function globalcollect_audit_make_default_donor_data( $wr1 ){
	
	$donor_data = array(
		'AMOUNT' => (int)wr1_amount($wr1),
		'EMAIL' => variable_get( 'globalcollect_audit_make_email', GC_AUDIT_MAKE_EMAIL ),
		'FIRSTNAME' => variable_get( 'globalcollect_audit_make_fname', GC_AUDIT_MAKE_FNAME ),
		'SURNAME' => variable_get( 'globalcollect_audit_make_lname', GC_AUDIT_MAKE_LNAME ),
		'STREET' => variable_get( 'globalcollect_audit_make_street', GC_AUDIT_MAKE_STREET ),
		'CITY' => variable_get( 'globalcollect_audit_make_city', GC_AUDIT_MAKE_CITY ),
	);
	
	$donor_data['ORDERID'] = wr1_order_id($wr1);
	
	//deal with the complete insanity that is the way currency codes are dealt with in the wr1 files...
	//cc always comes in as...
	if (array_key_exists('Transaction-currency', $wr1)){
		$donor_data['CURRENCYCODE'] = $wr1['Transaction-currency'];
	} else {
		//absolute madness. But I'm curious. So... here we go.
		$currency_code_fields = array(
			'Invoice-currency-deliv',
			'Invoice-currency-local',
			'Payment-currency',
			'Currency-due',
			'Over-under-currency-local', //the heck you say.
		);
		
		$currency = null;
		foreach ( $currency_code_fields as $field ){
			if (array_key_exists( $field, $wr1 )){
				if ( is_null($currency) ){
					$currency = trim($wr1[$field]);
				} else {
					if ( trim($wr1[$field]) != '' && trim($currency) != trim($wr1[$field]) ){
						//Alert the press: It's in five different fields for a reason!
						//I want this to email me, but for right now...
						globalcollect_audit_echo(print_r($wr1, true));
						globalcollect_audit_echo("Check it: The currencies are all messed up!");
						die();
					}
				}
			}
		}
		$donor_data['CURRENCYCODE'] = $currency;
	}
	
	
//	TODO: Figure out if/how WR1 files mark recurring and set:
//	$donor_data['ORDERTYPE'] = '4'
	
	return $donor_data;
}

/**
 * Makes everything we need to fake contribution tracking data. 
 * So: Mostly the timestamp. 
 * @param array $wr1 Transaction parsed into an array
 * @return array 
 */
function globalcollect_audit_make_contribution_tracking_data( $wr1 ){

	$return = array(
		//don't care about the actual values here: They're not saved downstream. 
		//It's just so we can eyeball where the stomp message came from, really.
		'utm_source' => 'gc_wr1',
		'utm_medium' => 'gc_wr1',
		'utm_campaign' => 'gc_wr1',
	);
	
	$return['ts'] = wr1_date_to_timestamp( $wr1 );
	return $return;
			
}

/**
 * Returns just the payment method and submethod codes from data contained in 
 * the $wr1 line.
 * @param array $wr1 Transaction parsed into an array
 * @return array
 */
function globalcollect_audit_make_payment_method_info( $wr1 ){
	$return = array();
	if ( $wr1['Payment-method'] === 'CC' ){
		$return['payment_method'] = 'cc';
		$return['payment_submethod'] = globalcollect_audit_cc_company_to_submethod( $wr1['Creditcard-company'] );
	} else {
		if (array_key_exists( 'WbC Payment product ID', $wr1 )){
			$subm = globalcollect_audit_get_payment_submethod( $wr1['WbC Payment product ID'] );
			$return['payment_method'] = $subm['group'];
			$return['payment_submethod'] = $subm['code'];
		} else {
			//dying here so I can run it against reality
			globalcollect_audit_echo(print_r($wr1, true));
			globalcollect_audit_echo("Need to handle this payment method and submethod.");
			die();
		}
	}
	
	return $return;
}


function globalcollect_audit_get_contribution_tracking_data( $contribution_tracking_id ){ 
	$dbs = wmf_civicrm_get_dbs();
	$dbs->push( 'donations' );

	$query = "SELECT * FROM contribution_tracking WHERE id = :id";
	$result = db_query( $query, array( ':id' => $contribution_tracking_id ) );
	if ( !$result->rowCount() ) {
		watchdog( 'globalcollect_audit', 'Missing Contribution Tracking data: @id ', array( 
		"@id" => $contribution_tracking_id ), WATCHDOG_DEBUG );  
	} else {
		watchdog( 'globalcollect_audit', 'Found Contribution: @id', array( '@id' => $contribution_tracking_id ), WATCHDOG_DEBUG );
	} 
	
	$result = $result->fetchAssoc();
	
	return $result;
}


/**
 * Returns an array of the full paths to all all valid .wr? files in the wr1 
 * directory. 
 * @return array full paths to all wr1-type files
 */
function globalcollect_audit_get_all_wr1_files(){
	$files_directory = variable_get( 'globalcollect_audit_wr1_files_dir', CONTRIBUTION_AUDIT_WR1_FILES_DIR );
	//foreach file in the directory, if it's a '*.wr?', add it to the list of files we could open.
	$files = array();
	if ( $handle = opendir( $files_directory ) ){
		while ( ( $file = readdir( $handle ) ) !== false ){
			if ( strpos( $file, '.wr' ) ){ //these can also be '.wr2', '.wr3', etc. 
				$files[] = $files_directory . $file;
			}
		}
	}
	closedir($handle);
	
	//This simple sort will work on the GC file naming convention until the year 
	//2020, when January will come up before anything else in the previous year. 
	//By that time, they will hopefully have changed their dumb 8-char filename 
	//standard anyway. 
	sort($files); 
	
	return $files;	
}

/**
 * Goes through the log file directory, and does a few things: 
 * * gunzips the .gz files
 * * Renames the raw unzips to something we're expecting
 * * Kills off log data that has been distilled already into .iop files
 * @return array A list of full paths to the files in their buckets 
 */
function globalcollect_audit_groom_logs(){
	$files_directory = variable_get( 'globalcollect_audit_log_files_dir', CONTRIBUTION_AUDIT_LOG_FILES_DIR );
	$files_directory_alt = variable_get( 'globalcollect_audit_log_files_dir_secondary', CONTRIBUTION_AUDIT_LOG_FILES_DIR );

	$files = array(
		'gz' => array(),
		'rename' => array(),
		'log' => array(),
		'iop' => array()
	);
	globalcollect_audit_echo("Grooming log files");
	$dates = array();
	if ( $handle = opendir( $files_directory ) ){
		while ( ( $file = readdir( $handle ) ) !== false ){
			$full_path = $files_directory . $file;
			$date = globalcollect_audit_get_log_date_by_file($full_path);
			if ( !$date ){
				continue;
			}
			$dates[] = $date;
			if ( strpos( $file, '.gz' ) ){
				$files['gz'][] = $full_path;
				continue;
			}
			if ( preg_match( '/\d{8}_iop\.log/', $file ) ){
				$files['iop'][$date] = $full_path;
				//rekey
				continue;
			}
			if ( preg_match( '/globalcollect_\d{8}\.log/', $file ) ){
				$files['log'][$date] = $full_path;
				//rekey
				continue;
			}
			if ( preg_match( '/globalcollect.\d{8}/', $file ) ){
				$files['rename'][] = $full_path;
				continue;
			}
		}
	}
	closedir($handle);
	
	if ( $files_directory_alt != $files_directory ){
		//and if we're missing any files from between what's in that dir, and NOW,
		//go get them at the alt and add them to the .gz list.
		sort($dates, SORT_NUMERIC);
		//we have to add one to the next date, because the dates in the audit script are all -1.
		$earliest_log_date = wmf_common_date_add_days( $dates[0], 1);
		$today_date = wmf_common_date_get_today_string();
		
		$copy_us = wmf_common_date_get_date_gap( $earliest_log_date, $today_date );
		$copy_us = array_diff( $copy_us, $dates ); //get all date holes.

		foreach ( $copy_us as $missing_date ){
			$copy_me = 'payments-globalcollect-' . $missing_date . '.gz';
			if ( file_exists( $files_directory_alt . $copy_me ) ){
				$cmd = "cp $files_directory_alt$copy_me $files_directory";
				exec( escapeshellcmd($cmd), $ret, $errorlevel );
				if ( !file_exists( $files_directory . $copy_me ) ){
					globalcollect_audit_echo("FILE PROBLEM: Something went wrong with $cmd");
				} else {
					$files['gz'][] = $files_directory . $copy_me;
				}
			} else {
				globalcollect_audit_echo("Missing log file $files_directory_alt$copy_me does not exist!");
			}
		}
	}
	
	//handle the gz files first
	foreach ($files['gz'] as $key => $gzfile){
		globalcollect_audit_echo("Gunzipping $gzfile");
		$cmd = "gunzip $gzfile";
		exec( escapeshellcmd($cmd), $ret, $errorlevel );
		//now check to make sure the file you expect exists
		$newfile = substr( $gzfile, 0, strlen($gzfile) - 3 );
		if (!file_exists($newfile)){
			globalcollect_audit_echo("FILE PROBLEM: Something went wrong with $cmd : $newfile doesn't exist.");
		} else {
			//add it to the other array. 
			$files['rename'][] = $newfile;
			if (file_exists($gzfile)){ //still? 
				unlink($gzfile);
			}
			unset($files['gz'][$key]);
		}
	}
	
	//handle the renames
	foreach ($files['rename'] as $key => $rename_me){
		globalcollect_audit_echo("Renaming $rename_me");
		//'/globalcollect.\d{8}_\d{6}/'
		//becomes 
		//'/globalcollect_\d{8}\.log/'
		$new_name = explode('/', $rename_me);
		//and the file name should be the last array key. 
		$just_file = array_pop($new_name);
		$just_file = preg_replace(
			array( '/(payments.)?globalcollect./' ),
			array( 'globalcollect_' ),
			$just_file );
		$new_name = implode( '/', $new_name ) . '/' . $just_file . '.log';
		rename( $rename_me, $new_name );
		$files['log'][] = $new_name;
		unset($files['rename'][$key]);
	}
	
	//delete redundant data
	foreach ( $files['log'] as $key => $big_log ){
		//'/\d{8}_iop\.log/'
		//is a distilled version of
		//'/globalcollect_\d{8}\.log/'
		$smallened_log = preg_replace(
			array('/globalcollect_/', '/\.log/'),
			array('', '_iop.log'),
			$big_log );
		if ( in_array($smallened_log, $files['iop']) ){
			globalcollect_audit_echo("Deleting $big_log");
			unlink( $big_log );
			unset($files['log'][$key]);
		}
	}
	
	foreach ($files as $type => $dontrekeyme){
		ksort($files[$type]);
	}
	
	return $files;
}


function globalcollect_audit_move_completed_wr1( $file, $nearly = false ){
	$subdir = 'completed';
	if ($nearly){
		$subdir .= '-nearly-' . date('Y-m-d', time());
	}
	$files_directory = variable_get( 'globalcollect_audit_wr1_files_dir', CONTRIBUTION_AUDIT_WR1_FILES_DIR );
	$completed_dir = $files_directory . '/' . $subdir;
	if ( !is_dir( $completed_dir ) ){
		if ( !mkdir ( $completed_dir, 0700 )){
			$message = "Could not make $completed_dir";
			watchdog('globalcollect_audit', $message);
			return false;
		}	
	}
	
	$path_info = pathinfo( $file );
	$newfile = $path_info['dirname'] . '/' . $subdir . '/' . $path_info['basename'];
	
	if (!rename( $file, $newfile )){
		$message = "Unable to move $file to $newfile";
		watchdog('globalcollect_audit', $message);
		return false;
	}
	globalcollect_audit_echo("Moved $file to $newfile");
	return true;
}


function globalcollect_audit_mark_rfd_cbk( $missing ){
	globalcollect_audit_echo('Marking refunds and chargebacks');
	$count = 0;
	foreach ( $missing as $index => $wr1 ){
		if ( wr1_is_negative_txn( $wr1 ) ){
			$send_message = array(
				'gateway_refund_id' => 'RFD' . wr1_order_id( $wr1 ), //after intense deliberation, we don't actually care what this is at all.
				'gateway_parent_id' => wr1_order_id( $wr1 ), //gateway transaction ID
				'gross_currency' => wr1_currency( $wr1 ), //currency code
				'gross' => wr1_amount( $wr1 ) / 100, //amount
				'date' => wr1_date_to_timestamp( $wr1 ), //timestamp
				'gateway' => 'globalcollect', //lcase
				'gateway_account' => $wr1['gateway_account'], //from DI. ?
				'payment_method' => '', //Argh. Not telling you. 
				'payment_submethod' => '', //Still not telling you.
				'type' => wr1_get_negative_type( $wr1 ), //refund or chargeback
			);
			echo print_r( $send_message, true );
			globalcollect_audit_send_stomp( 'refund', $send_message );
			$count += 1;
			globalcollect_audit_echo('.');
			
			unset( $missing[$index] );
		}
	}
	globalcollect_audit_results_ball( 'refunds/chargebacks', $count );
	return $missing;
}

/**
 * Tries to intelligently select the next most likely log to knock off the 
 * majority of the remaining missing transactions, which drastically cuts down 
 * on runtime. 
 * @staticvar array $tried The dates we have tried
 * @staticvar string $available The groomed files that are currently available 
 * in the logs directory. 
 * @param array $missing Parsed missing transaction data form the wr1 files
 * @param array $counts Array of log data we have found, indexed by the actual 
 * date it was initiated (logdate - 1)
 * @return type 
 */
function globalcollect_audit_get_next_log( $missing, $counts ){
	static $tried = array();
	static $available = null;
	if ( is_null( $available ) ){
		$available = globalcollect_audit_groom_logs();
		//$available['iop'] and $available['log'] are the ones we want.
		//don't really care about the order: All we want at this point are the 
		//keys, so we have to flip first or array_merge will think they're 
		//numeric and rekey. I hate php.  
		$available = array_merge( array_flip($available['log']), array_flip($available['iop']) );
		rsort( $available );
	}
	
	//this is the var that tells us how far to cluster around the dates we're 
	//missing, before we simply slide backwards into history.
	$plusminus = variable_get( 'globalcollect_audit_plusminus', CONTRIBUTION_AUDIT_PLUSMINUS );
	
	//haven't found anything yet. 
	$file = null;
	
	//If this is the first time around, kill the future.
	if ( empty($tried) ){
		$today = wmf_common_date_get_today_string();
		for ( $i=0; $i<$plusminus + 1; ++$i ){
			$tried[] = wmf_common_date_add_days( $today, $i );
		}
	}
	
	//look for the next file until we either find something, or hit a fatal error. 
	while ( globalcollect_audit_can_continue() && is_null( $file ) ){
		$tryme = false;

		//Find the most popular date in the missing transactions that has not been 
		//tried yet, and look there. 
		if ( !$tryme ){
			$dates = array();
			foreach ( $missing as $transaction ){
				$date = wr1_date( $transaction );
				if (is_null($date)){
					return null;
				}
				if ( array_key_exists( $date, $dates ) ){
					$dates[$date] += 1;
				} else {
					$dates[$date] = 1;
				}
			}

			//now turn the array inside out and sort it by most popular date
			array_flip($dates);
			arsort($dates);

			foreach ( $dates as $date => $count ){
				if ( !in_array($date, $tried) ){
					$tryme = $date;
					break;
				}
			}
		}

		//Buffer out both directions from all the dates we've found something on.
		if ( !$tryme ){
			//we've tried all the log dates explicitly present in the wr1. Now try more.
			$more_tries = array();
			for($i=1; $i < ($plusminus + 1); ++$i ){
				$more_tries[] = $i;
				$more_tries[] = $i * -1;
			}

			foreach ( $dates as $date => $count ){
				foreach( $more_tries as $add ){
					$newdate = wmf_common_date_add_days( $date, $add );
					if ( !in_array($newdate, $tried) ){
						$tryme = $newdate;
						break 2;
					}
				}
			}
		}

		//Check everything else we have, that we haven't tried yet.
		if ( !$tryme ){
			foreach ( $available as $date ){
				if ( !in_array( $date, $tried ) ){
					$tryme = $date;
					break;
				}
			}
		}

		//We have now tried everything. Kick out of the loop with an error code that will cause can_continue to say "no".  
		if ( !$tryme ){
			$message = __FUNCTION__  . " No 'next' log identified. Current Missing: " . print_r( $dates, true );
			globalcollect_audit_log_error( $message, "WR1_LOG_STOP" );
			return null;
		}

		$tried[] = $tryme;
		//now see if the file actually exists. 
		$file = globalcollect_audit_get_log_file_by_date( $tryme );
	}
	return $file;
	
}

/**
 * Returns the log file that will contain transactions from the date passed in. 
 * @param string $date The target date of the actual log entry
 * @return string The full path to the reduced iop file
 */
function globalcollect_audit_get_log_file_by_date( $date ){
	//I know somebody is going to try to come back in time just to punch me for this one, but...
	$date = wmf_common_date_add_days( $date, 1 );
	//I swear it makes sense. Most of the data in any given log are actually from the previous day. 
	
	$log_directory = variable_get( 'globalcollect_audit_log_files_dir', CONTRIBUTION_AUDIT_LOG_FILES_DIR );
	$file = $log_directory . $date . '_iop.log';
	if ( file_exists( $file ) ){
		return $file;
	} else {
		//try to make it.
		$original_file = $log_directory . 'globalcollect_' . $date . '.log';
		if ( file_exists( $original_file ) ){
		
			$cmd = escapeshellcmd("grep 'INSERT_ORDERWITHPAYMENT' $original_file") . " > " . escapeshellcmd($file);

			globalcollect_audit_echo( $cmd );
			$ret = array();
			exec( $cmd, $ret, $errorlevel );
			
			if ( file_exists( $file ) ) {
				return $file;
			} else {
				$message = __FUNCTION__ . " $file could not be created. Something went wrong with the grep (permissions?)";
				globalcollect_audit_log_error( $message, "WR1_LOG_FATAL" );
				return null;
			}
			
		} else {
			$message = "$original_file not found. Please copy that file to the specified directory and re-run.";
			globalcollect_audit_log_error( $message, "WR1_LOG" );
			return null;
		}
	}
	
}

/**
 * Given a file name, should return the Ymd date portion of the filename.
 * This should work on both .log files, and .iop files generated by this script.
 * @param string $file Name of the file. Either a full path, or not. 
 * @return string The file's date in the format Ymd
 */
function globalcollect_audit_get_log_date_by_file( $file ){
	$file = explode('/', $file);
	$file = $file[count($file) - 1];
	
	$date = false;
	if ( preg_match( '/\d{8}_iop\.log/', $file ) ){
		$date = str_replace('_iop.log', '', $file);
	}
	if ( preg_match( '/globalcollect_\d{8}\.log/', $file ) ){
		$date = str_replace(array('globalcollect_', '.log'), array('',''), $file);
	}
	if ( preg_match( '/payments-globalcollect-\d{8}\.gz/', $file ) ){
		$date = str_replace(array('payments-globalcollect-', '.gz'), array('',''), $file);
	}
	if ( preg_match( '/globalcollect.\d{8}_\d{6}/', $file ) ){ //this happens sometimes
		$date = str_replace('globalcollect.', '', $file);
		$date = substr($date, 8);
	}

	if ( !is_numeric( $date ) ){
		return false;
	}
	
	//Subtract one from the date, because the logs rotate at midnight, so all 
	//the actual transactions are from the previous day. 
	$date = wmf_common_date_add_days( $date, -1 );
	return $date;
}


function globalcollect_audit_get_log_data_by_order_id( $order_id, $log ){
	
	$cmd = "grep <ORDERID>$order_id</ORDERID> $log";
	globalcollect_audit_echo( __FUNCTION__ . ' ' . $cmd, true );

	//echo $cmd . "\n";
	$ret = array();
	exec( escapeshellcmd($cmd), $ret, $errorlevel );
	
	if ( count( $ret ) > 0 ){
		
		//get the xml, and the contribution_id... and while we're at it, parse the xml. 
		$xml = null;
		$full_xml = false;
		$contribution_id = null;
		foreach ( $ret as $line ){
			if ( is_null( $xml ) ){
				//look for the raw xml. 
				if ( strpos( $line, 'RETURNED FROM CURL' ) ){
					$xmlstart = strpos( $line, '<XML>' );
					//$xmlend = strpos( $line, '</XML>' ) + 6;
					$xmlend = strpos( $line, '</XML>' );
					if ( $xmlend ){
						$full_xml = true;
						$xmlend += 6;
						$xml = substr($line, $xmlstart, $xmlend - $xmlstart);
					} else {
						//this is a broken line, and it won't load... but we can still parse what's left of the thing, the slow way.
						$xml = substr($line, $xmlstart);
					}
				}
			}
			if ( is_null( $contribution_id ) ){
				//get the contribution tracking id. 
				$ctid_end = strpos( $line, 'Raw XML Response' );
				if ( $ctid_end > 0 ){
					$ctid_start = strpos( $line, '_gateway:' ) + 9;
					$ctid = substr($line, $ctid_start, $ctid_end - $ctid_start);
					$contribution_id = trim( $ctid, ' :' );
				}
			}
		}

		if ( is_null( $contribution_id ) || is_null( $xml ) ){
			globalcollect_audit_echo("OH NOES. Couldn't find enough info in this log for order id $order_id!");
			if ( !is_null( $contribution_id ) ){
				globalcollect_audit_echo( $contribution_id );
			}
			if ( !is_null( $xml ) ){
				globalcollect_audit_echo("...but we also have xml, so that's odd.");
			}
			//TODO: This needs more love. We can't go on without both parts, but we should log that we found some of it.

			return null;
		} else {
			//go on with your bad self
			//echo "$order_id: '$contribution_id'. XML: \n$xml\n";
			//now parse the xml...
			
			$donor_data = array();
				
			if ( $full_xml ){
				$xmlobj = new DomDocument;
				$xmlobj->loadXML($xml);

				$parent_nodes = array(
					'ORDER',
					'PAYMENT'
				);

				foreach ( $parent_nodes as $parent_node ){
					foreach ( $xmlobj->getElementsByTagName( $parent_node ) as $node ) {
						foreach ( $node->childNodes as $childnode ) {
							if ( trim( $childnode->nodeValue ) != '' ) {
								$donor_data[$childnode->nodeName] = $childnode->nodeValue;
							}
						}
					}
				}
			} else {
				
				$search_for_nodes = array(
					'ORDERID' => true,
					'AMOUNT' => true,
					'CURRENCYCODE' => true,
					'PAYMENTPRODUCTID' => true,
					'ORDERTYPE' => true,
					'EMAIL' => true,
					'FIRSTNAME' => false,
					'SURNAME' => false,
					'STREET' => false,
					'CITY' => false,
					'STATE' => false,
					'COUNTRYCODE' => true,
					'ZIP' => false,
				);
				
				foreach ( $search_for_nodes as $node => $mandatory ){
					$tmp = globalcollect_audit_get_partial_xml_node_value( $node, $xml );
					if ( !is_null( $tmp ) ){
						$donor_data[$node] = $tmp;
					} else {
						if ( $mandatory ){
							$wd_message = __FUNCTION__ . ": Mandatory field $node missing for $contribution_id. Aborting.";
							globalcollect_audit_log_error( $wd_message, 'MISSING_MANDATORY_DATA' );
							return null;
						} else {
							$donor_data[$node] = '';
						}
					}
				}
			}
			
			$return['contribution_id'] = $contribution_id;
			$return['donor_data'] = $donor_data;
			return $return;
		}
	}
	return false;
}

/**
 * Logs the errors we get in a consistent way
 * @param type $watchdog_message
 * @param type $drush_code
 * @param type $drush_message 
 */
function globalcollect_audit_log_error( $watchdog_message, $drush_code, $drush_message = null ){
	global $gc_audit_errors;
	if ( is_null( $drush_message ) ){
		$drush_message = $watchdog_message;
	}

	//hijacking this for missing logs. These are clogging the errors, and I'd rather have the ball at the end anyway. 
	if ( $drush_code === 'WR1_LOG' ){
		$watchdog_message = explode(' ', $watchdog_message);
		$watchdog_message = explode('/', $watchdog_message[0]);
		globalcollect_audit_results_ball('Missing Logs', $watchdog_message[count($watchdog_message) - 1]);
		return;
	} else {
		//ball it up anyway. 
		globalcollect_audit_results_ball( $drush_code, $drush_message );
	}
	
	watchdog('globalcollect_audit', $watchdog_message, NULL, WATCHDOG_ERROR);
	
	//STOP EXPLODING.
	if (globalcollect_audit_error_isfatal( $drush_code )) {
		$gc_audit_errors[$drush_code] = $drush_message;
	}
}

/**
 * Gather output info in a static, because that's... less bad than a global
 * @param mixed $key Key denoting the type of data we are storing. Could be a 
 * string, or an array with two values (key and subkey) 
 * @param string $value The value we want to add to that key. Default null
 * @param bool $reset Set to true, if you want to wipe all values in $key (and 
 * set $reset to true and $key to false if you want to wipe everything). 
 * Default false.
 * @return array The entire ball of final results so far.  
 */
function globalcollect_audit_results_ball($key = null, $value = null, $reset = false){
	static $data_ball = array();
	$subkey = null;
	if ($key && is_array($key)){
		$subkey = $key[1];
		$key = $key[0];
	}
	
	//reset first
	if ( $reset ){
		if ( $key && array_key_exists( $key, $data_ball ) ){
			if ( $subkey && array_key_exists( $subkey, $data_ball[$key] ) ){
				unset($data_ball[$key][$subkey]);
			}
			if ( !$subkey ) {
				unset($data_ball[$key]);
			}
		}
		if ( !$key ){
			$data_ball = array();
		}
	}
	
	//then add the value
	if ( $key && !is_null( $value ) ){
		if ( $subkey ){
			//direct assignment
			$data_ball[$key][$subkey] = $value;
		} else {
			//add a value to the array
			$data_ball[$key][] = $value;
		}
	}
	
	return $data_ball;
}

/**
 * Function determines if the audit can continue. 
 * Will return false if we've thrown an error that is of a type that should be 
 * fatal.
 * @return bool True if the audit can soldier on, else false 
 */
function globalcollect_audit_can_continue(){
	//check for errors
	global $gc_audit_errors;
	if ( count( $gc_audit_errors ) ){
		//nonfatal errors: 
		//"WR1_DATA_FORMAT" 
		
		if ( array_key_exists( 'WR1_LOG_STOP', $gc_audit_errors ) ){
			//If the only thing in the errors is a log stop, don't blow up.
			//If there's other stuff, we should blow up with all of it. 
			if ( count( $gc_audit_errors ) !== 1 ){
				foreach ( $gc_audit_errors as $code => $thing ){
					drush_set_error($code, $thing);
				}
			}
			return false;
		}
		
		foreach ( $gc_audit_errors as $code => $thing){
			if (globalcollect_audit_error_isfatal( $code )) {
				return false;
			}
		}
	}
	return true;
}

/**
 * Returns an array of errors that should not cause the script to blow up.
 * @return type
 */
function globalcollect_audit_error_isfatal( $error ){
	$nonfatal =  array(
		'WR1_DATA_FORMAT',
		'MISSING_MANDATORY_DATA',
		'WR1_LOG',
		'MISSING_PARENT',
		'PARENT_OVERFLOW',
		'RECURRING_CBK',
		'CBK+RFD',
	);
	
	if ( in_array( $error, $nonfatal) ){
		return false;
	} else {
		return true;
	}
}

function globalcollect_audit_get_partial_xml_node_value( $node, $xml ){
	$node1 = "<$node>";
	$node2 = "</$node>";

	$valstart = strpos( $xml, $node1 ) + strlen( $node1 );
	if ( !$valstart ){
		return null;
	}
	
	$valend = strpos( $xml, $node2 );
	if ( !$valend ){ //it cut off in that node. This next thing is therefore safe(ish). 
		$valend = strpos( $xml, '</' );
	}
	
	if ( !$valend ){
		return null;
	}
	
	$value = substr( $xml, $valstart, $valend - $valstart );
	return $value;

}


function globalcollect_audit_cc_company_to_submethod( $cc_company ){
	$cc_array = array(
		'AMEX' => 'amex',
		'ECMC' => 'mc',
		'VISA' => 'visa',
		'DISC' => 'discover',
	);
	
	if ( array_key_exists( $cc_company, $cc_array ) ){
		return $cc_array[$cc_company];
	} else {
		//I am dying here, because if you're running in make_missing mode 
		//(which is currently the only way to get here) 
		//you dang well better be doing it manually.
		globalcollect_audit_echo("$cc_company is not a known Credit Card Company code! Fixit.");
		die();
	}
}

function globalcollect_audit_get_payment_submethod( $payment_product ){
	//get the payment product as a number. Then, look it up. 
	$map = array(
		11 => array(
			//GC Bank Transfer (new)
			'code' => 'bt',
			'group' => 'bt',
		),
			//Credit Cards: If the card is specified, land it in the right specific bucket.
			//otherwise: cc
		1 => array(
			'code' => 'visa',
			'group' => 'cc',
		),
		3 => array(
			'code' => 'mc',
			'group' => 'cc',
		),
		2 => array(
			'code' => 'amex',
			'group' => 'cc',
		),
		117 => array(
			'code' => 'maestro',
			'group' => 'cc',
		),
		118 => array(
			'code' => 'solo',
			'group' => 'cc',
		),
		124 => array(
			'code' => 'laser',
			'group' => 'cc',
		),
		125 => array(
			'code' => 'jcb',
			'group' => 'cc',
		),
		128 => array(
			'code' => 'discover',
			'group' => 'cc',
		),
		130 => array(
			'code' => 'cb',
			'group' => 'cc',
		),
		713 => array(
			//Direct Debit - all 'dd'
			'code' => 'dd_at',
			'group' => 'dd',
		),
		716 => array(
			'code' => 'dd_be',
			'group' => 'dd',
		),
		717 => array(
			'code' => 'dd_ch',
			'group' => 'dd',
		),
		712 => array(
			'code' => 'dd_de',
			'group' => 'dd',
		),
		719 => array(
			'code' => 'dd_es',
			'group' => 'dd',
		),
		714 => array(
			'code' => 'dd_fr',
			'group' => 'dd',
		),
		715 => array(
			'code' => 'dd_gb',
			'group' => 'dd',
		),
		718 => array(
			'code' => 'dd_it',
			'group' => 'dd',
		),
		711 => array(
			'code' => 'dd_nl',
			'group' => 'dd',
		),
		840 => array(
			//paypal
			'code' => 'ew_paypal',
			'group' => 'ew',
		),
		841 => array(
			//webmoney
			'code' => 'ew_webmoney',
			'group' => 'ew',
		),
		843 => array(
			//moneybookers
			'code' => 'ew_moneybookers',
			'group' => 'ew',
		),
		845 => array(
			//cashu  :)
			'code' => 'ew_cashu',
			'group' => 'ew',
		),
		849 => array(
			//yandex
			'code' => 'ew_yandex',
			'group' => 'ew',
		),
		500 => array(
			//bpay
			'code' => 'bpay',
			'group' => 'obt',
		),
		805 => array(
			//nordea
			'code' => 'rtbt_nordea_sweden',
			'group' => 'rtbt',
		),
		809 => array(
			//iDeal (exists)
			'code' => 'rtbt_ideal',
			'group' => 'rtbt',
		),
		810 => array(
			//enets
			'code' => 'rtbt_enets',
			'group' => 'rtbt',
		),
		836 => array(
			//sofort (exists!)
			'code' => 'rtbt_sofortuberweisung',
			'group' => 'rtbt',
		),
		856 => array(
			//EPS
			'code' => 'rtbt_eps',
			'group' => 'rtbt',
		),
		1503 => array(
			//Boleto
			'code' => 'cash_boleto',
			'group' => 'cash',
		),
	);
	
	return $map[$payment_product];

}

function globalcollect_audit_echo( $echo, $verbose = false ) {
	if ( $verbose && variable_get( 'globalcollect_audit_verbose', false ) === false ) {
		return;
	}
	static $chars = 0;
	static $limit = null;
	if (is_null($limit)){
		$limit = variable_get( 'globalcollect_audit_charlimit', 0);
	}
	
	if ( strlen( $echo ) === 1 ){
		echo $echo;
		++$chars;
		if ($limit > 0 && $chars > $limit){
			echo "\n";
			$chars = 0;
		}
	} else {
		//echo a whole line. Gets a little tricky.
		if ( $chars != 0 ){
			echo "\n";
		}
		echo "$echo\n";
		$chars = 0;		
	}
}

/**
 * *** Normalization Helpers ***
 * Everything from here down is a function meant to simplify the way we 
 * reference values returned in the wr1 record. 
 * PLEASE NOTE: I haven't decided if I hate this approach or not yet. 
 * If it turns out I hate it, I'll just write a normalization function for 
 * everything and run 'em all through the seive. 
 */


function wr1_echochar( $record ){
	if ($record['Record-category'] === '-'){
		switch ( $record['Record-type'] ){
			case 'CR':
				return 'r';
				break;
			case 'CB':
				return 'k';
				break;
			default:
				return '-';
		}
	} else {
		switch ( $record['Payment-method'] ){
			case 'CC':
				return 'c';
				break;
			case 'BA':
			case 'OB':
				return 'b';
				break;
			case 'PP': //this actually means "ewallets" to us
				return 'e';
				break;
			default:
				return '+';
		}
	}
}


function wr1_order_id( $record ){
	$ordered_keys = array(
		'Order-number',
		'Additional-reference',
		'Reference-original-payment',
	);
	
	if ( wr1_is_negative_txn( $record ) ){
		$ordered_keys = array(
			'Reference-original-payment',
			'Order-number-original',
			'Order-number',
		);
		if ( $record['Record-type'] === 'CR' ){
			unset ( $ordered_keys[0] );
		}
	}
	
	return gca_wr1_key_grinder($record, $ordered_keys, 'order ID');
}

function wr1_currency( $record ){
	$ordered_keys = array(
		'Transaction-currency',
		'Payment-currency',
		'Invoice-currency-deliv',
		'Invoice-currency-local',
		'Currency-due',
		'Over-under-currency-local',
	);
	return gca_wr1_key_grinder($record, $ordered_keys, 'currency', true);
}

function wr1_date( $record ){
	$ordered_keys = array(
		'Date-authorised',
		'Date-due',
	);
	return gca_wr1_key_grinder($record, $ordered_keys, 'date');
}

function wr1_date_to_timestamp( $record ){
	$parsed = date_parse( wr1_date($record) );
	
	return mktime( 
		'0',
		'0',
		'0',
		$parsed['month'],
		$parsed['day'],
		$parsed['year']
	);
}

function wr1_amount( $record ){
	$ordered_keys = array(
		'Payment-amount',
		'Amount-due',
	);
	return gca_wr1_key_grinder($record, $ordered_keys, 'amount');
}

function wr1_is_negative_txn( $record ){
	$ordered_keys = array(
		'Amount-sign_payment',
		'Amount-sign_amount',
	);
	$sign = gca_wr1_key_grinder($record, $ordered_keys, 'sign');
	if ( $sign === '-' ) {
		return true;
	}
	return false;
}

function wr1_get_negative_type( $record ){
	$refund_type = false;
	if ($record['Record-category'] === '-'){
		switch ( $record['Record-type'] ){
			case 'CR':
				$refund_type = 'refund';
				break;
			case 'CB':
				$refund_type = 'chargeback';
				break;
		}
	}
	
	return $refund_type;
}

function gca_wr1_key_grinder( $record, $keys, $name, $error_on_mismatch = false ){

	if ( $error_on_mismatch ){
		$ret = null;
		$first = '';
		foreach ( $keys as $key ){
			if (array_key_exists( $key, $record )){
				if ( is_null($ret) ){
					$ret = trim($record[$key]);
					$first = $key;
				} else {
					if ( trim($record[$key]) != '' && $ret != trim($record[$key]) ){
						globalcollect_audit_echo(print_r($record, true));
						globalcollect_audit_echo("Check it: The $name is all f'd. $first does not match $key (at least).");
						
						//insert special "don't die" rules here.
						//On occasion, these are predictable and we can cope with them going in "wrong"...
						$die = true;
						if ( $name === 'currency' 
							&& $record['WbC Payment method ID'] === '8' 
							&& $record['WbC Payment product ID'] === '841' ){
							$ret = $record['Payment-currency'];
							globalcollect_audit_echo("...but we're (sort of) fine with the Webmoney mismatch. Setting $name to $ret");
							$die = false;
						}

						if ( $die && !( variable_get( 'globalcollect_audit_mismatch_override', false ) ) ){
							die();
						} else {
							//short-circuit the rest of this generalized business. We know what's up.
							return $ret;
						}
					}
				}
			}
		}
		return $ret;
		
	} else {
		foreach ( $keys as $key ){
			if ( array_key_exists( $key, $record ) && trim($record[$key]) !== '' ){
				return $record[$key];
			}
		}
		//implicit else
		//TODO: Remove this mess when you know it's not going to... fail to kill things. 
		$checked = array(
			'sign',
		);
		if ( !in_array( $name, $checked ) ){
			globalcollect_audit_echo("No $name found for the following record: " . print_r( $record, true ));
			die();
		}
		return null;
	}
}

function globalcollect_audit_send_stomp( $queueId, $body ) {
    static $q;

    if ( !$q ) {
        $q = new Queue( queue2civicrm_stomp_url() );
    }

    // FIXME: register the queue mapping somewhere sane
    if ( $queueId === 'donations' ) {
        $queuePath = variable_get( 'queue2civicrm_subscription', '/queue/test' );
    } elseif ( $queueId === 'refund' ) {
        $queuePath = variable_get( 'refund_queue', '/queue/refund-notifications_test' );
    } else {
        throw new Exception( "What kind of a queue is this??: {$queueId}" );
    }

    $headers = array(
        'source_name' => "GlobalCollect WR1 Auditor",
        'source_type' => 'audit',
        'source_host' => gethostname(),
        'source_run_id' => getmypid(),
        'source_version' => wmf_common_get_my_revision(),
        'source_enqueued_at' => time(),
    );

    return $q->enqueue( json_encode( $body ), $headers, $queuePath );
}
