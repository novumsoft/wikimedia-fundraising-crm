<?php

use SmashPig\Core\Helpers\CurrencyRoundingHelper;
use SmashPig\Core\UtcDate;
use SmashPig\PaymentData\ReferenceData\CurrencyRates;
use wmf_civicrm\ImportStatsCollector;
use Civi\Api4\Email;

require_once 'recurring.inc';
require_once 'tracking.inc';
require_once 'wmf_civicrm.hooks.php';

function wmf_civicrm_menu() {
  $items = [];

  $items['admin/config/wmf_civicrm/matching_gifts'] = array(
    'title' => t('Matching Gifts Employer Data'),
    'description' => t('Set matching gifts employer data config'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('wmf_civicrm_matching_gifts_form'),
    'access arguments' => array('administer site configuration'),
    'type' => MENU_NORMAL_ITEM,
  );

  return $items;
}

function wmf_civicrm_matching_gifts_form() {
  $form = array();

  $form['matching_gifts_employer_data_file_path'] = array(
    '#type' => 'textfield',
    '#title' => 'File path for matching gifts employer data file',
    '#required' => TRUE,
    '#default_value' => variable_get(
      'matching_gifts_employer_data_file_path',
      '/srv/matching_gifts/employers.csv'
    ),
    '#description' => 'File path for matching gifts employer data file',
  );


  $form['matching_gifts_employer_data_update_email'] = array(
    '#type' => 'textfield',
    '#title' => 'Email address to send updates to',
    '#required' => TRUE,
    '#default_value' => variable_get(
      'matching_gifts_employer_data_update_email', 'fr-tech@wikimedia.org'
    ),
    '#description' => 'Email address to send matching gifts employer data updates to',
  );

  return system_settings_form($form);
}

/**
 * Ensure the specified option value exists.
 *
 * @param string $group_name
 * @param string $value
 */
function wmf_civicrm_ensure_option_value_exists($group_name, $value) {
  $params = [
    'option_group_id' => $group_name,
    'name' => $value,
    'label' => $value,
    'value' => $value,
    'is_active' => 1,
  ];
  $existingValues = civicrm_api3('OptionValue', 'get', [
    'option_group_id' => $params['option_group_id'],
    'value' => $params['value'],
    'sequential' => 1,
  ]);
  $createRequired = FALSE;
  if ($existingValues['count'] == 0) {
    $createRequired = TRUE;
  }
  elseif (!$existingValues['values'][0]['is_active']) {
    $params['id'] = $existingValues['values'][0]['id'];
    $createRequired = TRUE;
  }
  if ($createRequired) {
    civicrm_api3('OptionValue', 'create', $params);
    // It won't take much to rebuild this & we don't know the entity.
    // This should be rare.
    wmf_civicrm_flush_cached_options();
  }
}

function civicrm_api_classapi() {
  civicrm_initialize();
  if (module_load_include('php', 'civicrm', '../api/class.api') === FALSE) {
    watchdog('civicrm_api', t('Failed to load civicrm api classes'), [], WATCHDOG_ERROR);
  }
  else {
    return new civicrm_api3();
  }
}

/**
 * Determines the settlement currency for a given donation.
 * Argument is a queue message or a civicrm contribution array.
 * TODO: implement hook to determine our actual settlement currency.
 */
function wmf_civicrm_get_settlement_currency($transaction) {
  return 'USD';
}

function wmf_civicrm_get_custom_values($entity_id, $names, $group_name = NULL) {
  $names = (array) $names;
  $params['entityID'] = $entity_id;
  foreach ($names as $name) {
    $field = wmf_civicrm_get_custom_field_name($name, $group_name);
    #var_export( "Custom field mapping: {$name} -> {$field}" );
    $params[$field] = 1;
    $field_map[$field] = $name;
  }
  $result = CRM_Core_BAO_CustomValueTable::getValues($params);
  $ret = [];
  foreach ($result as $field => $value) {
    if (array_key_exists($field, $field_map)) {
      $ret[$field_map[$field]] = $value;
    }
  }
  return $ret;
}

/**
 * @param $entity_id
 * @param $map
 * @param null $group_name
 *
 * @throws \WmfException
 * @deprecated
 *
 * Phase this out as it is does some unecessary queries.
 *
 */
function wmf_civicrm_set_custom_field_values($entity_id, $map, $group_name = NULL) {
  $params = [
    'entityID' => $entity_id,
  ];
  $custom_fields =
    wmf_civicrm_get_custom_field_map(array_keys($map), $group_name);
  foreach ($map as $field_name => $value) {
    $params[$custom_fields[$field_name]] = $value;
  }
  $result = CRM_Core_BAO_CustomValueTable::setValues($params);
  if (!empty($result['is_error'])) {
    throw new WmfException(WmfException::CIVI_CONFIG,
      t('Failed to set custom values: id !id, error: !err', [
        '!id' => $entity_id,
        '!err' => $result['error_message'],
      ])
    );
  }
}

function wmf_civicrm_get_custom_field_map($field_names, $group_name = NULL) {
  static $custom_fields = [];
  foreach ($field_names as $name) {
    if (empty($custom_fields[$name])) {
      $id = CRM_Core_BAO_CustomField::getCustomFieldID($name, $group_name);
      $custom_fields[$name] = "custom_{$id}";
    }
  }

  return $custom_fields;
}

function wmf_civicrm_get_custom_field_name($field_name, $group_name = NULL) {
  $custom_fields = wmf_civicrm_get_custom_field_map([$field_name], $group_name);
  return $custom_fields[$field_name];
}

/**
 * Try to import a transaction message into CiviCRM, otherwise
 * throw an exception.
 *
 * @param array $msg
 *
 * @return array Contribution as inserted
 *
 * @throws \WmfException
 */
function wmf_civicrm_contribution_message_import(&$msg) {
  $timer = ImportStatsCollector::getInstance();
  $timer->init();

  if (empty($msg['recurring'])) {
    $overallTimerName = "wmf_civicrm_contribution_message_import";
  }
  else {
    $overallTimerName = "wmf_civicrm_recurring_message_import";
  }
  $timer->startImportTimer($overallTimerName);
  civicrm_initialize();

  $timer->startImportTimer("verify_and_stage");
  $msg = wmf_civicrm_verify_message_and_stage($msg);
  $timer->endImportTimer("verify_and_stage");

  $createRecurringToken = false;
  // Associate with existing recurring records
  if ($msg['recurring'] && !$msg['contribution_recur_id']) {
    if (!empty($msg['recurring_payment_token'])) {
      $timer->startImportTimer("get_recurring_payment_token");
      $token_record = wmf_civicrm_get_recurring_payment_token(
        $msg['gateway'], $msg['recurring_payment_token']
      );
      $timer->endImportTimer("get_recurring_payment_token");
      if ($token_record) {
        watchdog(
          'queue2civicrm_import',
          'Found matching recurring payment token: ' . $msg['recurring_payment_token'],
          NULL,
          WATCHDOG_INFO
        );
        $msg['contact_id'] = $token_record['contact_id'];
        $msg['payment_token_id'] = $token_record['id'];
        $msg['payment_processor_id'] = $token_record['payment_processor_id'];
      } else {
        // When there is a token on the $msg but not in the db
        $createRecurringToken = true;
      }
    }
    elseif ($msg['subscr_id']) {
      $timer->startImportTimer("get_gateway_subscription");
      $recur_record = wmf_civicrm_get_gateway_subscription($msg['gateway'], $msg['subscr_id']);
      $timer->endImportTimer("get_gateway_subscription");
      if ($recur_record) {
        watchdog('queue2civicrm_import', 'Found matching recurring record for subscr_id: ' . $msg['subscr_id'], NULL, WATCHDOG_INFO);
        $msg['contribution_recur_id'] = $recur_record->id;
        $msg['contact_id'] = $recur_record->contact_id;
      }
    }
    else {
      throw new WmfException(WmfException::INVALID_MESSAGE, 'Recurring donation, but no subscription ID or recurring payment token found.');
    }
  }
  if ($msg['contact_id'] && isset($msg['contact_hash'])) {
    wmf_civicrm_set_null_id_on_hash_mismatch($msg, TRUE);
  }

  if (variable_get('match_on_import')) {
    if (!$msg['contact_id'] && !empty($msg['first_name'] && !empty($msg['last_name']) && !empty($msg['email']))) {
      // Check for existing....
      $matches = Email::get(FALSE)
        ->addWhere('contact.first_name', '=', $msg['first_name'])
        ->addWhere('contact.last_name', '=', $msg['last_name'])
        ->addWhere('contact.is_deleted', '=', 0)
        ->addWhere('contact.is_deceased', '=', 0)
        ->addWhere('email', '=', $msg['email'])
        ->addWhere('is_primary', '=', TRUE)
        ->setSelect(['contact_id'])
        ->setLimit(2)
        ->execute();
      if (count($matches) === 1) {
        $msg['contact_id'] = $matches->first()['contact_id'];
      }
    }
  }
  if (!$msg['contact_id']) {
    $timer->startImportTimer("create_contact");
    wmf_civicrm_message_create_contact($msg);
    $timer->endImportTimer("create_contact");
  }
  else {
    // @todo Do not solicit appears like these fields but is a custom field. Not handled yet as not in the import
    // this was written (& tested) in conjunction with (Engage).
    $updateFields = ['do_not_email', 'do_not_mail', 'do_not_trade', 'do_not_phone', 'is_opt_out', 'do_not_sms'];
    $updateParams = array_intersect_key($msg, array_fill_keys($updateFields, TRUE));;

    if (isset($msg['employer_id'])) {
      $updateParams['employer_id'] = $msg['employer_id'];
    }
    if (!empty($updateParams)) {
      $updateParams['contact_id'] = $msg['contact_id'];
      civicrm_api3('Contact', 'create', $updateParams);
    }

    // We have set the bar for invoking a location update fairly high here - ie state,
    // city or postal_code is not enough, as historically this update has not occurred at
    // all & introducing it this conservatively feels like a safe strategy.
    if (!empty($msg['street_address'])) {
      $timer->startImportTimer("message_location_update");
      wmf_civicrm_message_location_update($msg, ['id' => $msg['contact_id']]);
      $timer->endImportTimer("message_location_update");
    }
    elseif (!empty($msg['email'])) {
      // location_update updates email, if set and address, if set.
      // However, not quite ready to start dealing with the situation
      // where less of the address is incoming than already exists
      // hence only call this part if street_address is empty.
      $timer->startImportTimer("message_email_update");
      wmf_civicrm_message_email_update($msg, $msg['contact_id']);
      $timer->endImportTimer("message_email_update");
    }
  }

  // Create recurring token if it isn't already there
  // Audit files bring in recurrings that we have the token for but were never created
  if ($createRecurringToken) {
    $token_record = wmf_civicrm_recur_payment_token_create($msg['contact_id'], $msg['gateway'], $msg['recurring_payment_token'], $msg['user_ip']);
    watchdog(
      'queue2civicrm_import',
      'No payment token found. Creating : ' . $token_record['id'],
      NULL,
      WATCHDOG_INFO
    );
    $msg['payment_token_id'] = $token_record['id'];
    $msg['payment_processor_id'] = $token_record['payment_processor_id'];
  }

  // Make new recurring record if necessary
  $initial_recurring = ($msg['recurring'] && !$msg['contribution_recur_id']);
  if ($initial_recurring) {
    $recurring_transaction_id = "";
    if ($msg['subscr_id']) {
      // FIXME: level across processors
      if ($msg['gateway'] === 'globalcollect') {
        if (FALSE === strpos($msg['subscr_id'], 'RECURRING GLOBALCOLLECT')) {
          $msg['subscr_id'] = "RECURRING GLOBALCOLLECT {$msg['subscr_id']}";
        }
      }
      $recurring_transaction_id = $msg['subscr_id'];
    }

    if (!empty($msg['recurring_payment_token'])) {
      $recurring_transaction_id = $msg['gateway_txn_id'];
    }

    watchdog('queue2civicrm_import', 'Attempting to insert new recurring subscription: ' . $recurring_transaction_id, NULL, WATCHDOG_INFO);
    $timer->startImportTimer("message_contribution_recur_insert");
    wmf_civicrm_message_contribution_recur_insert($msg, $msg['contact_id'], $recurring_transaction_id);
    $timer->endImportTimer("message_contribution_recur_insert");
    $recur_record = wmf_civicrm_get_gateway_subscription($msg['gateway'], $recurring_transaction_id);
    $msg['contribution_recur_id'] = $recur_record->id;
  }

  // Look up soft credit contact.
  if (!empty($msg['soft_credit_to'])) {

    $soft_credit_contact = civicrm_api3('Contact', 'Get', [
      'organization_name' => $msg['soft_credit_to'],
      'sequential' => 1,
      'return' => 'id',
    ]);
    if ($soft_credit_contact['count'] !== 1) {
      throw new WmfException(
        WmfException::INVALID_MESSAGE,
        "Bad soft credit target, [${msg['soft_credit_to']}]"
      );
    }
    # FIXME: awkward to have the two fields.
    $msg['soft_credit_to_id'] = $soft_credit_contact['id'];
  }

  // Set no_thank_you to recurring if its the 2nd+ of any recurring payments
  if (!$initial_recurring && $msg['contribution_recur_id']) {
    //check for previous recurring payments
    $recurring_check = civicrm_api3('Contribution', 'getcount', [
      'contribution_recur_id' => $msg['contribution_recur_id'],
    ]);

    //If there's at least 1, set no_thank_you to recurring
    if ($recurring_check >= 1) {
      $msg['no_thank_you'] = 'recurring';
    }
  }

  // Insert the contribution record.
  $timer->startImportTimer("message_contribution_insert");
  $contribution = _wmf_civicrm_message_contribution_insert($msg);
  $timer->endImportTimer("message_contribution_insert");

  if (wmf_civicrm_should_update_contribution_tracking($msg, $initial_recurring)) {
    // Map the tracking record to the CiviCRM contribution
    // @FIXME what do we do if this returns false?  nothing at the moment...
    wmf_civicrm_message_update_contribution_tracking($msg, $contribution);
  }

  if (!empty($msg['notes'])) {
    // TODO: Handle failure.
    civicrm_api3("Note", "Create", [
      'entity_table' => 'civicrm_contact',
      'entity_id' => $msg['contact_id'],
      'note' => $msg['notes'],
    ]);
  }

  $timer->endImportTimer($overallTimerName);
  $timer->deinit();
  return $contribution;
}

/**
 * Checks for contact ID and hash match.  If mismatched unset
 * ID and hash so message is treated as a new contact.
 *
 * @param $msg
 * @param $matchEmail
 *
 * @throws CiviCRM_API3_Exception
 */
function wmf_civicrm_set_null_id_on_hash_mismatch(&$msg, $matchEmail = FALSE) {
  $existing = civicrm_api3('Contact', 'getSingle', [
    'id' => $msg['contact_id'],
    'return' => ['hash', 'email'],
  ]);

  if (!$existing || $existing['hash'] !== $msg['contact_hash'] ||
    ($existing['email'] !== $msg['email'] && $matchEmail)) {
    $msg['contact_id'] = NULL;
    unset($msg['contact_hash']);
  }
}

/**
 * Create a contact from the $msg array and set the contact_id.
 *
 * @param array $msg
 *   Normalised wmf msg array.
 *
 * @throws \WmfException
 */
function wmf_civicrm_message_create_contact(&$msg) {
  $contact = wmf_civicrm_message_contact_insert($msg);
  $msg['contact_id'] = $contact['id'];
}

/**
 * Insert the contribution record.
 *
 * This is an internal method, you must be looking for
 *
 * @param array $msg
 *
 * @return array
 *
 * @throws \WmfException
 * @see wmf_civicrm_contribution_message_import.
 *
 */
function _wmf_civicrm_message_contribution_insert($msg) {
  $transaction = WmfTransaction::from_message($msg);
  $trxn_id = $transaction->get_unique_id();


  $contribution = [
    'contact_id' => $msg['contact_id'],
    'total_amount' => $msg['gross'],
    // CiviCRM supports financial_type_id rather than contribution_type_id now. Handling both here
    // is a first step to deprecating contribution_type_id.
    'financial_type_id' => empty($msg['financial_type_id']) ? $msg['contribution_type_id'] : $msg['financial_type_id'],
    'payment_instrument_id' => $msg['payment_instrument_id'],
    'fee_amount' => $msg['fee'],
    'net_amount' => $msg['net'],
    'trxn_id' => $trxn_id,
    'receive_date' => wmf_common_date_unix_to_civicrm($msg['date']),
    'currency' => $msg['currency'],
    'source' => $msg['original_currency'] . ' ' . $msg['original_gross'],
    'contribution_recur_id' => $msg['contribution_recur_id'],
    'check_number' => $msg['check_number'],
    'soft_credit_to' => $msg['soft_credit_to_id'],
    'debug' => TRUE,
  ];

  // Add the thank you date when it exists and is not null (e.g.: we're importing from a check)
  if (array_key_exists('thankyou_date', $msg) && is_numeric($msg['thankyou_date'])) {
    $contribution['thankyou_date'] = wmf_common_date_unix_to_civicrm($msg['thankyou_date']);
  }

  // Store the identifier we generated on payments
  $invoice_fields = ['invoice_id', 'order_id'];
  foreach ($invoice_fields as $invoice_field) {
    if (!empty($msg[$invoice_field])) {
      $contribution['invoice_id'] = $msg[$invoice_field];
      // The invoice_id column has a unique constraint
      if ($msg['recurring']) {
        $contribution['invoice_id'] .= '|recur-' . UtcDate::getUtcTimestamp();
      }
      break;
    }
  }

  /**
   *  Hopefully the Civi API will eventually handle custom fields in the
   *  above "Create" call.
   *
   * NOTE: the custom field for "Gift_Information" indicates that check number is stored here.  It is not.
   */
  $custom_field_defaults = [
    // Contribution_comments field does not appear to exist & is quietly ignored I believe.
    'Contribution_Comments' => '',
    'gateway_account' => '',
  ];
  if ($contribution['total_amount'] >= 1000) {
    $custom_field_defaults['Campaign'] = 'Benefactor Gift';
  }

  // Legacy field names which do not match the message field names
  $custom_name_mangle = [
    'comment' => 'Contribution_Comments',
    'direct_mail_appeal' => 'Appeal',
    'gift_source' => 'Campaign',
    'postmark_date' => 'Postmark_Date',
    'restrictions' => 'Fund',
    'stock_description' => 'Description_of_Stock',
    'gateway_status' => 'gateway_status_raw',
  ];

  // Custom fields with names that match the message fields.
  $custom_name_passthrough = [
    'gateway_account',
    'import_batch_number',
    'no_thank_you',
    'source_name',
    'source_type',
    'source_host',
    'source_run_id',
    'source_version',
    'source_enqueued_time',
  ];

  $custom_fields = $custom_name_mangle
    + array_combine($custom_name_passthrough, $custom_name_passthrough);

  $custom_vars = [];
  foreach ($custom_fields as $msg_key => $custom_key) {
    if (array_key_exists($msg_key, $msg)) {
      $custom_vars[$custom_key] = $msg[$msg_key];
    }
  }

  // Transform any unix timestamps into an unambiguous MySQL datetime literal.
  // If the date is already in mysql format, it will be 14 characters long:
  // YYYYmmddHHiiss :-/
  $date_mangle = [
    'Postmark_Date',
    'source_enqueued_time',
  ];
  foreach ($date_mangle as $field) {
    if (array_key_exists($field, $custom_vars)
      && is_numeric($custom_vars[$field])
      && strlen($custom_vars[$field]) < 14
    ) {
      $custom_vars[$field] = wmf_common_date_unix_to_sql($custom_vars[$field]);
    }
  }

  $custom_vars += $custom_field_defaults;

  $custom_name_mapping = wmf_civicrm_get_custom_field_map(array_keys($custom_vars));
  foreach ($custom_name_mapping as $readable => $machined) {
    if (array_key_exists($readable, $custom_vars)) {
      $contribution[$machined] = $custom_vars[$readable];
    }
  }

  watchdog('wmf_civicrm', 'Contribution array for civicrm_contribution_add(): ' . print_r($contribution, TRUE), NULL, WATCHDOG_DEBUG);
  try {
    $contribution_result = civicrm_api3('Contribution', 'Create', array_merge($contribution, ['skipRecentView' => 1]));
    watchdog('wmf_civicrm', "Successfully created contribution {$contribution_result['id']} for contact  {$contribution['contact_id']}", NULL, WATCHDOG_DEBUG);
  }
  catch (CiviCRM_API3_Exception $e) {
    watchdog('wmf_civicrm', 'Error inserting contribution: ' . $e->getMessage() . ' ' . $e->getCode(), NULL, WATCHDOG_INFO);
    // Constraint violations occur when data is rolled back to resolve a deadlock.
    if (in_array($e->getErrorCode(), ['constraint violation', 'deadlock', 'database lock timeout'])) {
      throw new WmfException(WmfException::DATABASE_CONTENTION, 'Contribution not saved due to database load', $e->getExtraParams());
    }

    $duplicate = 0;

    try {
      if (array_key_exists('invoice_id', $contribution)) {
        watchdog('wmf_civicrm', 'Checking for duplicate on invoice ID ' . $contribution['invoice_id'], NULL, WATCHDOG_INFO);
        $invoice_id = $contribution['invoice_id'];
        $duplicate = civicrm_api3("Contribution", "getcount", ["invoice_id" => $invoice_id]);
      }
      if ($duplicate > 0) {
        // We can't retry the insert here because the original API
        // error has marked the Civi transaction for rollback.
        // This WmfException code has special handling in the
        // WmfQueueConsumer that will alter the invoice_id before
        // re-queueing the message.
        throw new WmfException(
          WmfException::DUPLICATE_INVOICE,
          'Duplicate invoice ID, should modify and retry',
          $e->getExtraParams()
        );
      }
      else {
        throw new WmfException(
          WmfException::INVALID_MESSAGE,
          'Cannot create contribution, civi error!',
          $e->getExtraParams()
        );
      }
    }
    catch (CiviCRM_API3_Exception $eInner) {
      throw new WmfException(
        WmfException::INVALID_MESSAGE,
        'Cannot create contribution, civi error!',
        $eInner->getExtraParams()
      );
    }
  }

  // Create any required tags on the contribution
  if ($msg['contribution_tags']) {
    $supported_tags = array_flip(CRM_Core_BAO_Tag::getTags('civicrm_contribution'));
    $stacked_ex = [];
    foreach (array_unique($msg['contribution_tags']) as $tag) {
      try {
        $tag_result = civicrm_api3("EntityTag", "Create", [
          'entity_table' => 'civicrm_contribution',
          'entity_id' => $contribution_result['id'],
          'tag_id' => $supported_tags[$tag],
        ]);
      }
      catch (CiviCRM_API3_Exception $ex) {
        $stacked_ex[] = "Failed to add tag {$tag} to contribution ID {$contribution_result['id']}. Error: " . $ex->getMessage();
      }
    }
    if (!empty($stacked_ex)) {
      throw new WmfException(
        WmfException::IMPORT_CONTRIB,
        implode("\n", $stacked_ex)
      );
    }
  }

  return $contribution_result['values'][$contribution_result['id']];
}

/**
 * Translate option value to CiviCRM id.
 *
 * Note that in general we do not need to translate these names to ids as the
 * CiviCRM api does that. This allows us to add additional error checking,
 * although possibly for not much gain.
 *
 * @param string $type
 * @param $name
 *
 * @return bool
 */
function wmf_civicrm_get_civi_id($type, $name) {
  static $civi_ids = [];
  $params = ['name' => $name];
  $dummy = [];

  if (array_key_exists($type, $civi_ids) && array_key_exists($name, $civi_ids[$type])) {
    return $civi_ids[$type][$name];
  }

  switch ($type) {
    case 'contribution_type_id':
    case 'financial_type_id':
      //fixme: This is probably the upside-down way to do it. Really ought to go through the API.
      //
      $result = CRM_Financial_BAO_FinancialType::retrieve($params, $dummy);
      if (!is_null($result)) {
        $civi_ids[$type][$name] = $result->id;
        watchdog('wmf_civicrm', "Found id for contribution_type $name: " . $civi_ids[$type][$name]);
      }
      else {
        //make it. Or, throw an error here. Either way.
        //XXX nonono
        watchdog('wmf_civicrm', "Id for contribution_type $name not found. Creating...");
        $params['description'] = '';
        $params['accounting_code'] = strtoupper($name);
        $params['is_deductible'] = 1;
        $params['is_active'] = 1;
        $result = CRM_Financial_BAO_FinancialType::add($params, $dummy);
        $civi_ids[$type][$name] = $result->id;
        watchdog('wmf_civicrm', "New id for contribution_type $name :" . $civi_ids[$type][$name]);
      }
      $id = $civi_ids[$type][$name];
      if (empty($id)) {
        throw new WmfException(WmfException::CIVI_CONFIG,
          t('Contribution Type "!name" not found!', ['!name' => $name])
        );
      }
      return $id;
    case 'payment_instrument_id':
      $instruments = civicrm_api3('Contribution', 'getoptions', ['field' => 'payment_instrument_id']);
      return array_search($name, $instruments['values']);
      break;

    default:
      throw new WmfException(WmfException::CIVI_CONFIG, t("Civi lookup for type '!type' not implemented", ["!type" => $type]));
  }
}

function wmf_civicrm_get_message_contribution_type($msg) {
  $gateway = strtolower($msg['gateway']);
  if ($gateway === 'merkle') {
    return 'merkle';
  }
  elseif ($gateway === 'arizonalockbox') {
    return 'Arizona Lockbox';
  }
  else {
    return 'cash';
  }
}

/**
 * Determines which civi-only payment instrument is appropriate for the current
 * message, and returns the civi payment instrument's human-readable display
 * string (if it exists).
 *
 * TODO lookup table
 *
 * @return string payment instrument label
 */
function wmf_civicrm_get_message_payment_instrument($msg) {
  civicrm_initialize();

  $payment_instrument = NULL;

  if (isset($msg['raw_payment_instrument'])) {
    return $msg['raw_payment_instrument'];
  }

  if (array_key_exists('payment_method', $msg) && trim($msg['payment_method']) != '') {

    switch (strtolower($msg['payment_method'])) {
      case 'check':
        $payment_instrument = 'Check';
        break;
      case 'bt':
        $payment_instrument = 'Bank Transfer';
        switch (strtolower($msg['payment_submethod'])) {
          // India
          case 'netbanking':
            $payment_instrument .= ': Netbanking';
            break;
          case 'paytmwallet':
            $payment_instrument .= ': PayTM Wallet';
            break;
          case 'upi':
            $payment_instrument .= ': UPI';
            break;
        }
        break;
      case 'cc':
        $payment_instrument = 'Credit Card';
        if (empty($msg['payment_submethod'])) {
          watchdog('wmf_civicrm', 'No credit card submethod given', NULL, WATCHDOG_WARNING);
          break;
        }
        switch (strtolower($msg['payment_submethod'])) {
          case 'visa':
            $payment_instrument .= ': Visa';
            break;
          case 'visa-beneficial':
            $payment_instrument .= ': Visa Beneficial';
            break;
          case 'visa-electron':
            $payment_instrument .= ': Visa Electron';
            break;
          case 'visa-debit':
            $payment_instrument .= ': Visa Debit';
            break;
          case 'mc':
            $payment_instrument .= ': MasterCard';
            break;
          case 'mc-debit':
            $payment_instrument .= ': MasterCard Debit';
            break;
          case 'amex':
            $payment_instrument .= ': American Express';
            break;
          case 'maestro':
            $payment_instrument .= ': Maestro';
            break;
          case 'solo':
            $payment_instrument .= ': Solo';
            break;
          case 'laser':
            $payment_instrument .= ': Laser';
            break;
          case 'jcb':
            $payment_instrument .= ': JCB';
            break;
          case 'discover':
            $payment_instrument .= ': Discover';
            break;
          case 'cb':
            $payment_instrument .= ': Carte Bleue';
            break;
          case 'cmr':
            $payment_instrument .= ': CMR Falabella';
            break;
          case 'diners':
            $payment_instrument .= ': Diners';
            break;
          case 'elo':
            $payment_instrument .= ': Elo';
            break;
          case 'hiper':
            $payment_instrument .= ': HiperCard';
            break;
          case 'magna':
            $payment_instrument .= ': Magna';
            break;
          case 'mercadolivre':
            $payment_instrument .= ': MercadoLivre';
            break;
          case 'presto':
            $payment_instrument .= ': Presto';
            break;
          case 'cabal':
            $payment_instrument .= ': Cabal';
            break;
          case 'naranja':
            $payment_instrument .= ': Naranja';
            break;
          case 'shopping':
            $payment_instrument .= ': Tarjeta Shopping';
            break;
          case 'nativa':
            $payment_instrument .= ': Nativa';
            break;
          case 'cencosud':
            $payment_instrument .= ': Cencosud';
            break;
          case 'argen':
            $payment_instrument .= ': Argencard';
            break;
          case 'webpay':
            $payment_instrument .= ': Webpay';
            break;
          case 'bij':
            $payment_instrument .= ': Bijenkorf';
            break;
          case 'lider':
            $payment_instrument .= ': Lider';
            break;
          case 'oca':
            $payment_instrument .= ': OCA';
            break;
          // India
          case 'rupay':
            $payment_instrument .= ': RuPay';
            break;
        }
        break;
      case 'dd':
        $payment_instrument = 'Direct Debit';
        break;
      case 'eft':
        $payment_instrument = 'EFT';
        break;
      case 'ew':
        switch (strtolower($msg['payment_submethod'])) {
          case 'ew_paypal':
            $payment_instrument = 'Paypal';
            break;
          case 'ew_webmoney':
            $payment_instrument = 'Webmoney';
            break;
          case 'ew_moneybookers':
            $payment_instrument = 'Moneybookers';
            break;
          case 'ew_cashu':
            $payment_instrument = 'Cashu';
            break;
          case 'ew_yandex':
            $payment_instrument = 'Yandex';
            break;
          case 'ew_alipay':
            $payment_instrument = 'Alipay';
            break;
        }
        break;
      case 'obt':
        if (strtolower($msg['payment_submethod'] === 'bpay')) {
          $payment_instrument = 'Bpay';
        }
        break;
      case 'rtbt':
        switch (strtolower($msg['payment_submethod'])) {
          case 'rtbt_nordea_sweden':
            $payment_instrument = 'Nordea';
            break;
          case 'rtbt_ideal':
            $payment_instrument = 'iDeal';
            break;
          case 'rtbt_enets':
            $payment_instrument = 'Enets';
            break;
          case 'rtbt_sofortuberweisung':
            $payment_instrument = 'Sofort';
            break;
          case 'rtbt_eps':
            $payment_instrument = 'EPS';
            break;
        }
        break;
      case 'stock':
        $payment_instrument = 'Stock';
        break;
      case 'cash':
        $payment_instrument = 'Cash';
        if (empty($msg['payment_submethod'])) {
          watchdog('wmf_civicrm', 'No cash submethod given', NULL, WATCHDOG_WARNING);
          break;
        }
        switch (strtolower($msg['payment_submethod'])) {
          case 'cash_boleto':
            $payment_instrument = 'Boleto';
            break;
          case 'cash_banamex':
            $payment_instrument = 'Banamex';
            break;
          case 'cash_bancomer':
            $payment_instrument = 'Bancomer';
            break;
          case 'cash_davivienda':
            $payment_instrument = 'Davivienda';
            break;
          case 'cash_efecty':
            $payment_instrument = 'Efecty';
            break;
          case 'cash_oxxo':
            $payment_instrument = 'OXXO';
            break;
          case 'cash_pago_facil':
            $payment_instrument = 'Pago Facil';
            break;
          case 'cash_provencia_pagos':
            $payment_instrument = 'Provencia Pagos';
            break;
          case 'cash_red_pagos':
            $payment_instrument = 'Red Pagos';
            break;
          case 'cash_rapipago':
            $payment_instrument = 'Rapi Pago';
            break;
          case 'cash_santander':
            $payment_instrument = 'Santander';
            break;
        }
        break;
      case 'payflowpro':
        if (strtolower($msg['gateway']) === 'payflowpro') {
          $payment_instrument = 'Credit Card';
        }
        break;

      case 'trilogy':
        $payment_instrument = 'Trilogy';
        break;
    }

  }
  if (!$payment_instrument
    and array_key_exists('gateway', $msg)
  ) {
    switch (strtolower($msg['gateway'])) {
      case 'amazon':
        $payment_instrument = 'Amazon';
        if (array_key_exists('payment_method', $msg) and strtolower($msg['payment_method']) !== 'amazon') {
          watchdog('wmf_civicrm', 'payment_method constraint violated: gateway Amazon, but method=@method ; gateway_txn_id=@id', [
            '@method' => $msg['payment_method'],
            '@id' => $msg['gateway_txn_id'],
          ], WATCHDOG_DEBUG);
        }
        break;
      case 'paypal':
      case 'paypal_ec':
        // These PayPal flows are distinct gateway classes, but are
        // recorded together.  They might share an account, although the
        // configuration will have to be broken up across gateway globals.
        $payment_instrument = 'Paypal';
        // FIXME: Case is spelled "PayPal", but existing records must be
        // migrated when we do that.

        // Validate method if provided.
        if (array_key_exists('payment_method', $msg) and strtolower($msg['payment_method']) !== 'paypal') {
          watchdog('wmf_civicrm', 'payment_method constraint violated: gateway Paypal, but method=@method ; gateway_txn_id=@id', [
            '@method' => $msg['payment_method'],
            '@id' => $msg['gateway_txn_id'],
          ], WATCHDOG_DEBUG);
        }
        break;
      case 'square':
        $payment_instrument = 'Square Cash';
        if (array_key_exists('payment_method', $msg) and strtolower($msg['payment_method']) !== 'square') {
          watchdog('wmf_civicrm', 'payment_method constraint violated: gateway Square, but method=@method ; gateway_txn_id=@id', [
            '@method' => $msg['payment_method'],
            '@id' => $msg['gateway_txn_id'],
          ], WATCHDOG_DEBUG);
        }
        break;
      case 'trilogy':
        $payment_instrument = 'Trilogy';
        if (array_key_exists('payment_method', $msg) and strtolower($msg['payment_method']) !== 'trilogy') {
          watchdog('wmf_civicrm', 'payment_method constraint violated: gateway Trilogy, but method=@method ; gateway_txn_id=@id', [
            '@method' => $msg['payment_method'],
            '@id' => $msg['gateway_txn_id'],
          ], WATCHDOG_DEBUG);
        }
        break;
    }
  }

  //I was going to check to make sure the target gateway was a real thing, but: Hello, overhead. No.
  return $payment_instrument;
}

/**
 * Normalize contribution amounts
 *
 * Do exchange rate conversions and set appropriate fields for CiviCRM
 * based on information contained in the message.
 *
 * Upon exiting this function, the message is guaranteed to have these fields:
 *    currency - settlement currency
 *    original_currency - currency remitted by the donor
 *    gross - settled total amount
 *    original_gross - remitted amount in original currency
 *    fee - processor fees, when available
 *    net - gross less fees
 *
 * @param $msg
 *
 * @return array
 * @throws \WmfException
 */
function wmf_civicrm_normalize_contribution_amounts($msg) {
  $msg = wmf_civicrm_format_currency_fields($msg);

  // If there is anything fishy about the amount...
  if ((empty($msg['gross']) or empty($msg['currency']))
    and (empty($msg['original_gross']) or empty($msg['original_currency']))
  ) {
    // just... don't
    watchdog('wmf_civicrm', 'Not freaking out about non-monetary message.',
      NULL, WATCHDOG_INFO);
    return $msg;
  }

  if (empty($msg['original_currency']) && empty($msg['original_gross'])) {
    $msg['original_currency'] = $msg['currency'];
    $msg['original_gross'] = $msg['gross'];
  }

  $validFee = array_key_exists('fee', $msg) && is_numeric($msg['fee']);
  $validNet = array_key_exists('net', $msg) && is_numeric($msg['net']);
  if (!$validFee && !$validNet) {
    $msg['fee'] = '0.00';
    $msg['net'] = $msg['gross'];
  }
  elseif ($validNet && !$validFee) {
    $msg['fee'] = $msg['gross'] - $msg['net'];
  }
  elseif ($validFee && !$validNet) {
    $msg['net'] = $msg['gross'] - $msg['fee'];
  }

  $settlement_currency = wmf_civicrm_get_settlement_currency($msg);
  if ($msg['currency'] !== $settlement_currency) {
    watchdog('wmf_civicrm', 'Converting to settlement currency: %old -> %new',
      ['%old' => $msg['currency'], '%new' => $settlement_currency],
      WATCHDOG_INFO);
    try {
      $settlement_convert = exchange_rate_convert($msg['original_currency'], 1, $msg['date']) / exchange_rate_convert($settlement_currency, 1, $msg['date']);
    }
    catch (ExchangeRatesException $ex) {
      throw new WmfException(WmfException::INVALID_MESSAGE, "UNKNOWN_CURRENCY: '{$msg['original_currency']}': " . $ex->getMessage());
    }

    // Do exchange rate conversion
    $msg['currency'] = $settlement_currency;
    $msg['fee'] = $msg['fee'] * $settlement_convert;
    $msg['gross'] = $msg['gross'] * $settlement_convert;
    $msg['net'] = $msg['net'] * $settlement_convert;
  }

  $msg['fee'] = CurrencyRoundingHelper::round($msg['fee'], $msg['currency']);
  $msg['gross'] = CurrencyRoundingHelper::round($msg['gross'], $msg['currency']);
  $msg['net'] = CurrencyRoundingHelper::round($msg['net'], $msg['currency']);

  return $msg;
}

/**
 * Format currency fields in passed array.
 *
 * Currently we are just stripping out commas on the assumption they are a
 * thousand separator and unhelpful.
 *
 * @param array $values
 * @param array $currencyFields
 *
 * @return array
 */
function wmf_civicrm_format_currency_fields($values, $currencyFields = [
  'gross',
  'fee',
  'net',
]) {
  foreach ($currencyFields as $field) {
    if (isset($values[$field])) {
      $values[$field] = str_replace(',', '', $values[$field]);
    }
  }
  return $values;
}

function wmf_civicrm_verify_message_and_stage($msg) {
  $msg = wmf_civicrm_normalize_msg($msg);

  $required = [
    'gross',
    'currency',
    'gateway',
    'gateway_txn_id',
  ];

  $err = [];
  foreach ($required as $key) {
    if (empty($msg[$key])) {
      $err[] = "Required Field '$key' not found in message.";
    }
  }

  if (floatval($msg['net']) <= 0 || floatval($msg['gross']) <= 0) {
    $err[] = "Positive amount required.";
  }

  if (!empty($err)) {
    throw new WmfException(WmfException::CIVI_REQ_FIELD, $err);
  }

  $max_lengths = [
    'check_number' => 255,
    'city' => 64,
    'email' => 254,
    'first_name' => 64,
    'last_name' => 64,
    'middle_name' => 64,
    'organization_name' => 128,
    'postal_code' => 64,
    'street_address' => 96,
    'supplemental_address_1' => 96,
    'supplemental_address_2' => 96,
  ];
  $truncate_tags = [
    'postal_code' => 'AddressTruncated',
    'street_address' => 'AddressTruncated',
    'supplemental_address_1' => 'AddressTruncated',
    'supplemental_address_2' => 'AddressTruncated',
    'city' => 'AddressTruncated',
  ];
  foreach ($max_lengths as $key => $limit) {
    if (strlen($msg[$key]) > $limit) {
      if (array_key_exists($key, $truncate_tags)) {
        watchdog(
          'wmf_civicrm',
          'Truncating key !key to !len chars. Original: "!val". Applying tag !tag',
          [
            '!key' => $key,
            '!len' => $limit,
            '!val' => $msg[$key],
            '!tag' => $truncate_tags[$key],
          ],
          WATCHDOG_WARNING
        );
        $msg[$key] = mb_substr($msg[$key], 0, $limit);
        $msg['contact_tags'][] = $truncate_tags[$key];
      }
      else {
        throw new WmfException(WmfException::INVALID_MESSAGE, "Field '{$key}' is too long.");
      }
    }
  }

  //Now check to make sure this isn't going to be a duplicate message for this gateway.
  wmf_civicrm_check_for_duplicates($msg['gateway'], $msg['gateway_txn_id']);

  return $msg;
}

/**
 * Throw an exception if a contribution already exists
 *
 * @param string $gateway
 * @param string $gateway_txn_id
 *
 * @throws WmfException
 */
function wmf_civicrm_check_for_duplicates($gateway, $gateway_txn_id) {
  if (CRM_Core_DAO::singleValueQuery(
    'SELECT count(*)
    FROM wmf_contribution_extra cx
    WHERE gateway = %1 AND gateway_txn_id = %2', [
    1 => [$gateway, 'String'],
    2 => [$gateway_txn_id, 'String'],
  ])) {
    throw new WmfException(
      WmfException::DUPLICATE_CONTRIBUTION,
      'Contribution already exists. Ignoring message.'
    );
  }
}

/**
 * Insert the contact record
 *
 * Serves as a standard way for message processors to handle contact
 * insertion.  By passing a contact id, a contact can be updated.
 *
 * @param array $msg
 * @param int $contact_id
 *
 * @return array
 */
function wmf_civicrm_message_contact_insert($msg, $contact_id = NULL) {
  $isCreate = !$contact_id;
  // Set defaults for optional fields in the message
  if (!array_key_exists('contact_type', $msg)) {
    $msg['contact_type'] = "Individual";
  }
  elseif ($msg['contact_type'] != "Individual" && $msg['contact_type'] != "Organization") {
    // looks like an unsupported type was sent, revert to default
    watchdog('wmf_civicrm', 'Non-supported contact_type received: %type', ['%type' => print_r($msg['contact_type'], TRUE)], WATCHDOG_INFO);
    $msg['contact_type'] = "Individual";
  }

  if (!array_key_exists('contact_source', $msg)) {
    $msg['contact_source'] = "online donation";
  }

  // Create the contact record
  $contact = [
    'id' => $contact_id,
    'contact_type' => $msg['contact_type'],
    'contact_source' => $msg['contact_source'],
    'debug' => TRUE,
    // We speed up our imports by passing in this param.
    // going forwards there is scope to a) improve the processing
    // upstream rather than skip & b) not skip for Major Gifts contacts.
    'skip_greeting_processing' => TRUE,
    // Adding updateBlankLocInfo bypasses some unnecessary queries.
    // The queries are intended to ensure that no contact's are without a
    // primary email/address etc. The bug only ever affects updates, not new creates
    // I've been working to remove this bug & the subsequent check
    // entirely (https://lab.civicrm.org/dev/core/-/issues/2039 )
    // but this seems like a quick safe way to remove 10 queries per contact create.
    // see https://github.com/civicrm/civicrm-core/pull/18477/files#diff-a6c74f5d526f1e30491d903548bbc388L67
    // for what it does. If should be temporary as I will keep working on a core fix.
    // It's probably conservative not putting on update as well but create should get most of them
    // without any risk
   'updateBlankLocInfo' => $isCreate,
  ];
  if (strtolower($msg['contact_type']) !== "organization") {
    foreach (['first_name', 'last_name', 'middle_name'] as $name) {
      if (isset($msg[$name])) {
        $contact[$name] = wmf_civicrm_string_clean($msg[$name], 64);
      }
    }
  }

  if (!$contact_id && isset($msg['email']) && wmf_civicrm_is_email_valid($msg['email'])) {
    // For updates we are still using our own process which may or may not confer benefits
    // For inserts however we can rely on the core api.
    $contact['email'] = $msg['email'];
  }
  if (strtolower($msg['contact_type']) == "organization") {
    // @todo probably can remove handling for sort name and display name now.
    $contact['sort_name'] = $msg['organization_name'];
    $contact['display_name'] = $msg['organization_name'];
    $contact['organization_name'] = $msg['organization_name'];
  }
  elseif (!empty($msg['employer_id'])) {
    $contact['employer_id'] = $msg['employer_id'];
  }
  if (!empty($msg['prefix_id:label'])) {
    // prefix_id:label is APIv4 format. name_prefix is our own fandango.
    // We should start migrating to APIv4 format so supporting it
    // is a first step.
    $msg['name_prefix'] = $msg['prefix_id:label'];
  }
  if (!empty($msg['name_prefix'])) {
    $contact['prefix_id'] = $msg['name_prefix'];
    wmf_civicrm_ensure_option_exists($msg['name_prefix'], 'prefix_id', 'individual_prefix');
  }
  if (!empty($msg['name_suffix'])) {
    $contact['suffix_id'] = $msg['name_suffix'];
    wmf_civicrm_ensure_option_exists($msg['name_suffix'], 'suffix_id', 'individual_suffix');
  }
  if (empty($msg['language'])) {
    // TODO: use LanguageTag to prevent truncation of >2 char lang codes
    // guess from contribution_tracking data
    $tracking = wmf_civicrm_get_contribution_tracking($msg);
    if ($tracking and !empty($tracking['language'])) {
      if (strpos($tracking['language'], '-')) {
        // If we are already tracking variant, use that
        [$language, $variant] = explode('-', $tracking['language']);
        $contact['preferred_language'] = $language . '_' . strtoupper($variant);
      }
      else {
        $contact['preferred_language'] = $tracking['language'];
        if (!empty($tracking['country'])) {
          $contact['preferred_language'] .= '_' . $tracking['country'];
        }
      }
    }
    else {
      // FIXME: wish we had the contact_id here :(
      watchdog('wmf_civicrm', 'Failed to guess donor\'s preferred language, falling back to some hideous default', NULL, WATCHDOG_INFO);
    }
  }
  else {
    // If the language is already an existing full locale, don't mangle it
    if (strlen($msg['language']) > 2 && wmf_civicrm_check_language_exists($msg['language'])) {
      $contact['preferred_language'] = $msg['language'];
    } else {
      $contact['preferred_language'] = strtolower(substr($msg['language'], 0, 2));
      if (!empty($msg['country'])) {
        $contact['preferred_language'] .= '_' . strtoupper(substr($msg['country'], 0, 2));
      }
    }
  }
  if (!empty($contact['preferred_language'])) {
    if (!wmf_civicrm_check_language_exists($contact['preferred_language'])) {
      $parts = explode('_', $contact['preferred_language']);
      if (wmf_civicrm_check_language_exists($parts[0])) {
        // in other words en_NO will be converted to en
        // rather than Norwegian English.
        $contact['preferred_language'] = $parts[0];
      }
      else {
        // otherwise let's create it rather than fail.
        // seems like the easiest way not to lose visibility, data or the plot.
        wmf_civicrm_ensure_language_exists($contact['preferred_language']);
      }
    }
  }

  // Copy some fields, if they exist
  $direct_fields = [
    'do_not_email',
    'do_not_mail',
    'do_not_phone',
    'do_not_sms',
    'is_opt_out',
  ];
  foreach ($direct_fields as $field) {
    if (isset($msg[$field])) {
      if (in_array($msg[$field], [0, 1, '0', '1', TRUE, FALSE], TRUE)) {
        $contact[$field] = $msg[$field];
      }
      elseif (strtoupper($msg[$field]) === 'Y') {
        $contact[$field] = TRUE;
      }
    }
  }

  $custom_vars = [];
  $custom_field_mangle = [
    'opt_in' => 'opt_in',
    'do_not_solicit' => 'do_not_solicit',
    'org_contact_name' => 'Name',
    'org_contact_title' => 'Title',
    'employer' => 'Employer_Name',
    // Partner is the custom field's name, Partner is also the custom group's name
    // since other custom fields have names similar to core fields (Partner.Email)
    // this api-similar namespacing convention seems like a good choice.
    'Partner.Partner' => 'Partner',
    'Organization_Contact.Phone' => 'Phone',
    'Organization_Contact.Email' => 'Email',
    // These 2 fields already have aliases but adding
    // additional ones with the new standard allows migration
    // and means that the import file does not have to mix and match.
    'Organization_Contact.Title' => 'Title',
    'Organization_Contact.Name' => 'Name',
  ];
  foreach ($custom_field_mangle as $msgField => $customField) {
    if (isset($msg[$msgField])) {
      $custom_vars[$customField] = $msg[$msgField];
    }
  }

  $custom_name_mapping = wmf_civicrm_get_custom_field_map(array_keys($custom_vars));
  foreach ($custom_name_mapping as $readable => $machined) {
    if (array_key_exists($readable, $custom_vars)) {
      $contact[$machined] = $custom_vars[$readable];
    }
  }

  if (WmfDatabase::isNativeTxnRolledBack()) {
    throw new WmfException(WmfException::IMPORT_CONTACT, "Native txn rolled back before inserting contact");
  }
  // Attempt to insert the contact
  try {
    $contact_result = civicrm_api3('Contact', "Create", $contact);
    if ($contact_id == NULL) {
      watchdog('wmf_civicrm', 'Successfully created contact: %id', ['%id' => $contact_result['id']], WATCHDOG_DEBUG);
    }
    else {
      watchdog('wmf_civicrm', 'Successfully updated contact: %id', ['%id' => $contact_result['id']], WATCHDOG_DEBUG);
    }

    if (WmfDatabase::isNativeTxnRolledBack()) {
      throw new WmfException(WmfException::IMPORT_CONTACT, "Native txn rolled back after inserting contact");
    }
  }
  catch (CiviCRM_API3_Exception $ex) {
    if (in_array($ex->getErrorCode(), ['constraint violation', 'deadlock', 'database lock timeout'])) {
      throw new WmfException(
        WmfException::DATABASE_CONTENTION,
        'Contact could not be added due to database contention',
        $ex->getExtraParams()
      );
    }
    throw new WmfException(
      WmfException::IMPORT_CONTACT,
      'Contact could not be added. Aborting import. Contact data was ' . print_r($contact, TRUE) . ' Original error: ' . $ex->getMessage()
      . ' Details: ' . print_r($ex->getExtraParams(), TRUE),
      $ex->getExtraParams()
    );
  }
  $contact_id = $contact_result['id'];

  // Add phone number
  if (isset($msg['phone'])) {
    try {
      $phone_result = civicrm_api3('Phone', 'Create', [
        // XXX all the fields are nullable, should we set any others?
        'contact_id' => $contact_id,
        'location_type_id' => wmf_civicrm_get_default_location_type_id(),
        'phone' => $msg['phone'],
        'phone_type_id' => 'Phone',
        'is_primary' => 1,
        'debug' => TRUE,
      ]);
    }
    catch (CiviCRM_API3_Exception $ex) {
      throw new WmfException(
        WmfException::IMPORT_CONTACT,
        "Failed to add phone for contact ID {$contact_id}: {$ex->getMessage()} " . print_r($ex->getExtraParams(), TRUE)
      );
    }
  }

  // Add groups to this contact.
  if (!empty($msg['contact_groups'])) {
    // TODO: Use CRM_Contact_GroupContact::buildOptions in Civi 4.4, also
    // in place of ::tag below.
    $supported_groups = array_flip(CRM_Core_PseudoConstant::allGroup());
    $stacked_ex = [];
    foreach (array_unique($msg['contact_groups']) as $group) {
      try {
        $tag_result = civicrm_api3("GroupContact", "Create", [
          'contact_id' => $contact_id,
          'group_id' => $supported_groups[$group],
        ]);
      }
      catch (CiviCRM_API3_Exception $ex) {
        $stacked_ex[] = "Failed to add group {$group} to contact ID {$contact_id}. Error: " . $ex->getMessage();
      }
    }
    if (!empty($stacked_ex)) {
      throw new WmfException(
        WmfException::IMPORT_CONTACT,
        implode("\n", $stacked_ex)
      );
    }
  }

  // Do we have any tags we need to add to this contact?
  if (!empty($msg['contact_tags'])) {
    $supported_tags = array_flip(CRM_Core_BAO_Tag::getTags('civicrm_contact'));
    $stacked_ex = [];
    foreach (array_unique($msg['contact_tags']) as $tag) {
      try {
        $tag_result = civicrm_api3("EntityTag", "Create", [
          'entity_table' => 'civicrm_contact',
          'entity_id' => $contact_id,
          'tag_id' => $supported_tags[$tag],
        ]);
      }
      catch (CiviCRM_API3_Exception $ex) {
        $stacked_ex[] = "Failed to add tag {$tag} to contact ID {$contact_id}. Error: " . $ex->getMessage();
      }
    }
    if (!empty($stacked_ex)) {
      throw new WmfException(
        WmfException::IMPORT_CONTACT,
        implode("\n", $stacked_ex)
      );
    }
  }

  // Create a relationship to an existing contact?
  if (!empty($msg['relationship_target_contact_id'])) {
    $relationship_type = civicrm_api3("RelationshipType", "Get", [
      'name_a_b' => $msg['relationship_type'],
    ]);
    if (!$relationship_type['count']) {
      throw new WmfException(WmfException::IMPORT_CONTACT, "Bad relationship type: {$msg['relationship_type']}");
    }

    try {
      civicrm_api3("Relationship", "Create", [
        'contact_id_a' => $contact_id,
        'contact_id_b' => $msg['relationship_target_contact_id'],
        'relationship_type_id' => $relationship_type['id'],
        'is_active' => 1,
      ]);
    }
    catch (CiviCRM_API3_Exception $ex) {
      throw new WmfException(WmfException::IMPORT_CONTACT, $ex->getMessage());
    }
  }
  if ($isCreate) {
    // Insert the location records if this is being called as a create.
    // For update it's handled in the update routing.
    wmf_civicrm_message_address_insert($msg, $contact_id);
  }
  if (WmfDatabase::isNativeTxnRolledBack()) {
    throw new WmfException(WmfException::IMPORT_CONTACT, "Native txn rolled back after inserting contact auxiliary fields");
  }
  return $contact_result;
}

/**
 * Clean up a string by
 *  - trimming preceding & ending whitespace
 *  - removing any in-string double whitespace
 *
 * @param string $string
 * @param int $length
 *
 * @return string
 */
function wmf_civicrm_string_clean($string, $length) {
  $replacements = [
    // Hex for &nbsp;
    '/\xC2\xA0/' => ' ',
    '/&nbsp;/' => ' ',
    // Replace multiple ideographic space with just one.
    '/(\xE3\x80\x80){2}/' => html_entity_decode("&#x3000;"),
    // Trim ideographic space (this could be done in trim further down but seems a bit fiddly)
    '/^(\xE3\x80\x80)/' => ' ',
    '/(\xE3\x80\x80)$/' => ' ',
    // Replace multiple space with just one.
    '/\s\s+/' => ' ',
    // And html ampersands with normal ones.
    '/&amp;/' => '&',
    '/&Amp;/' => '&',
  ];
  return substr(trim(preg_replace(array_keys($replacements), $replacements, $string)), 0, $length);
}

/**
 * Ensure the selected language is valid in CiviCRM DB.
 *
 * In 4.6 CiviCRM validates preferred_language against the language
 * option_group in the DB.
 *
 * wmf has (at least in the tests) defined these ad hoc.
 * Options are to manage the list of available languages or create them at
 * run time if required. This function does the latter.
 *
 * When retrieved using getoptions it uses a pseudoconstant
 * so, the DB query won't run more than once. I haven't added an
 * extra level of caching into this function at this stage for fear of fragility
 * if it gets updated elsewhere but it could be done.
 *
 * @param string
 *
 * @return mixed
 * @throws \CiviCRM_API3_Exception
 */
function wmf_civicrm_ensure_language_exists($languageAbbreviation) {
  wmf_civicrm_ensure_option_exists($languageAbbreviation, 'preferred_language', 'languages', ['value' => substr($languageAbbreviation, 0, 2)]);
}

/**
 * Check if the language string exists.
 *
 * @param string $languageAbbreviation
 *
 * @return bool
 */
function wmf_civicrm_check_language_exists($languageAbbreviation) {
  $languages = wmf_civicrm_get_valid_languages();
  return !empty($languages[$languageAbbreviation]);
}

/**
 * Get valid languages.
 *
 * @return array
 */
function wmf_civicrm_get_valid_languages() {
  static $languages;
  if (empty($languages)) {
    $available_options = civicrm_api3('Contact', 'getoptions', [
      'field' => 'preferred_language',
    ]);
    $languages = $available_options['values'];
  }
  return $languages;
}

/**
 * Ensure the required option value exists.
 *
 * @param string $option_value
 * @param string $field_name
 * @param string|int $option_group_name
 *   Option group name or option group ID if known
 * @param array $spec
 *   Values for the entity if it is to be created.
 * @param string $entity
 *
 * @throws \CiviCRM_API3_Exception
 */
function wmf_civicrm_ensure_option_exists($option_value, $field_name, $option_group_name, $spec = [], $entity = 'Contact') {
  $available_options = civicrm_api3($entity, 'getoptions', [
    'field' => $field_name,
  ]);
  if ($option_value && empty($available_options['values'][$option_value])) {
    $uniqueParams = [
      'option_group_id' => $option_group_name,
      'name' => $option_value,
    ];
    $checkForInactive = civicrm_api3('OptionValue', 'get', array_merge(['is_active' => 0], $uniqueParams));
    if (!empty($checkForInactive['id'])) {
      $uniqueParams['id'] = $checkForInactive['id'];
    }
    civicrm_api3('OptionValue', 'create', array_merge($uniqueParams, $spec));
  }
}

/**
 * Update the contact record
 *
 * Serves as a standard way for message processors to handle contact
 * updates.
 *
 * @param array $msg
 * @param int $contact_id
 *
 * @return array
 */
function wmf_civicrm_message_contact_update($msg, $contact_id) {
  //FIXME: reverse the way these functions delegate.  Or eliminate -_insert.
  $contact = wmf_civicrm_message_contact_insert($msg, $contact_id);
  // Insert the location record
  // This will be duplicated in some cases in the main message_import, but should
  // not have a negative impact. Longer term it should be removed from here in favour of there.
  wmf_civicrm_message_location_update($msg, $contact);
  return $contact;
}

/**
 * Update the location record
 *
 * Serves as a standard way for message processors to handle location
 * updates.
 *
 * @param array $msg
 * @param array $contact
 */
function wmf_civicrm_message_location_update($msg, $contact) {
  wmf_civicrm_message_email_update($msg, $contact['id']);
  wmf_civicrm_message_address_update($msg, $contact['id']);
}

/**
 * Updates the email for a contact.
 *
 * @param array $msg
 * @param int $contact_id
 *
 * @throws \WmfException
 */
function wmf_civicrm_message_email_update($msg, $contact_id) {
  if (!wmf_civicrm_is_email_valid(CRM_Utils_Array::value('email', $msg))) {
    return;
  }

  try {
    $loc_type_id = isset($msg['email_location_type_id']) ? $msg['email_location_type_id'] : wmf_civicrm_get_default_location_type_id();
    if (!is_numeric($loc_type_id)) {
      $loc_type_id = CRM_Core_PseudoConstant::getKey('CRM_Core_BAO_Email', 'location_type_id', $loc_type_id);
    }
    $isPrimary = isset($msg['email_location_type_id']) ? 0 : 1;

    $emailParams = [
      'email' => $msg['email'],
      'is_primary' => $isPrimary,
      'is_billing' => $isPrimary,
      'contact_id' => $contact_id,
    ];

    // Look up contact's existing email to get the id and to determine
    // if the email has changed.
    $existingEmails = civicrm_api3("Email", 'get', [
      'return' => ['location_type_id', 'email', 'is_primary'],
      'contact_id' => $contact_id,
      'sequential' => 1,
      'options' => ['sort' => 'is_primary'],
    ])['values'];

    if (!empty($existingEmails)) {
      foreach ($existingEmails as $prospectiveEmail) {
        // We will update an existing one if it has the same email or the same
        // location type it, preferring same email+location type id over
        // same email over same location type id.
        if ($prospectiveEmail['email'] === $msg['email']) {
          if (empty($existingEmail)
            || $existingEmail['email'] !== $msg['email']
            || $prospectiveEmail['location_type_id'] == $loc_type_id
          ) {
            $existingEmail = $prospectiveEmail;
          }
        }
        elseif ($prospectiveEmail['location_type_id'] == $loc_type_id) {
          if (empty($existingEmail)) {
            $existingEmail = $prospectiveEmail;
          }
        }
      }

      if (!empty($existingEmail)) {
        if (strtolower($existingEmail['email']) === strtolower($msg['email'])) {
          // If we have the email already it still may make sense
          // to update to primary if this is (implicitly) an update of
          // primary email
          if (!$isPrimary || $existingEmail['is_primary']) {
            return;
          }
        }
        $emailParams['id'] = $existingEmail['id'];
        $emailParams['on_hold'] = 0;
      }
    }

    civicrm_api3('Email', 'create', $emailParams);
  }
  catch (CiviCRM_API3_Exception $e) {
    // Constraint violations occur when data is rolled back to resolve a deadlock.
    $code = (in_array($e->getErrorCode(), ['constraint violation', 'deadlock', 'database lock timeout'])) ? WmfException::DATABASE_CONTENTION : WmfException::IMPORT_CONTACT;
    throw new WmfException($code, "Couldn't store email for the contact.", $e->getExtraParams());
  }
}

/**
 * We do not store empty emails or placeholder emails.
 *
 * @param string $email
 *
 * @return bool
 */
function wmf_civicrm_is_email_valid($email) {
  if (empty($email) || $email === 'nobody@wikimedia.org') {
    return FALSE;
  }
  return TRUE;
}

/**
 * At a minimum, we need a country to store an address
 *
 * @param array $address
 *
 * @return bool
 */
function wmf_civicrm_is_address_valid($address) {
  if (!empty($address['country_id'])) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Update address for a contact.
 *
 * @param array $msg
 * @param int $contact_id
 *
 * @throws \WmfException
 */
function wmf_civicrm_message_address_update($msg, $contact_id) {

  // CiviCRM does a DB lookup instead of checking the pseudoconstant.
  // @todo fix Civi to use the pseudoconstant.
  $country_id = wmf_civicrm_get_country_id($msg['country']);
  $address = [
    'is_primary' => 1,
    'street_address' => $msg['street_address'],
    'supplemental_address_1' => !empty($msg['supplemental_address_1']) ? $msg['supplemental_address_1'] : '',
    'city' => $msg['city'],
    'postal_code' => $msg['postal_code'],
    'country_id' => $country_id,
    'country' => $msg['country'],
    'is_billing' => 1,
    'debug' => 1,
  ];
  if (!empty($msg['state_province'])) {
    $address['state_province'] = $msg['state_province'];
    $address['state_province_id'] = wmf_civicrm_get_state_id($country_id, $msg['state_province']);
  }
  if (!wmf_civicrm_is_address_valid($address)) {
    return;
  }

  $address_params = [
    'contact_id' => $contact_id,
    'location_type_id' => wmf_civicrm_get_default_location_type_id(),
    'values' => [$address],
  ];

  try {
    civicrm_api3('Address', 'replace', $address_params);
  }
  catch (CiviCRM_API3_Exception $e) {
    // Constraint violations occur when data is rolled back to resolve a deadlock.
    $code = $e->getErrorCode() === 'constraint violation' ? WmfException::DATABASE_CONTENTION : WmfException::IMPORT_CONTACT;
    throw new WmfException($code, "Couldn't store address for the contact.", $e->getExtraParams());
  }
}

/**
 * Insert a new address for a contact.
 *
 * If updating or unsure use the marginally slower update function.
 *
 * @param array $msg
 * @param int $contact_id
 *
 * @throws \WmfException
 */
function wmf_civicrm_message_address_insert($msg, $contact_id) {
  $loc_type_id = wmf_civicrm_get_default_location_type_id();

  // We can do these lookups a bit more efficiently than Civi
  $country_id = wmf_civicrm_get_country_id($msg['country']);

  $address_params = [
    'contact_id' => $contact_id,
    'location_type_id' => $loc_type_id,
    'is_primary' => 1,
    'street_address' => $msg['street_address'],
    'supplemental_address_1' => !empty($msg['supplemental_address_1']) ? $msg['supplemental_address_1'] : NULL,
    'city' => $msg['city'],
    'postal_code' => $msg['postal_code'],
    'country_id' => $country_id,
    'country' => $msg['country'],
    'fix_address' => isset($msg['fix_address']) ? $msg['fix_address'] : FALSE,
    'is_billing' => 1,
    'version' => 3,
  ];

  if (!empty($msg['state_province'])) {
    $address_params['state_province'] = $msg['state_province'];
    $address_params['state_province_id'] = wmf_civicrm_get_state_id($country_id, $msg['state_province']);
  }

  if (!wmf_civicrm_is_address_valid($address_params)) {
    return;
  }
  if (WmfDatabase::isNativeTxnRolledBack()) {
    throw new WmfException(WmfException::IMPORT_CONTACT, "Native txn rolled back before inserting address");
  }
  try {
    // @todo - remove this from here & do in pre like this
    // https://issues.civicrm.org/jira/browse/CRM-21786
    // or don't pass fix_address= 0 (but we need to understand performance reasons
    // why we haven't done that.
    CRM_Core_BAO_Address::addGeocoderData($address_params);
    civicrm_api3('Address', 'Create', $address_params);
  }
  catch (CiviCRM_API3_Exception $ex) {
    throw new WmfException(
      WmfException::IMPORT_CONTACT,
      'Couldn\'t store address for the contact: ' .
      $ex->getMessage()
    );
  }

  if (WmfDatabase::isNativeTxnRolledBack()) {
    throw new WmfException(WmfException::IMPORT_CONTACT, "Native txn rolled back after inserting address");
  }
}

function wmf_civicrm_get_default_location_type_id() {
  $default_location_type = CRM_Core_BAO_LocationType::getDefault();
  return $default_location_type->id;
}

function wmf_civicrm_get_country_id($raw) {
  // ISO code, or outside chance this could be a lang_COUNTRY pair
  if (preg_match('/^([a-z]+_)?([A-Z]{2})$/', $raw, $matches)) {
    $code = $matches[2];

    $iso_cache = CRM_Core_PseudoConstant::countryIsoCode();
    $id = array_search(strtoupper($code), $iso_cache);
    if ($id !== FALSE) {
      return $id;
    }
  }
  else {
    $country_cache = CRM_Core_PseudoConstant::country(FALSE, FALSE);
    $id = array_search($raw, $country_cache);
    if ($id !== FALSE) {
      return $id;
    }
  }

  watchdog('wmf_civicrm',
    "Cannot find country: [%txt]",
    ['%txt' => $raw],
    WATCHDOG_NOTICE
  );
  return FALSE;
}

/**
 * Get the state id for the named state in the given country.
 *
 * @param int $country_id
 * @param string $state
 *
 * @return int|null
 */
function wmf_civicrm_get_state_id($country_id, $state) {
  $stateID = CRM_Core_DAO::singleValueQuery('
  SELECT id
FROM civicrm_state_province s
WHERE
    s.country_id = %1
    AND ( s.abbreviation = %2 OR s.name = %3)
  ', [
    1 => [$country_id, 'String'],
    2 => [$state, 'String'],
    3 => [$state, 'String'],
  ]);
  if ($stateID) {
    return (int) $stateID;
  }

  watchdog('wmf_civicrm',
    "Cannot find state: [%state] (country %country)",
    ['%state' => $state, '%country' => $country_id],
    WATCHDOG_NOTICE
  );
}


/**
 * Normalize the queued message
 *
 * Decodes the message and updates some of the message fields in ways
 * that are consistent with how we need to insert data into CiviCRM.
 * This should be useful by other modules processing contribution messages
 * out of the queue.
 *
 * TODO: Split this into a transformation chain.
 *
 * @param mixed $msg
 *
 * @return array
 *
 * @throws \WmfException
 * @throws \CiviCRM_API3_Exception
 */
function wmf_civicrm_normalize_msg($msg) {
  // Decode the message body.
  if (!is_array($msg)) {
    $msg = json_decode($msg->body, TRUE);
  }

  $trim_strings = function ($input) {
    if (!is_string($input)) {
      return $input;
    }
    return trim($input);
  };

  $msg = array_map($trim_strings, $msg);

  //defaults: Keys that aren't actually required, but which will cause some portion of the code to complain
  //if they don't exist (even if they're blank).
  // FIXME: don't use defaults.  Access msg properties using a functional interface.
  $defaults = [
    // FIXME: Default to now. If you can think of a better thing to do in
    // the name of historical exchange rates.  Searching ts and
    // source_enqueued_time is a good start.
    'date' => time(),
    'first_name' => '',
    'middle_name' => '',
    'last_name' => '',
    'organization_name' => '',
    'email' => '',
    'street_address' => '',
    'supplemental_address_1' => '',
    'supplemental_address_2' => '',
    'city' => '',
    'country' => '',
    'state_province' => '',
    'postal_code' => '',
    'postmark_date' => NULL,
    'check_number' => NULL,
    'thankyou_date' => NULL,
    'recurring' => NULL,
    'utm_campaign' => NULL,
    'contact_id' => NULL,
    'contribution_recur_id' => NULL,
    'effort_id' => NULL,
    'subscr_id' => NULL,
    'contact_groups' => [],
    'contact_tags' => [],
    'contribution_tags' => [],
    'soft_credit_to' => NULL,
    'soft_credit_to_id' => NULL,
  ];
  $msg = $msg + $defaults;

  wmf_civicrm_removeKnownBadStringsFromAddressFields($msg);

  if (empty($msg['contribution_type_id'])) {
    if (empty($msg['contribution_type'])) {
      $msg['contribution_type'] = wmf_civicrm_get_message_contribution_type($msg);

      if (!$msg['contribution_type']) {
        throw new WmfException(WmfException::INVALID_MESSAGE, 'No contribution type specified');
      }
    }
    $msg['contribution_type_id'] = wmf_civicrm_get_civi_id('contribution_type_id', $msg['contribution_type']);
  }

  if (empty($msg['payment_instrument_id'])) {
    if (empty($msg['payment_instrument'])) {
      $msg['payment_instrument'] = wmf_civicrm_get_message_payment_instrument($msg);

      if (!$msg['payment_instrument']) {
        throw new WmfException(WmfException::INVALID_MESSAGE, 'No payment instrument specified');
      }
    }
    // CiviCRM does not require us to do this translation. It will do the same thing
    // if we don't & through a mandatory_missing error.
    $msg['payment_instrument_id'] = wmf_civicrm_get_civi_id('payment_instrument_id', $msg['payment_instrument']);
  }
  if (!$msg['payment_instrument_id']) {
    throw new WmfException(WmfException::INVALID_MESSAGE, "No payment type found for message.");
  }

  // Convert times to Unix timestamps.
  if (!is_numeric($msg['date'])) {
    $msg['date'] = wmf_common_date_parse_string($msg['date']);
  }
  // if all else fails, fall back to now.
  if (empty($msg['date'])) {
    $msg['date'] = time();
  }

  // if we're missing a contrib id, insert new record to the table
  // this can happen if a user somehow makes a trxn from outside the normal workflow
  // Historically checks have been  ignored as they are completely offline.
  // T146295 has raised some questions about this.
  // code change respects previous recognition of 'payment_method' as being a little bit magic,
  // but also assumes that if you are setting utm_medium or utm_source in your import you intend them to be recorded.
  if (!isset($msg['contribution_tracking_id'])) {
    if (
      (!empty($msg['utm_medium']) || !empty($msg['utm_source']))
      || (array_key_exists('payment_method', $msg) && strtoupper($msg['payment_method']) != "CHECK")
    ) {

      watchdog('wmf_civicrm', 'Contribution missing contribution_tracking_id', [], WATCHDOG_DEBUG);

      $source = isset($msg['utm_source']) ? $msg['utm_source'] : '..' . $msg['payment_method'];
      $medium = isset($msg['utm_medium']) ? $msg['utm_medium'] : 'civicrm';
      $campaign = isset($msg['utm_campaign']) ? $msg['utm_campaign'] : NULL;

      $tracking = [
        'utm_source' => $source,
        'utm_medium' => $medium,
        'utm_campaign' => $campaign,
        'ts' => wmf_common_date_unix_to_sql($msg['date']),
      ];
      if (
        !empty($msg['country']) &&
        array_search($msg['country'], CRM_Core_PseudoConstant::countryIsoCode()) !== FALSE
      ) {
        $tracking['country'] = $msg['country'];
      }
      try {
        $contribution_tracking_id = wmf_civicrm_insert_contribution_tracking($tracking);
      }
      catch (Exception $e) {
        throw new WmfException(WmfException::INVALID_MESSAGE, $e->getMessage());
      }
      watchdog('wmf_civicrm', 'Newly inserted contribution tracking id: @id', ['@id' => $contribution_tracking_id], WATCHDOG_DEBUG);
      $msg['contribution_tracking_id'] = $contribution_tracking_id;
    }
  }

  if ($msg['recurring'] and !isset($msg['start_date'])) {
    $msg['start_date'] = $msg['date'];
    $msg['create_date'] = $msg['date'];
  }

  if ($msg['recurring'] and !$msg['subscr_id']) {
    if ($msg['gateway'] == 'globalcollect') {
      // Well randomly grab an ID, of course :-/
      $msg['subscr_id'] = $msg['gateway_txn_id'];
    }
    else {
      if ($msg['gateway'] == 'amazon') {
        // Amazon 'subscription id' is the Billing Agreement ID, which
        // is a substring of the Capture ID we record as 'gateway_txn_id'
        $msg['subscr_id'] = substr($msg['gateway_txn_id'], 0, 19);
      }
    }
  }

  if (!empty($msg['thankyou_date'])) {
    if (!is_numeric($msg['thankyou_date'])) {
      $unix_time = wmf_common_date_parse_string($msg['thankyou_date']);
      if ($unix_time !== FALSE) {
        $msg['thankyou_date'] = $unix_time;
      }
      else {
        watchdog('wmf_civicrm', 'Could not parse thankyou date: @date from @id', [
          '@date' => $msg['thankyou_date'],
          '@id' => $msg['contribution_tracking_id'],
        ], WATCHDOG_DEBUG);
        unset($msg['thankyou_date']);
      }
    }
  }

  if (empty($msg['first_name']) and empty($msg['last_name'])) {
    $msg['first_name'] = 'Anonymous';
    $msg['last_name'] = '';
  }

  // Check for special flags
  // TODO: push non-generic cases into database
  if (!empty($msg['utm_campaign'])) {
    switch ($msg['utm_campaign']) {
      case 'NY2013':
        $msg['direct_mail_appeal'] = "New York Event 2013";
        break;
      case 'NYCShaku2013':
        $msg['direct_mail_appeal'] = "Shaku - NYC Event 2013";
        break;
      case 'SF2013':
        $msg['direct_mail_appeal'] = "San Francisco Event 2013";
        break;
      case 'Mossman':
        $msg['direct_mail_appeal'] = "Sheila Mossman";
        break;
      case 'Mediander':
        $msg['direct_mail_appeal'] = "Mediander";
        break;
      default:
        $directMailOptions = wmf_civicrm_get_options('Contribution', wmf_civicrm_get_custom_field_name('Appeal'));
        if (!array_key_exists($msg['utm_campaign'], $directMailOptions)) {
          wmf_civicrm_ensure_option_value_exists(wmf_civicrm_get_direct_mail_field_option_name(), $msg['utm_campaign']);
        }
        $msg['direct_mail_appeal'] = $msg['utm_campaign'];
        break;
    }
  }

  if (wmf_civicrm_is_endowment_gift($msg)) {
    $msg['financial_type_id'] = 'Endowment Gift';
  }

  $list_fields = [
    'contact_groups',
    'contact_tags',
    'contribution_tags',
  ];
  foreach ($list_fields as $field) {
    if (is_string($msg[$field])) {
      $msg[$field] = preg_split('/[\s,]+/', $msg[$field], NULL, PREG_SPLIT_NO_EMPTY);
    }
    $msg[$field] = array_unique($msg[$field]);
  }

  // Front-end uses es-419 to represent Latin American Spanish but
  // CiviCRM needs to store it as a 5 char string. We choose es_MX.
  if (isset($msg['language']) && strtolower($msg['language']) == 'es-419') {
    $msg['language'] = 'es_MX';
  }

  // set the correct amount fields/data and do exchange rate conversions.
  $msg = wmf_civicrm_normalize_contribution_amounts($msg);

  return $msg;
}

/**
 * Remove known bad strings from address.
 *
 * This function focuses on specific forms of bad data with high
 * prevalence in the fields we see them in.
 *
 * @param array $msg
 */
function wmf_civicrm_removeKnownBadStringsFromAddressFields(&$msg) {
  // Remove known dummy data.
  if ($msg['street_address'] === 'N0NE PROVIDED') {
    $msg['street_address'] = '';
  }

  $invalidAddressStrings = ['0', 'City/Town', 'NoCity', 'City'];
  foreach (['postal_code', 'city'] as $fieldName) {
    if (in_array($msg[$fieldName], $invalidAddressStrings)) {
      $msg[$fieldName] = '';
    }
  }

  // Filter out unexpected characters from postal codes.
  // This filter should allow through all postal code formats
  // listed here https://github.com/unicode-org/cldr/blob/release-26-0-1/common/supplemental/postalCodeData.xml
  if (isset($msg['postal_code'])) {
    $msg['postal_code'] = preg_replace(
      '/[^a-z0-9\s\-]+/i',
      '',
      $msg['postal_code']
    );
  }

}

/**
 * Get the name value for the option group for direct mail.
 *
 * The option group for the direct mail field has been given a distinctive
 * title but the name (which is the unique one) is distinctly historical.
 *
 * This name is included (as per below) in the install script so this function
 * exists mostly to document it as such a wierd name is guaranteed to get
 * people worried about avoiding hard-coding. The more appealing title 'Appeal'
 * cannot be guaranteed to be unique.
 *
 * @throws \CiviCRM_API3_Exception
 */
function wmf_civicrm_get_direct_mail_field_option_name() {
  return 'appeal_20080709183729';
}

/**
 * Pulls all records in the wmf_contribution_extras table that match the gateway
 * and gateway transaction id.
 *
 * @param string $gateway
 * @param string $gateway_txn_id
 *
 * @return mixed array of result rows, or false if none present.
 * TODO: return empty set rather than false.
 * @throws WmfException
 */
function wmf_civicrm_get_contributions_from_gateway_id($gateway, $gateway_txn_id) {
  $gateway = strtolower($gateway);
  $query = "SELECT cx.*, cc.* FROM wmf_contribution_extra cx LEFT JOIN civicrm_contribution cc
		ON cc.id = cx.entity_id
		WHERE gateway = %1 AND gateway_txn_id = %2";

  $dao = CRM_Core_DAO::executeQuery($query, [
    1 => [$gateway, 'String'],
    2 => [$gateway_txn_id, 'String'],
  ]);
  return wmf_civicrm_dao_to_list($dao);
}

/**
 * Pulls all records in the wmf_contribution_extras table that match the civicrm
 * contribution id.
 *
 * @param string $contribution_id
 *
 * @return mixed array of result rows, or false if none present.
 * @throws WmfException
 */
function wmf_civicrm_get_contributions_from_contribution_id($contribution_id) {
  $query = "SELECT cx.*, cc.* FROM wmf_contribution_extra cx LEFT JOIN civicrm_contribution cc
		ON cc.id = cx.entity_id
		WHERE cc.id = %1";

  $dao = CRM_Core_DAO::executeQuery($query, [
    1 => [$contribution_id, 'Integer'],
  ]);
  return wmf_civicrm_dao_to_list($dao);
}

/**
 * Checks to see whether a contribution is refunded or charged back by gateway
 * and gateway transaction id.
 *
 * @param string $gateway
 * @param string $gateway_txn_id
 *
 * @return bool true if contribution exists and is refunded or charged back,
 *   else false
 */
function wmf_civicrm_is_refunded_by_gateway_id($gateway, $gateway_txn_id) {
  $contributions = wmf_civicrm_get_contributions_from_gateway_id($gateway, $gateway_txn_id);
  if (!$contributions) {
    return FALSE;
  }
  return CRM_Contribute_BAO_Contribution::isContributionStatusNegative(
    $contributions[0]['contribution_status_id']
  );
}

function wmf_civicrm_boost_performance() {
  civicrm_initialize();
  $config = CRM_Core_Config::singleton();
  $config->doNotResetCache = 1;
}

function wmf_civicrm_set_no_thank_you($contribution_id, $reason) {
  watchdog('wmf_civicrm', "Preventing thank-you for contribution {$contribution_id} because: {$reason}", [], WATCHDOG_INFO);

  try {
    wmf_civicrm_set_custom_field_values($contribution_id, [
      'no_thank_you' => $reason,
    ]);
  }
  catch (WmfException $ex) {
    watchdog('wmf_civicrm', "Updating with no-thank-you failed with details: {$ex->getMessage()}", [], WATCHDOG_ERROR);
  }
}

/**
 * Sets the civi records to reflect a contribution refund.
 *
 * The original contribution is set to status "Refunded", or "Chargeback" and a
 * negative financial transaction record is created. If the amount refunded
 * does not match a second contribution is added for the balance. The
 * parent_contribution_id custom field is set on the balance contribution to
 * connect it to the parent.
 *
 * Prior to the 4.6 CiviCRM upgrade refunds resulted in second contribution
 * with a negative amount. They were linked to the original through the
 * parent_contribution_id custom field. This was consistent with 4.2 behaviour
 * which was the then current version.
 *
 * 4.3 (included in the 4.6 upgrade) introduced recording multiple financial
 * transactions (payments) against one contribution. In order to adapt to this
 * the markRefund function now records second financial transactions against
 * the original contribution (using the contribution.create api). Discussion
 * about this change is at https://phabricator.wikimedia.org/T116317
 *
 * Some refunds do not have the same $ amount as the original transaction.
 * Prior to Oct 2014 these were seemingly always imported to CiviCRM. Since
 * that time the code was changed to throw an exception when the refund
 * exceeded the original amount, and not import it into CiviCRM. (this does
 * have visibility as it results in fail_mail).
 *
 * The code suggested an intention to record mismatched refunds with a the
 * difference in the custom fields settlement_usd. However, this returns no
 * rows. select * from wmf_contribution_extra WHERE settlement_usd IS NOT NULL
 * LIMIT. It would appear they have been recorded without any record of the
 * discrepancy, or there were none.
 *
 * That issue should be addressed (as a separate issue). The methodology for
 * recording the difference needs to be considered e.g T89437 - preferably in
 * conjunction with getting the appropriate method tested within the core
 * codebase.
 *
 * Note that really core CiviCRM should have a way of handling this and we
 * should work on getting that resolved and adopting it.
 *
 * An earlier iteration of this function reconstructed the value of the
 * original contribution when it had been zero'd or marked as 'RFD'. This
 * appears to be last used several years ago & this handling has been removed
 * now.
 *
 * @param int $contribution_id
 * @param string $refund_type
 *   'refund'|'chargeback' - this will determine the new contribution status.
 * @param bool $refund_completed
 *   It turns out this is only passed in as anything other than true from the
 *   tests (based on grepping). The UI DOES allow for a status of 'Pending
 *   Refund' to be used if this is required from the UI although we don't have
 *   a process around that at this stage.
 * @param string $refund_date
 * @param int $refund_gateway_txn_id
 * @param string $refund_currency
 *   If provided this will be checked against the original contribution and an
 *   exception will be thrown on mismatch.
 * @param float $refund_amount
 *   If provided this will be checked against the original contribution and an
 *   exception will be thrown on mismatch.
 *
 * @return int
 *   The refund's contribution id.
 * @throws \ExchangeRatesException
 * @throws \WmfException
 */

function wmf_civicrm_mark_refund(
  $contribution_id,
  $refund_type = 'refund',
  $refund_completed = FALSE,
  $refund_date = NULL,
  $refund_gateway_txn_id = NULL,
  $refund_currency = NULL,
  $refund_amount = NULL
) {
  $amount_scammed = 0;

  try {
    $contribution = civicrm_api3('Contribution', 'getsingle', [
      'id' => $contribution_id,
      'return' => [
        'total_amount',
        'trxn_id',
        'contribution_source',
        'contact_id',
        'receive_date',
        'contribution_status_id',
      ],
    ]);
  }
  catch (CiviCRM_API3_Exception $e) {
    throw new WmfException(
      WmfException::INVALID_MESSAGE, "Could not load contribution: $contribution_id with error " . $e->getMessage()
    );
  }

  // Note that my usual reservation about using BAO functions from custom code is overridden by the
  // caching problems we are hitting in testing (plus the happy knowledge the tests care about this line of
  // code).
  if (CRM_Contribute_BAO_Contribution::isContributionStatusNegative($contribution['contribution_status_id'])
  ) {
    throw new WmfException(WmfException::DUPLICATE_CONTRIBUTION, "Contribution is already refunded: $contribution_id");
  }
  // Deal with any discrepancies in the refunded amount.
  [$original_currency, $original_amount] = explode(" ", $contribution['contribution_source']);

  if ($refund_currency !== NULL) {
    if ($refund_currency != $original_currency) {
      throw new WmfException(WmfException::INVALID_MESSAGE, "Refund was in a different currency.  Freaking out.");
    }
  }
  else {
    $refund_currency = $original_currency;
  }
  if ($refund_date === NULL) {
    $refund_date = time();
  }
  elseif (!is_numeric($refund_date)) {
    $refund_date = wmf_common_date_parse_string($refund_date);
  }

  // TODO: Normalize earlier.
  $validTypes = [
    'refund' => 'Refunded',
    'chargeback' => 'Chargeback',
    'cancel' => 'Cancelled',
    'reversal' => 'Chargeback', // from the audit processor
    'admin_fraud_reversal' => 'Chargeback', // raw IPN code
  ];

  if (!array_key_exists($refund_type, $validTypes)) {
    throw new WmfException(WmfException::IMPORT_CONTRIB, "Unknown refund type '{$refund_type}'");
  }

  try {
    civicrm_api3('Contribution', 'create', [
      'id' => $contribution_id,
      'debug' => 1,
      'contribution_status_id' => $validTypes[$refund_type],
      'cancel_date' => wmf_common_date_unix_to_civicrm($refund_date),
      'refund_trxn_id' => $refund_gateway_txn_id,
    ]);
  }
  catch (CiviCRM_API3_Exception $e) {
    throw new WmfException(
      WmfException::IMPORT_CONTRIB,
      "Cannot mark original contribution as refunded:
                $contribution_id, " . $e->getMessage() . print_r($e->getExtraParams(), TRUE)
    );
  }

  if ($refund_amount !== NULL) {

    $amount_scammed = round($refund_amount, 2) - round($original_amount, 2);
    if ($amount_scammed != 0) {
      $transaction = WmfTransaction::from_unique_id($contribution['trxn_id']);
      if ($refund_gateway_txn_id) {
        $transaction->gateway_txn_id = $refund_gateway_txn_id;
      }
      $transaction->is_refund = TRUE;
      $refund_unique_id = $transaction->get_unique_id();

      try {
        civicrm_api3('Contribution', 'create', [
          'total_amount' => round(
            exchange_rate_convert(
              $refund_currency,
              -$amount_scammed,
              wmf_common_date_parse_string(date('Y-m-d h:i:s', $refund_date)
              )), 2),
          // New type?
          'financial_type_id' => 'Refund',
          'contact_id' => $contribution['contact_id'],
          'contribution_source' => $refund_currency . " " . -$amount_scammed,
          'trxn_id' => $refund_unique_id,
          'receive_date' => date('Y-m-d h:i:s', $refund_date),
          'currency' => 'USD',
          'debug' => 1,
          wmf_civicrm_get_custom_field_name('parent_contribution_id') => $contribution_id,
          wmf_civicrm_get_custom_field_name('no_thank_you') => 1,
        ]);
      }
      catch (CiviCRM_API3_Exception $e) {
        throw new WmfException(
          WmfException::IMPORT_CONTRIB,
          "Cannot create new contribution for the refund difference:
                $contribution_id, " . $e->getMessage() . print_r($e->getExtraParams(), TRUE)
        );
      }
    }
  }

  if ($amount_scammed > 0.02 * $original_amount) {
    wmf_common_failmail('wmf_civicrm', "Refund amount mismatch for : $contribution_id, difference is {$amount_scammed}. See "
      . CRM_Utils_System::url('civicrm/contact/view/contribution', [
        'reset' => 1,
        'id' => $contribution_id,
        'action' => 'view',
      ], TRUE));
  }

  return $contribution_id;
}

/**
 * Implementation of hook_civicrm_merge().
 *
 * @param string $type
 * @param array $refs
 * @param int $mainId
 * @param int $otherId
 * @param array $tables
 */
function wmf_civicrm_civicrm_merge($type, &$refs, $mainId, $otherId, $tables) {
  switch ($type) {
    case 'batch' :
    case 'form' :

      watchdog("civicrm_merge_debug", "Deduping contacts $mainId and $otherId");
      $refs['migration_info']['context'] = $type;
      CRM_Core_DAO::executeQuery('SET @uniqueID = %1', [
        1 => [
          uniqid() . CRM_Utils_String::createRandom(CRM_Utils_String::ALPHANUMERIC, 4),
          'String',
        ],
      ]);
      if (isset($refs['fields_in_conflict'])) {
        if (array_key_exists('move_' . wmf_civicrm_get_custom_field_name('do_not_solicit'), $refs['fields_in_conflict'])
        ) {
          $keyString = 'move_' . wmf_civicrm_get_custom_field_name('do_not_solicit');
          // At least one contact has a 1 for do_not_solicit, YES wins.
          $refs['migration_info'][$keyString] = 1;
          $refs['migration_info']['rows'][$keyString]['other'] = ts('Yes');
          unset($refs['fields_in_conflict'][$keyString]);
        }

        $wmfCalculatedFields = wmf_civicrm_get_calculated_fields();

        $overwriteLatestContributionFields = FALSE;
        $latestDonationField = wmf_civicrm_get_custom_field_name('last_donation_date');
        if (
          isset($refs['migration_info']['rows']['move_' . $latestDonationField])
          && strtotime($refs['migration_info']['rows']['move_' . $latestDonationField]['other']) >
          strtotime($refs['migration_info']['rows']['move_' . $latestDonationField]['main'])) {
          $overwriteLatestContributionFields = TRUE;
        }
        $latestDonationFields = [
          wmf_civicrm_get_custom_field_name('last_donation_currency'),
          wmf_civicrm_get_custom_field_name('last_donation_amount'),
          wmf_civicrm_get_custom_field_name('last_donation_usd'),
        ];

        foreach ($wmfCalculatedFields as $wmfCalculatedField) {
          $keyString = 'move_' . $wmfCalculatedField;
          if ($overwriteLatestContributionFields && in_array($wmfCalculatedField, $latestDonationFields)
            && isset($refs['migration_info']['rows']['move_' . $wmfCalculatedField])) {
            $refs['migration_info']['move_' . $wmfCalculatedField] = $refs['migration_info']['rows']['move_' . $wmfCalculatedField]['other'];
          }
          elseif (isset($refs['migration_info']['move_' . $wmfCalculatedField])) {
            unset($refs['migration_info']['move_' . $wmfCalculatedField]);
            unset($refs['migration_info']['rows']['move_' . $wmfCalculatedField]);
          }
          if (array_key_exists($keyString, $refs['fields_in_conflict'])) {
            unset($refs['fields_in_conflict'][$keyString]);
          }
        }

        // If type is 'form' then the user is responsible for selecting how to merge the
        // non-calculated fields but in batch mode we have selected assumptions
        // ie. take the latest address and give opt out choices priority over
        // default settings for opt out fields.
        if ($type === 'batch') {
          foreach (array_keys($refs['fields_in_conflict']) as $moveField) {
            _wmf_civicrm_merge_resolve_field_conflict($refs, $moveField, $mainId, $otherId);
          }
        }
      }

      break;

  }
}

/**
 * Resolve any resolvable field conflicts.
 *
 * @param array $refs
 * @param string $moveField
 * @param int $mainId
 *   Id of the main contact (the one to keep)
 * @param int $otherId
 *   Id of the other contact (the one to delete)
 */
function _wmf_civicrm_merge_resolve_field_conflict(&$refs, $moveField, $mainId, $otherId) {
  $dbFieldName = str_replace('move_', '', $moveField);

  if (_wmf_civicrm_merge_resolve_preferred_language_conflict(
    $dbFieldName,
    $refs['migration_info'][$moveField],
    // The $refs['migration_info']['rows']['move_preferred_language'] values
    // are blank for non-valid values (like we use). This has test cover though :-)
    $refs['migration_info']['other_details'][$dbFieldName],
    $refs['migration_info']['main_details'][$dbFieldName],
    $mainId,
    $otherId
  )) {
    unset($refs['fields_in_conflict'][$moveField]);
    return;
  }

  if (substr($moveField, 0, 13) === 'move_location') {
    $fieldParts = explode('_', $moveField);
    $mainContactBlocks = $refs['migration_info']['main_details']['location_blocks'];
    $otherContactBlocks = $refs['migration_info']['other_details']['location_blocks'];

    if ($fieldParts[2] === 'email') {
      // Now fully handled in the deduper.
      return;
    }
    if ($fieldParts[2] === 'address') {
      // See if this has been handed off to deduper yet - if so don't handle here
      // We are working to move everything to the deduper but it's taking some unravelling.
      $mainAddress = $mainContactBlocks['address'][$fieldParts[3]] ?? NULL;
      $otherAddress = $otherContactBlocks['address'][$fieldParts[3]] ?? NULL;
      if ($mainAddress && $otherAddress && _wmf_civicrm_merge_is_address_conflict_resolvable($mainAddress['display'], $otherAddress['display'], $mainAddress, $otherAddress)) {
        return;
      }
    }

    unset($refs['fields_in_conflict'][$moveField]);
  }
}

/**
 * Resolve conflicts where 2 different addresses are really the same.
 *
 * The way CiviCRM handles addresses is by converting the whole address into
 * one string & comparing it. This means addresses that only differ by
 * having additional information are treated as a conflict.
 *
 * @param string $valueToKeep
 * @param string $valueToOverwrite
 * @param array $blockToKeep
 * @param array $blockToOverwrite
 *
 * @return bool
 */
function _wmf_civicrm_merge_is_address_conflict_resolvable($valueToKeep, $valueToOverwrite, $blockToKeep, $blockToOverwrite) {
  // Let's get rid of any preceding or trailing spaces.
  $valueToKeep = trim($valueToKeep);
  $valueToOverwrite = trim($valueToOverwrite);
  if (!$valueToKeep || !$valueToOverwrite) {
    return FALSE;
  }

  if (_wmf_civicrm_merge_is_only_extra_postal_code_suffix($valueToKeep, $valueToOverwrite, $blockToKeep, $blockToOverwrite)) {
    return TRUE;
  }

  if (!stristr($valueToKeep, $valueToOverwrite) && !stristr($valueToOverwrite, $valueToKeep)) {
    return FALSE;
  }
  static $countries = [];
  if (empty($countries)) {
    $countries = civicrm_api3('Address', 'getoptions', ['field' => 'country_id']);
    $countries = $countries['values'];
  }
  if ((in_array($valueToOverwrite, $countries) || in_array($valueToKeep, $countries))
    && (!empty($blockToKeep['country_id']) && $blockToKeep['country_id'] === $blockToOverwrite['country_id'])
  ) {
    // One of the values is a country & it is a subset of the other value. We
    // can get past this.
    return TRUE;
  }
  return FALSE;
}

/**
 * Is the merge conflict purely the addition of a postal code suffix.
 *
 * @param string $valueToKeep
 * @param string $valueToOverwrite
 * @param array $blockToKeep
 * @param array $blockToOverwrite
 *
 * @return bool
 */
function _wmf_civicrm_merge_is_only_extra_postal_code_suffix($valueToKeep, $valueToOverwrite, $blockToKeep, $blockToOverwrite) {
  $fieldsInBlockToKeepOnly = array_diff_key($blockToKeep, $blockToOverwrite);
  $fieldsInBlockToOverwriteOnly = array_diff_key($blockToOverwrite, $blockToKeep);
  if (array_keys($fieldsInBlockToKeepOnly) === ['postal_code_suffix']
    && str_replace('-' . $blockToKeep['postal_code_suffix'], '', $valueToKeep) === $valueToOverwrite) {
    return TRUE;
  }
  if (array_keys($fieldsInBlockToOverwriteOnly) === ['postal_code_suffix']
    && str_replace('-' . $blockToOverwrite['postal_code_suffix'], '', $valueToOverwrite) === $valueToKeep
  ) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Resolve conflicts on preferred language.
 *
 * If the underlying language (first 2 letters) is the same we make a value
 * choice.
 *
 * 1) we prefer 'valid' languages - ones that have entries in the option_value
 * table.
 * 2) we prefer more explicit (longer) languages (en_US over en).
 * 3) we prefer languages with labels that describe them. For example
 *   'de_DE' => 'German' has been deliberately created
 *   'de_NZ' => 'de_NZ' has been code-created.
 *
 * Note preferring based on the option value table means updates to what is
 * enabled or whether they have labels will flow through.
 *
 * We could also return the later donor but this feels like poor return on
 * effort given they are already the same main language and we don't easily
 * have that info at this point in the code. We will usually get the most
 * recent donor anyway by default - as it merges higher id to lower id.
 *
 * @param string $fieldName
 * @param string $moveFieldValue
 * @param string $valueToKeep
 * @param string $valueToOverwrite
 *
 * @return bool
 *   Has the conflict been resolved?
 *
 * @throws \CiviCRM_API3_Exception
 */
function _wmf_civicrm_merge_resolve_preferred_language_conflict($fieldName, &$moveFieldValue, &$valueToKeep, &$valueToOverwrite, $contactToKeepID, $contactToDeleteID) {
  if ($fieldName !== 'preferred_language') {
    return FALSE;
  }
  $valueToKeep = wmf_civicrm_get_language_db_value($valueToKeep);
  $valueToOverwrite = wmf_civicrm_get_language_db_value($valueToOverwrite);

  if (substr($valueToKeep, 0, 2) != substr($valueToOverwrite, 0, 2)) {
    $lastDonor = civicrm_api3('Contribution', 'get', [
      'return' => 'contact_id',
      'contact_id' => [
        'IN' => [
          $contactToKeepID,
          $contactToDeleteID,
        ],
      ],
      'sequential' => 1,
      'options' => ['sort' => 'receive_date DESC', 'limit' => 1],
    ])['values'];
    if (empty($lastDonor[0])) {
      return TRUE;
    }
    if ($lastDonor[0]['contact_id'] == $contactToKeepID) {
      // We are resolving the conflict by keeping the language unchanged from our 'keeper' contact.
      // By default it will be trying to overwrite that value with the 'to-delete' contact
      // (and it would block that through the conflict process).
      // We re-instate the values that it was going to overwrite.
      $moveFieldValue = $valueToOverwrite;
      $valueToKeep = $valueToOverwrite;
      return TRUE;
    }
    else {
      // We are resolving the conflict by keeping the language from our 'to-delete' contact.
      // These are what it was going to carry over & we keep that.
      return TRUE;
    }
  }
  if (!wmf_civicrm_check_language_exists($valueToOverwrite)) {
    // The conflict is resolved & the value to keep is fine.
    return TRUE;
  }

  $languages = wmf_civicrm_get_valid_languages();
  if (!wmf_civicrm_check_language_exists($valueToKeep)
    || strlen($valueToOverwrite) > strlen($valueToKeep)
    || ($languages[$valueToKeep] == $valueToKeep && $languages[$valueToOverwrite] != $valueToOverwrite)
  ) {
    // The conflict is resolved & we will chose the overwrite value as the keeper is invalid.
    $moveFieldValue = $valueToOverwrite;
    $valueToKeep = $valueToOverwrite;
    return TRUE;
  }

  return TRUE;
}

/**
 * Get the value for language that is stored in the db.
 *
 * In CiviCRM 5.17 an improvement means that the display renders the
 * UI string - eg. 'English (United States)' on the merge screen instead of 'en_US'.
 *
 * However, as we have previously griped about, the values passed out to the hook
 * are stupidly tied to the form - resulting in the change flowing through.
 *
 * This handling copes with either the db value or the form value - although the db value might
 * be irrelevant after we do our next update (OTOH it's just an early return so 'cheap').
 *
 * @param string $value
 *
 * @return string
 */
function wmf_civicrm_get_language_db_value($value): string {
  if (!$value) {
    return '';
  }
  $languages = wmf_civicrm_get_valid_languages();
  if (isset($languages[$value])) {
    return $value;
  }
  if (in_array($value, $languages)) {
    return array_search($value, $languages);
  }
  return $value;
}

/**
 *
 * We are testing a nuanced real life situation where the address data of the
 * most recent donor gets priority - resulting in the primary address being set
 * to the primary address of the most recent donor and address data on a per
 * location type basis also being set to the most recent donor. Hook also
 * excludes a fully matching address with a different location.
 *
 * This has been added to the test suite to ensure the code supports more this
 * type of intervention.
 *
 * @param array $blocksDAO
 *   Array of location DAO to be saved. These are arrays in 2 keys 'update' &
 *   'delete'.
 * @param int $mainId
 *   Contact_id of the contact that survives the merge.
 * @param int $otherId
 *   Contact_id of the contact that will be absorbed and deleted.
 * @param array $migrationInfo
 *   Calculated migration info, informational only.
 *
 * @return mixed
 * @throws \CRM_Core_Exception
 * @throws \CiviCRM_API3_Exception
 */
function wmf_civicrm_civicrm_alterLocationMergeData(&$blocksDAO, $mainId, $otherId, $migrationInfo) {

  // If we are dealing with a manual merge do not intervene.
  if ($migrationInfo['context'] == 'form') {
    return;
  }

  // The merge handler is in dedupe tools - we are migrating this code over to that extension.
  // for now our goal is NOT to touch any merges being managed by that extension. That extension will
  // currently ONLY manage emails which are blocked as merge conflicts due on_hold being different.
  // This code has never handled that so the goal is to not touch any emails IF that extension is touching them.
  /* @var CRM_Deduper_BAO_MergeHandler $mergeHandler*/
  $mergeHandler = $migrationInfo['merge_handler'];
  $lastDonorID = $mergeHandler->getPreferredContact();
  $contactIDToBeKeptIsMostRecentDonor = ($lastDonorID == $mainId) ? TRUE : FALSE;
  // Since the last donor is not the main ID we are prioritising info from the last donor.
  // In the test this should always be true - but keep the check in case
  // something changes that we need to detect.
  if (!$contactIDToBeKeptIsMostRecentDonor) {
    $higherPriorityLocationBlocks = $migrationInfo['other_details']['location_blocks'];
    $lowerPriorityLocationBlocks = $migrationInfo['main_details']['location_blocks'];
  }
  else {
    $higherPriorityLocationBlocks = $migrationInfo['main_details']['location_blocks'];
    $lowerPriorityLocationBlocks = $migrationInfo['other_details']['location_blocks'];
  }

  foreach ($higherPriorityLocationBlocks as $blockType => $blocks) {
    if ($blockType === 'email') {
      continue;
    }
    foreach ($blocks as $blockIndex => $block) {
      if ($mergeHandler->isResolvingLocationConflictFor($blockType)) {
        // We are not going to deal with conflict resolution here because the merge handler is on it.
        // In practice this could currently only mean that there is a conflict on an email address
        // where they only differ in their on_hold handling & the mergeHandler has that in hand.
        // Any other form of conflict is location currently handled in this section & not handled there.
        continue;
      }
      if ($block['is_primary'] == 1 && isset($blocksDAO[$blockType]['update'][$block['id']])) {
        unset($blocksDAO[$blockType]['update'][$block['id']]->is_primary);
      }

      if (empty($lowerPriorityLocationBlocks[$blockType])) {
        continue;
      }

      foreach ($lowerPriorityLocationBlocks[$blockType] as $index => $lowerPriorityLocationBlock) {
        if (_wmf_civicrm_is_delete_location_in_favour_of_higher_priority_one(
          $blocks, $block, $lowerPriorityLocationBlock)
        ) {
          $blocksDAO[$blockType]['delete'][$lowerPriorityLocationBlock['id']] = _civicrm_api3_load_DAO($blockType);
          $blocksDAO[$blockType]['delete'][$lowerPriorityLocationBlock['id']]->id = $lowerPriorityLocationBlock['id'];
          if (!isset($blocksDAO[$blockType]['update'][$block['id']])) {
            $blocksDAO[$blockType]['update'][$block['id']] = _civicrm_api3_load_DAO($blockType);
            $blocksDAO[$blockType]['update'][$block['id']]->id = $block['id'];
            $blocksDAO[$blockType]['update'][$block['id']]->contact_id = $mainId;
          }
          unset($lowerPriorityLocationBlocks[$blockType][$index]);
        }
        if (isset($blocksDAO[$blockType]['update'][$block['id']]->is_primary)) {
          $blocksDAO[$blockType]['update'][$block['id']]->is_primary = $block['is_primary'];
        }
      }
      foreach ($lowerPriorityLocationBlocks[$blockType] as $remainingLocation) {
        $blocksDAO[$blockType]['update'][$remainingLocation['id']] = _civicrm_api3_load_DAO($blockType);
        $blocksDAO[$blockType]['update'][$remainingLocation['id']]->id = $remainingLocation['id'];
        $blocksDAO[$blockType]['update'][$remainingLocation['id']]->contact_id = $mainId;
        $blocksDAO[$blockType]['update'][$remainingLocation['id']]->is_primary = 0;
      }
    }
  }

}

/**
 * Get the field ids of the wmf fields that are determined by calculation.
 *
 * Differences in these fields should not block a merge activity as they
 * are simply recalculated.
 *
 * @return array
 *   The custom fields that are calculated in the format
 *   - custom_1
 *   - custom_2
 */
function wmf_civicrm_get_calculated_fields() {
  $fieldNames = wmf_get_calculated_field_names();
  $customFields = [];
  foreach ($fieldNames as $fieldName) {
    $customFields[] = wmf_civicrm_get_custom_field_name($fieldName);
  }
  return $customFields;
}

/**
 * Get the names of the calculated fields.
 *
 * @return array
 */
function wmf_get_calculated_field_names() {
  $fields = _wmf_civicrm_get_wmf_donor_fields();
  return array_keys($fields);
}

/**
 * Implementation of hook_civicrm_pre
 *
 * @param string $op
 * @param string $type
 * @param int $id
 * @param array $entity
 *
 * @throws \WmfException
 */
function wmf_civicrm_civicrm_pre($op, $type, $id, &$entity) {
  switch ($type) {
    case 'Contribution':
      wmf_civicrm_civicrm_pre_Contribution($op, $id, $entity);
      break;
  }
}

/**
 * @param string $op
 * @param int $id
 * @param array $contribution
 *
 * @throws \WmfException
 */
function wmf_civicrm_civicrm_pre_Contribution($op, $id, &$contribution) {
  switch ($op) {
    case 'create':
    case 'edit':
      // Add derived wmf_contribution_extra fields to contribution parameters
      if (WmfDatabase::isNativeTxnRolledBack()) {
        throw new WmfException(
          WmfException::IMPORT_CONTRIB,
          'Native txn rolled back before running pre contribution hook'
        );
      }
      $extra = wmf_civicrm_get_wmf_contribution_extra($contribution);

      if ($extra) {
        $map = wmf_civicrm_get_custom_field_map(
          array_keys($extra), 'contribution_extra'
        );
        $mapped = [];
        foreach ($extra as $key => $value) {
          $mapped[$map[$key]] = $value;
        }
        $contribution += $mapped;
        // FIXME: Seems really ugly that we have to do this, but when
        // a contribution is created via api3, the _pre hook fires
        // after the custom field have been transformed and copied
        // into the 'custom' key
        $formatted = [];
        _civicrm_api3_custom_format_params($mapped, $formatted, 'Contribution');
        if (isset($contribution['custom'])) {
          $contribution['custom'] += $formatted['custom'];
        }
        else {
          $contribution['custom'] = $formatted['custom'];
        }
      }

      break;
  }
}

/**
 * Implementation of hook_civicrm_post, used to update contribution_extra fields
 * and wmf_donor rollup fields.
 *
 * @param string $op
 * @param string $type
 * @param int $id
 * @param \CRM_Contribute_BAO_Contribution $entity
 *
 * @throws \WmfException
 * @throws \CiviCRM_API3_Exception
 */
function wmf_civicrm_civicrm_post($op, $type, $id, &$entity) {
  switch ($type) {
    case 'Contribution':
      wmf_civicrm_civicrm_post_Contribution($op, $id, $entity);
      break;
  }
}

/**
 * @param string $op
 * @param int $id
 * @param \CRM_Contribute_BAO_Contribution $contribution
 *
 * @throws \CiviCRM_API3_Exception
 * @throws \WmfException
 */
function wmf_civicrm_civicrm_post_Contribution($op, $id, &$contribution) {
  switch ($op) {
    case 'create':
    case 'edit':
      if (WmfDatabase::isNativeTxnRolledBack()) {
        throw new WmfException(
          WmfException::IMPORT_CONTRIB,
          'Native txn rolled back before running post contribution hook'
        );
      }
      $params = wmf_civicrm_getLastDonationParams($contribution);
      if (!empty($params)) {
        $params['id'] = $contribution->contact_id;
        civicrm_api3('Contact', 'create', $params);
      }

      break;
  }
}

/**
 * @param array $contribution
 *
 * @return array
 */
function wmf_civicrm_get_wmf_contribution_extra($contribution) {
  $extra = [];

  if (!empty($contribution['trxn_id'])) {
    try {
      $transaction = WmfTransaction::from_unique_id($contribution['trxn_id']);
      $extra['gateway'] = strtolower($transaction->gateway);
      $extra['gateway_txn_id'] = $transaction->gateway_txn_id;
    }
    catch (WmfException $ex) {
      watchdog('wmf_civicrm', "Failed to parse trxn_id: {$contribution['trxn_id']}, " . $ex->getMessage());
    }
  }

  if (!empty($contribution['source'])) {
    $extra = array_merge($extra, wmf_civicrm_get_original_currency_and_amount_from_source($contribution['source'], $contribution['total_amount']));
  }
  return $extra;
}

/**
 * Get original currency & amount
 *
 * The source field holds the amount & currency - parse it out
 * e.g 'USD 15.25'
 *
 * @param string $source
 * @param float $usd_amount
 *
 * @return array
 */
function wmf_civicrm_get_original_currency_and_amount_from_source($source, $usd_amount) {
  if (empty($source)) {
    return [];
  }
  [$original_currency, $original_amount] = explode(" ", $source);
  if (is_numeric($original_amount) && wmf_civicrm_is_valid_currency($original_currency)) {
    return ['original_currency' => $original_currency, 'original_amount' => $original_amount];
  }

  if (is_numeric($original_amount)) {
    return ['original_currency' => 'USD', 'original_amount' => $usd_amount];
  }
  return [];

}

/**
 * Get the details of the last donation received if it differs from the current one.
 *
 * We use this information to update the last_donation_amount and
 * last_donation_currency fields. They will already have been updated to hold
 * the information about the current one in those fields so we only return the
 * information if it differs.
 *
 * @param \CRM_Contribute_BAO_Contribution $contribution
 *
 * @return mixed
 * @throws \CiviCRM_API3_Exception
 */
function wmf_civicrm_getLastDonationParams(&$contribution) {
  $contributionStatus = CRM_Core_PseudoConstant::getLabel('CRM_Contribute_BAO_Contribution', 'contribution_status_id', $contribution->contribution_status_id);
  if (empty($contribution->total_amount) && (!$contributionStatus)) {
    return [];
  }
  if ($contributionStatus === 'Completed'
    && !empty($contribution->receive_date)
    && substr($contribution->trxn_id, 0, 4) !== 'RFD '
    && substr($contribution->receive_date, 0, 8) === date('Ymd')
  ) {
    // If the current donation was received today do an early return.
    // What we lose in accuracy (perhaps 2 have come in on the same day) we
    // gain in performance.
    return [];
  }
  if (!$contribution->contact_id || !$contribution->total_amount) {
    $contribution->find(TRUE);
  }
  $params = [];

  // The old code used to assume that 'any' insert was the latest. Here we check.
  // We could possibly 'assume' it to be the latest if on the latest day - although in that
  // case we probably lose a get query & gain an 'update' query as the extra fields are likely already
  // updated by the triggers.
  $contactLastDonation = _wmf_civicrm_get_contact_last_donation_data($contribution);
  $extra = wmf_civicrm_get_original_currency_and_amount_from_source($contribution->source, $contribution->total_amount);
  if ($contributionStatus === 'Completed' && substr($contribution->trxn_id, 0, 4) !== 'RFD ') {
    // This is a 'valid' transaction - it's either the latest or no update is required.
    if (strtotime($contactLastDonation['date']) === strtotime($contribution->receive_date)) {
      if (!empty($extra['original_currency']) && $contactLastDonation['currency'] !== CRM_Utils_Array::value('original_currency', $extra)) {
        $params[wmf_civicrm_get_custom_field_name('last_donation_currency')] = $extra['original_currency'];
      }
      if (!empty($extra['original_amount']) && round($contactLastDonation['amount'], 2) !== round(CRM_Utils_Array::value('original_amount', $extra), 2)) {
        $params[wmf_civicrm_get_custom_field_name('last_donation_amount')] = $extra['original_amount'];
      }
      if (round($contactLastDonation['amount_usd'], 2) !== round($contribution->total_amount, 2)) {
        $params[wmf_civicrm_get_custom_field_name('last_donation_usd')] = $contribution->total_amount;
      }
    }
    return $params;
  }

  // We don't have a completed transaction here - probably a refund - time to get the details of the latest & update it.
  // (From back office it could also be pending but we probably don't stand to gain much by special handling pendings as low volume).
  $existing = civicrm_api3('Contribution', 'get', [
    'contribution_status_id' => CRM_Core_PseudoConstant::getKey('CRM_Contribute_BAO_Contribution', 'contribution_status_id', 'Completed'),
    'contact_id' => $contribution->contact_id,
    'options' => ['limit' => 1, 'sort' => 'receive_date DESC'],
    'trxn_id' => ['NOT LIKE' => 'RFD %'],
    'return' => [
      wmf_civicrm_get_custom_field_name('original_currency'),
      wmf_civicrm_get_custom_field_name('original_amount'),
      'total_amount',
    ],
  ]);
  if (!$existing['count']) {
    return $params;
  }
  $latestContribution = $existing['values'][$existing['id']];
  $latestContributionCurrency = CRM_Utils_Array::value(wmf_civicrm_get_custom_field_name('original_currency'), $latestContribution);
  $latestContributionAmount = CRM_Utils_Array::value(wmf_civicrm_get_custom_field_name('original_amount'), $latestContribution);

  if ($latestContributionCurrency !== CRM_Utils_Array::value('original_currency', $extra)) {
    $params[wmf_civicrm_get_custom_field_name('last_donation_currency')] = $latestContributionCurrency;
  }
  if (round($contactLastDonation['amount'], 2) !== round($latestContributionAmount, 2)) {
    $params[wmf_civicrm_get_custom_field_name('last_donation_amount')] = $latestContributionAmount;
  }
  if (round($contactLastDonation['amount_usd'], 2) !== round($latestContribution['total_amount'], 2)) {
    $params[wmf_civicrm_get_custom_field_name('last_donation_usd')] = $latestContribution['total_amount'];
  }
  return $params;
}

/**
 * @param $contribution
 *
 * @return array
 * @throws \CiviCRM_API3_Exception
 */
function _wmf_civicrm_get_contact_last_donation_data(&$contribution) {
  $contactExistingCustomData = civicrm_api3('Contact', 'getsingle', [
    'id' => $contribution->contact_id,
    'return' => [
      wmf_civicrm_get_custom_field_name('last_donation_currency'),
      wmf_civicrm_get_custom_field_name('last_donation_amount'),
      wmf_civicrm_get_custom_field_name('last_donation_date'),
      wmf_civicrm_get_custom_field_name('last_donation_usd'),
    ],
  ]);
  return [
    'amount' => CRM_Utils_Array::value(wmf_civicrm_get_custom_field_name('last_donation_amount'), $contactExistingCustomData),
    'date' => CRM_Utils_Array::value(wmf_civicrm_get_custom_field_name('last_donation_date'), $contactExistingCustomData),
    'amount_usd' => CRM_Utils_Array::value(wmf_civicrm_get_custom_field_name('last_donation_usd'), $contactExistingCustomData),
    'currency' => CRM_Utils_Array::value(wmf_civicrm_get_custom_field_name('last_donation_currency'), $contactExistingCustomData),
  ];
}

/**
 * Implements hook_alterLogTables().
 *
 * @param array $logTableSpec
 */
function wmf_civicrm_civicrm_alterLogTables(&$logTableSpec) {
  $logTableSpec['wmf_contribution_extra'] = [];
  $contactReferences = CRM_Dedupe_Merger::cidRefs();
  foreach (array_keys($logTableSpec) as $tableName) {
    $contactIndexes = [];
    $logTableSpec[$tableName]['engine'] = 'INNODB';
    $logTableSpec[$tableName]['engine_config'] = 'ROW_FORMAT=COMPRESSED KEY_BLOCK_SIZE=4';
    $contactRefsForTable = CRM_Utils_Array::value($tableName, $contactReferences, []);
    foreach ($contactRefsForTable as $fieldName) {
      $contactIndexes['index_' . $fieldName] = $fieldName;
    }
    $logTableSpec[$tableName]['indexes'] = array_merge([
      'index_id' => 'id',
      'index_log_conn_id' => 'log_conn_id',
      'index_log_date' => 'log_date',
    ], $contactIndexes);
  }

  // Exclude from logging tables to save disk given low value.
  $tablesNotToLog = [
    // financial tables that don't add much to forensics
    'civicrm_entity_financial_trxn',
    'civicrm_financial_item',
    'civicrm_financial_trxn',
    'civicrm_line_item',
    // our queues are not the primary source for these silverpop based tables (and there is a log of data)
    'civicrm_mailing',
    'civicrm_mailing_provider_data',
    // this table is not important because we don't send from civi / need to link back
    // mailing events within civi.
    'civicrm_mailing_job',
    // this table logs group membership & largely repeats log_civicrm_group_contact.
    'civicrm_subscription_history',
    // wmf_donor contains calculated data only.
    'wmf_donor',
  ];
  foreach ($tablesNotToLog  as $noLoggingTable) {
    if (isset($logTableSpec[$noLoggingTable])) {
      unset($logTableSpec[$noLoggingTable]);
    }
  }

}

/**
 * Get a grip on multiple database connections.
 *
 * @return db_switcher
 */
function wmf_civicrm_get_dbs() {
  return new db_switcher();
}

/**
 * Expand CiviCRM DAO results object into an array of rows as array
 *
 * @param $dao CRM_Core_DAO
 *
 * @return array
 * @throws \Exception
 */
function wmf_civicrm_dao_to_list($dao) {
  if (PEAR::isError($dao)) {
    throw new Exception($dao->getMessage());
  }
  $result = [];
  while ($dao->fetch()) {
    $result[] = $dao->toArray();
  }
  // FIXME: pick wart
  if (empty($result)) {
    return FALSE;
  }
  return $result;
}

/**
 * Get javascript to add to contribution page to reduce data-entry issues on thank yous.
 *
 * Our rules are
 *  1) We send out thank you emails in our thank you job unless there is a value in the no-thank-you reason field.
 *  2) For online donations we almost always leave this blank (regular recurring being an exception).
 *  3) For manually entered emails we default to setting a value so thank-yous do NOT go out.
 *  4a) For donor advised emails we want to default to sending when Engage enters these. Clearing out the value from no-thank-you reason addresses this.
 *  4b) For Stock gift emails we want to default to sending. Clearing out the value from no-thank-you reason addresses this.
 *  5) The thank you mailer sends to contacts who have a primary email (it does not respect on hold &
 *   if this is an issue we should raise a phab to consider).
 *  6) MG suggested we also should set no-thank-you-reason when there is no email. In fact an email couldn't go out, but I have respected
 *   this suggestion as adding an email feels like it might unexpectedly cause an email to go out - although by default
 *   I think the thank you job doesn't delve too far back.
 *
 * In order to implement we have a php hook that sets the default for no-thank-you reason to 'Manually Entered' (suppressing the email).
 * The javascript injected from this function adds change events to 3 fields
 *   1) The gift source field - if this is changed to Donor Advised Fund it will check if the contact has a primary email (see
 *      above note about on_hold) and if so it will clear out the no-thank-you-reason field (meaning a thank you will go out).
 *   2) The financial type field - if this is changed to Stock it will check if the contact has a primary email (see
 *      above note about on_hold) and if so it will clear out the no-thank-you-reason field (meaning a thank you will go out).
 *   3) The no-thank-you-reason field. Changes to this field will add text near the submit buttons indicating whether or not
 *      a mail would go out. I didn't want to get into mucking around on what to do if the gift source field was changed
 *      and changed again - so I opted to try to give a visual queue as to what to expect. I'm also mindful I consider this
 *      js method to be a bit hacky & non-robust so hopefully they would notice there NOT being a visual queue if it stops
 *      working. Note the change happens when they click out of the field - I think that might be unintuitive while testing but
 *      should be fine in a data entry flow.
 *
 * Preferred solution? Use the afform functionality to create a cut down targetted form for Engage to do their data entry.
 *
 * Bug: T233374/T259173
 *
 * @param string $no_thank_you_reason_field_name
 * @param string $no_thank_you_toggle_form_elements
 *
 * @return string $js
 */
function wmf_civicrm_get_no_thankyou_js(string $no_thank_you_reason_field_name, array $no_thank_you_toggle_form_elements) {
  $element_selectors = '';
  foreach($no_thank_you_toggle_form_elements as $el) {
    $element_selectors .= "#{$el},";
  }
  $element_selectors = substr($element_selectors,0,-1);
  $js =  "
    if (!cj('.wmf-email-text').length) {
      cj('.crm-submit-buttons').append('<div class=\'wmf-email-text\'>No thank-you email will be sent unless you clear the no thank-you reason field</div>');
    }
    cj('#{$no_thank_you_reason_field_name}').change(function() {
      if (cj('#{$no_thank_you_reason_field_name}').val().length) {
        cj('.wmf-email-text').text('No thank-you email will be sent');
      }
      else {
       CRM.api4('Email', 'get', {
          select: ['email'],
          where: [['contact_id', '=', CRM.vars.coreForm.contact_id], ['is_primary', '=', 1]]
        }).then(function(email) {
          if (email.length === 0) {
           cj('#{$no_thank_you_reason_field_name}').val('No available email').trigger('change');
          }
          else {
            cj('.wmf-email-text').text('A thank-you email will be sent');
          }
        })
      }
    });
    cj('$element_selectors').change(function() {
      if (cj('option:selected',this).text() === 'Donor Advised Fund'
      || cj('option:selected',this).text() === 'Stock' ) {
        cj('#{$no_thank_you_reason_field_name}').val('').trigger('change');
      }
    })";

  return $js;
}

/**
 * Additional validations for the contribution form
 *
 * @param array $fields
 * @param CRM_Core_Form $form
 *
 * @return array of any errors in the form
 * @throws \CiviCRM_API3_Exception
 * @throws \WmfException
 */
function wmf_civicrm_validate_contribution($fields, $form): array {
  $errors = [];

  // Only run on add or update
  if (!($form->_action & (CRM_Core_Action::UPDATE | CRM_Core_Action::ADD))) {
    return $errors;
  }
  // Source has to be of the form USD 15.25 so as not to gum up the works,
  // and the currency code on the front should be something we understand
  $source = $fields['source'];
  if (preg_match('/^([a-z]{3}) [0-9]+(\.[0-9]+)?$/i', $source, $matches)) {
    $currency = strtoupper($matches[1]);
    if (!wmf_civicrm_is_valid_currency($currency)) {
      $errors['source'] = t('Please set a supported currency code');
    }
  }
  else {
    $errors['source'] = t('Source must be in the format USD 15.25');
  }

  // Only run the following validation for users having the Engage role.
  if (!wmf_civicrm_user_has_role('Engage Direct Mail')) {
    return $errors;
  }

  $engage_contribution_type_id = wmf_civicrm_get_civi_id('financial_type_id', 'Engage');
  if ($fields['financial_type_id'] !== $engage_contribution_type_id) {
    $errors['financial_type_id'] = t("Must use the \"Engage\" contribution type.");
  }

  if (wmf_civicrm_tomorrows_month() === '01') {
    $postmark_field_name = _wmf_civicrm_get_form_custom_field_name('postmark_date');
    // If the receive_date is in Dec or Jan, make sure we have a postmark date,
    // to be generous to donors' tax stuff.
    $date = strptime($fields['receive_date'], "%m/%d/%Y");
    // n.b.: 0-based date spoiler.
    if ($date['tm_mon'] == (12 - 1) || $date['tm_mon'] == (1 - 1)) {
      // And the postmark date is missing
      if ($form->elementExists($postmark_field_name) && !$fields[$postmark_field_name]) {
        $errors[$postmark_field_name] = t("You forgot the postmark date!");
      }
    }
  }

  return $errors;
}

/**
 * Return tomorrow's month number.  Used to tell if today is New Year's Eve or
 * later.
 */
function wmf_civicrm_tomorrows_month() {
  $tomorrow = new DateTime('+1 day');
  $month = gmdate("m", $tomorrow->getTimestamp());
  return $month;
}

/**
 * Return true if the user has this role
 *
 * @param string $role Name of the role
 *
 * @return bool
 */
function wmf_civicrm_user_has_role($role) {
  global $user;

  foreach ($user->roles as $rid => $roleName) {
    if ($role === $roleName) {
      return TRUE;
    }
  }

  return FALSE;
}

/**
 * Recalculates USD amounts of contributions between $start and $end
 * based on exchange rates in our database.  Useful if you spent three months
 * not retrieving the latest exchange rates.
 *
 * @param DateTime $start the date from which to start recalculation
 * @param DateTime $end the cutoff date
 * @param int $batch_size number of contributions to recalculate at once
 *
 * @throws \WmfException
 */
function wmf_civicrm_recalculate_contributions($start, $end, $batch_size = 1000) {
  $api = civicrm_api_classapi();
  $query = "SELECT c.id, c.receive_date, c.total_amount, c.fee_amount,
c.net_amount, e.original_amount, e.original_currency
FROM civicrm_contribution c
JOIN wmf_contribution_extra e on e.entity_id = c.id
WHERE c.receive_date > %1
AND c.receive_date <= %2
AND c.id > %3
AND e.original_currency <> 'USD'
ORDER BY c.id ASC
LIMIT %4";
  $last_id = 0;
  while (TRUE) {
    $dao = CRM_Core_DAO::executeQuery($query, [
      1 => [$start->format('Ymd'), 'Date'],
      2 => [$end->format('Ymd'), 'Date'],
      3 => [$last_id, 'Integer'],
      4 => [$batch_size, 'Integer'],
    ]);
    $batch = wmf_civicrm_dao_to_list($dao);
    if (empty($batch)) {
      break;
    }

    foreach ($batch as $contribution) {
      $id = $contribution['id'];
      $original_amount = $contribution['original_amount'];
      $currency = $contribution['original_currency'];
      $total_amount = $contribution['total_amount'];

      if ($id > $last_id) {
        $last_id = $id;
      }

      if ($original_amount == 0 || $total_amount == 0) {
        watchdog('recalculate_contributions', "Not recalculating contribution $id with zero original or total amount", NULL, WATCHDOG_DEBUG);
        continue;
      }
      if (!preg_match('/^[a-z][a-z][a-z]$/i', $currency)) {
        watchdog('recalculate_contributions', "Not recalculating contribution $id with nonsense currency $currency", NULL, WATCHDOG_DEBUG);
        continue;
      }

      // Approximate rate we originally used so we can correct the fee & net.
      $rate_used = $total_amount / $original_amount;
      try {
        $correct_rate = exchange_rate_convert($currency, 1, wmf_common_date_parse_string($contribution['receive_date']));
      }
      catch (ExchangeRatesException $ex) {
        watchdog('recalculate_contributions', "Not recalculating contribution $id.  Cannot find rate for currency $currency", NULL, WATCHDOG_DEBUG);
        continue;
      }
      $recalculated_total = round($correct_rate * $original_amount, 2);
      $recalculated_fee = round($contribution['fee_amount'] / $rate_used * $correct_rate, 2);
      $recalculated_net = $recalculated_total - $recalculated_fee;

      $params = [
        'id' => $contribution['id'],
        'total_amount' => $recalculated_total,
        'fee_amount' => $recalculated_fee,
        'net_amount' => $recalculated_net,
      ];

      watchdog(
        'recalculate_contributions',
        "Recalculating contribution $id, received on {$contribution['receive_date']}. " .
        "Original_amount: $original_amount, original_currency: $currency, " .
        "old total_amount: $total_amount, old fee_amount: {$contribution['fee_amount']}, " .
        "old net_amount: {$contribution['net_amount']}.  " .
        "New total_amount: $recalculated_total, new fee_amount: $recalculated_fee, " .
        "new net_amount: $recalculated_net.",
        NULL,
        WATCHDOG_DEBUG
      );

      if (!$api->Contribution->Create($params)) {
        throw new WmfException(
          WmfException::UNKNOWN, "Failed to update USD amount of contribution: $id, " . $api->errorMsg()
        );
      }
    }
  }
}

/**
 * Get options for a field.
 *
 * @param string $entity
 * @param string $field
 *
 * @return array
 * @throws \CiviCRM_API3_Exception
 */
function wmf_civicrm_get_options($entity, $field) {
  if (!isset(\Civi::$statics['wmf_civicrm'][$entity][$field])) {
    $options = civicrm_api3($entity, 'getoptions', ['field' => $field]);
    \Civi::$statics['wmf_civicrm'][$entity][$field] = $options['values'];
  }
  return \Civi::$statics['wmf_civicrm'][$entity][$field];
}

/**
 * Determine if a code represents a supported currency. Uses the
 * DonationInterface currency list as a canonical source.
 *
 * @param string $currency should be an ISO 4217 code
 *
 * @return bool true if it's a real currency that we can handle
 */
function wmf_civicrm_is_valid_currency($currency) {
  $all_currencies = array_keys(CurrencyRates::getCurrencyRates());
  return in_array($currency, $all_currencies);
}


/**
 * Implements hook_civicrm_validateForm().
 *
 * @param string $formName
 * @param array $fields
 * @param array $files
 * @param CRM_Core_Form $form
 * @param array $errors
 */
function wmf_civicrm_civicrm_validateForm($formName, &$fields, &$files, &$form, &$errors) {
  if ($formName === 'CRM_Contact_Form_DedupeFind') {
    if (!$fields['limit']) {
      $errors['limit'] = ts('Save the database. Use a limit');
    }
    $ruleGroupID = $form->rgid;
    if ($fields['limit'] > 1 && 'fishing_net' === civicrm_api3('RuleGroup', 'getvalue', ['id' => $ruleGroupID, 'return' => 'name'])) {
      $errors['limit'] = ts('The fishing net rule should only be applied to a single contact');
    }
  }
  if ($formName == 'CRM_Contribute_Form_Contribution') {
    $engageErrors = wmf_civicrm_validate_contribution($fields, $form);
    if (!empty($engageErrors)) {
      $errors = array_merge($errors, $engageErrors);
    }
  }
}

/**
 * Abuse the permissions hook to prevent de-duping without a limit
 *
 * @param string $permission
 * @param bool $granted
 *
 * @return bool
 */
function wmf_civicrm_civicrm_permission_check($permission, &$granted) {
  if ($permission === 'merge duplicate contacts') {
    $action = CRM_Utils_Request::retrieve('action', 'String');
    $path = CRM_Utils_System::currentPath();
    if (
      $path === 'civicrm/contact/dedupefind' &&
      !CRM_Utils_Request::retrieve('limit', 'Integer') &&
      ($action != CRM_Core_Action::PREVIEW)
    ) {
      CRM_Core_Session::setStatus(ts('Not permitted for WMF without a limit - this is a setting (dedupe_default_limit) configured on administer->system settings -> misc'));
      $granted = FALSE;
    }
  }
  return TRUE;
}

/**
 * If the address is an exact match or a subset of the address on the preferred
 * contact or matches the location type of an existing address we want to
 * delete it.
 *
 * @param array $blocks
 * @param array $lowerPriorityLocationBlock
 * @param array $block
 * @param book $isPreferOtherContact
 *   Is the other contact preferred (due to being a more recent donor).
 *
 * @return array
 */
function _wmf_civicrm_is_delete_location_in_favour_of_higher_priority_one($blocks, $block, $lowerPriorityLocationBlock) {
  $lowerPriorityLocationTypeID = $lowerPriorityLocationBlock['location_type_id'];
  unset($lowerPriorityLocationBlock['location_type_id']);
  if ($lowerPriorityLocationTypeID == $block['location_type_id'] ||
    CRM_Dedupe_Merger::locationIsSame($block, $lowerPriorityLocationBlock)
    && (!isset($blocks['update']) || !isset($blocks['update'][$lowerPriorityLocationBlock['id']]))
    && (!isset($blocks['delete']) || !isset($blocks['delete'][$lowerPriorityLocationBlock['id']]))
  ) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Given a line from a drupal watchdog log with an array, reconstruct
 * the keys and values from the mangled print_r variant
 * e.g. [gateway] =&gt; paypal#012    [source_name] =&gt; SmashPig#012
 */
function wmf_civicrm_parse_watchdog_array($logLine) {
  $logLine = str_replace('=&gt;', '=>', $logLine);
  $output = [];
  preg_match_all('/\[([^\]]+)\] => (.*?)#012/', $logLine, $matches);
  foreach ($matches[1] as $index => $key) {
    $output[$key] = $matches[2][$index];
  }
  return $output;
}

/**
 * Flush statically cached option values.
 */
function wmf_civicrm_flush_cached_options() {
  \Civi::$statics['wmf_civicrm'] = [];
}

/**
 * Ensure that our US zip geocoder (only) is enabled.
 */
function wmf_civicrm_ensure_correct_geocoder_enabled() {
  // I'm feeling really sad - our tests won't do the include path properly due to
  // some complex set up issue. Let's try just calling the hook function from here
  // (only used in install & upgrade script).
  $config = CRM_Core_Config::singleton();
  geocoder_civicrm_config($config);
  $geocoders = civicrm_api3('Geocoder', 'get', []);
  foreach ($geocoders['values'] as $geocoder) {
    if ($geocoder['name'] !== 'us_zip_geocoder') {
      civicrm_api3('Geocoder', 'create', [
        'id' => $geocoder['id'],
        'is_active' => 0,
      ]);
    }
    else {
      civicrm_api3('Geocoder', 'create', [
        'id' => $geocoder['id'],
        'is_active' => 1,
      ]);
    }
  }
}

/**
 * Implements hook_civicrm_triggerInfo().
 *
 * Add triggers for our calculated custom fields.
 *
 * Whenever a contribution is updated the fields are re-calculated provided
 * the change is an update, a delete or an update which alters a relevant field
 * (contribution_status_id, receive_date, total_amount, contact_id, currency).
 *
 * All fields in the dataset are recalculated (the performance gain on a 'normal'
 * contact of being more selective was too little to show in testing. On our anonymous contact
 * it was perhaps 100 ms but we don't have many contact with thousands of donations.)
 *
 * The wmf_contribution_extra record is saved after the contribution is inserted
 * so we need to potentially update the fields from that record at that points,
 * with a separate trigger.
 **
 *
 * @throws \CRM_Core_Exception
 * @throws \CiviCRM_API3_Exception
 */
function wmf_civicrm_civicrm_triggerInfo(&$info, $tableName) {
  if (!$tableName || $tableName === 'civicrm_contribution') {
    $fields = $aggregateFieldStrings = [];

    $endowmentFinancialType = CRM_Core_PseudoConstant::getKey('CRM_Contribute_BAO_Contribution', 'financial_type_id', 'Endowment Gift');
    if (!$endowmentFinancialType) {
      throw new CRM_Core_Exception('No endowment gift type');
    }
    for ($year = WMF_MIN_ROLLUP_YEAR; $year <= WMF_MAX_ROLLUP_YEAR; $year++) {
      $nextYear = $year + 1;
      $fields[] = "total_{$year}_{$nextYear}";
      $aggregateFieldStrings[] = "MAX(total_{$year}_{$nextYear}) as total_{$year}_{$nextYear}";
      $fieldSelects[] = "SUM(COALESCE(IF(financial_type_id <> $endowmentFinancialType AND receive_date BETWEEN '{$year}-07-01' AND '{$nextYear}-06-30 23:59:59', c.total_amount, 0),0)) as total_{$year}_{$nextYear}";
      $updates[] = "total_{$year}_{$nextYear} = VALUES(total_{$year}_{$nextYear})";

      $fields[] = "total_{$year}";
      $aggregateFieldStrings[] = "MAX(total_{$year}) as total_{$year}";
      $fieldSelects[] = "SUM(COALESCE(IF(financial_type_id <> $endowmentFinancialType AND receive_date BETWEEN '{$year}-01-01' AND '{$year}-12-31 23:59:59', c.total_amount, 0),0)) as total_{$year}";
      $updates[] = "total_{$year} = VALUES(total_{$year})";

      if ($year >= 2017) {
        if ($year >= 2018) {
          $fields[] = "endowment_total_{$year}_{$nextYear}";
          $aggregateFieldStrings[] = "MAX(endowment_total_{$year}_{$nextYear}) as endowment_total_{$year}_{$nextYear}";
          $fieldSelects[] = "SUM(COALESCE(IF(financial_type_id = $endowmentFinancialType AND receive_date BETWEEN '{$year}-07-01' AND '{$nextYear}-06-30 23:59:59', c.total_amount, 0),0)) as endowment_total_{$year}_{$nextYear}";
          $updates[] = "endowment_total_{$year}_{$nextYear} = VALUES(endowment_total_{$year}_{$nextYear})";

          $fields[] = "endowment_total_{$year}";
          $aggregateFieldStrings[] = "MAX(endowment_total_{$year}) as endowment_total_{$year}";
          $fieldSelects[] = "SUM(COALESCE(IF(financial_type_id = $endowmentFinancialType AND receive_date BETWEEN '{$year}-01-01' AND '{$year}-12-31 23:59:59', c.total_amount, 0),0)) as endowment_total_{$year}";
          $updates[] = "endowment_total_{$year} = VALUES(endowment_total_{$year})";
        }

        $fields[] = "change_{$year}_{$nextYear}";
        $aggregateFieldStrings[] = "MAX(change_{$year}_{$nextYear}) as change_{$year}_{$nextYear}";
        $fieldSelects[] = "
          SUM(COALESCE(IF(financial_type_id <> $endowmentFinancialType AND receive_date BETWEEN '{$nextYear}-01-01' AND '{$nextYear}-12-31 23:59:59', c.total_amount, 0),0))
          - SUM(COALESCE(IF(financial_type_id <> $endowmentFinancialType AND receive_date BETWEEN '{$year}-01-01' AND '{$year}-12-31 23:59:59', c.total_amount, 0),0))
           as change_{$year}_{$nextYear}";
        $updates[] = "change_{$year}_{$nextYear} = VALUES(change_{$year}_{$nextYear})";
      }
    }

    $sql = '
    INSERT INTO wmf_donor (
      entity_id, last_donation_currency, last_donation_amount, last_donation_usd,
      first_donation_usd, date_of_largest_donation,
      largest_donation, endowment_largest_donation, lifetime_including_endowment,
      lifetime_usd_total, endowment_lifetime_usd_total,
      last_donation_date, endowment_last_donation_date, first_donation_date,
      endowment_first_donation_date, number_donations,
      endowment_number_donations, ' . implode(', ', $fields) . '
    )

    SELECT
      NEW.contact_id as entity_id,
       # to honour FULL_GROUP_BY mysql mode we need an aggregate command for each
      # field - even though we know we just want `the value from the subquery`
      # MAX is a safe wrapper for that
      # https://www.percona.com/blog/2019/05/13/solve-query-failures-regarding-only_full_group_by-sql-mode/
      MAX(COALESCE(x.original_currency, latest.currency)) as last_donation_currency,
      MAX(COALESCE(x.original_amount, latest.total_amount, 0)) as last_donation_amount,
      MAX(COALESCE(latest.total_amount, 0)) as last_donation_usd,
      MAX(COALESCE(earliest.total_amount, 0)) as first_donation_usd,
      MAX(largest.receive_date) as date_of_largest_donation,
      MAX(largest_donation) as largest_donation,
      MAX(endowment_largest_donation) as endowment_largest_donation,
      MAX(lifetime_including_endowment) as lifetime_including_endowment,
      MAX(lifetime_usd_total) as lifetime_usd_total,
      MAX(endowment_lifetime_usd_total) as endowment_lifetime_usd_total,
      MAX(last_donation_date) as last_donation_date,
      MAX(endowment_last_donation_date) as endowment_last_donation_date,
      MIN(first_donation_date) as first_donation_date,
      MIN(endowment_first_donation_date) as endowment_first_donation_date,
      MAX(number_donations) as number_donations,
      MAX(endowment_number_donations) as endowment_number_donations,
      ' . implode(',', $aggregateFieldStrings) . "

    FROM (
      SELECT
        MAX(IF(financial_type_id <> $endowmentFinancialType, COALESCE(total_amount, 0), 0)) AS largest_donation,
        MAX(IF(financial_type_id = $endowmentFinancialType, COALESCE(total_amount, 0), 0)) AS endowment_largest_donation,
        SUM(COALESCE(total_amount, 0)) AS lifetime_including_endowment,
        SUM(IF(financial_type_id <> $endowmentFinancialType, COALESCE(total_amount, 0), 0)) AS lifetime_usd_total,
        SUM(IF(financial_type_id = $endowmentFinancialType, COALESCE(total_amount, 0), 0)) AS endowment_lifetime_usd_total,
        MAX(IF(financial_type_id <> $endowmentFinancialType AND total_amount > 0, receive_date, NULL)) AS last_donation_date,
        MAX(IF(financial_type_id = $endowmentFinancialType AND total_amount > 0, receive_date, NULL)) AS endowment_last_donation_date,
        MIN(IF(financial_type_id <> $endowmentFinancialType AND total_amount, receive_date, NULL)) AS first_donation_date,
        MIN(IF(financial_type_id = $endowmentFinancialType AND total_amount > 0, receive_date, NULL)) AS endowment_first_donation_date,
        COUNT(IF(financial_type_id <> $endowmentFinancialType AND total_amount > 0, receive_date, NULL)) AS number_donations,
        COUNT(IF(financial_type_id = $endowmentFinancialType AND total_amount > 0, receive_date, NULL)) AS endowment_number_donations,
     " . implode(',', $fieldSelects) . "
      FROM civicrm_contribution c
      USE INDEX(FK_civicrm_contribution_contact_id)
      WHERE contact_id = NEW.contact_id
        AND contribution_status_id = 1
        AND (c.trxn_id NOT LIKE 'RFD %' OR c.trxn_id IS NULL)
    ) as totals
  LEFT JOIN civicrm_contribution latest
    USE INDEX(FK_civicrm_contribution_contact_id)
    ON latest.contact_id = NEW.contact_id
    AND latest.receive_date = totals.last_donation_date
    AND latest.contribution_status_id = 1
    AND latest.total_amount > 0
    AND (latest.trxn_id NOT LIKE 'RFD %' OR latest.trxn_id IS NULL)
    AND latest.financial_type_id <> $endowmentFinancialType
  LEFT JOIN wmf_contribution_extra x ON x.entity_id = latest.id

  LEFT JOIN civicrm_contribution earliest
    USE INDEX(FK_civicrm_contribution_contact_id)
    ON earliest.contact_id = NEW.contact_id
    AND earliest.receive_date = totals.first_donation_date
    AND earliest.contribution_status_id = 1
    AND earliest.total_amount > 0
    AND (earliest.trxn_id NOT LIKE 'RFD %' OR earliest.trxn_id IS NULL)
  LEFT JOIN civicrm_contribution largest
    USE INDEX(FK_civicrm_contribution_contact_id)
    ON largest.contact_id = NEW.contact_id
    AND largest.total_amount = totals.largest_donation
    AND largest.contribution_status_id = 1
    AND largest.total_amount > 0
    AND (largest.trxn_id NOT LIKE 'RFD %' OR largest.trxn_id IS NULL)
  GROUP BY NEW.contact_id

  ON DUPLICATE KEY UPDATE
    last_donation_currency = VALUES(last_donation_currency),
    last_donation_amount = VALUES(last_donation_amount),
    last_donation_usd = VALUES(last_donation_usd),
    first_donation_usd = VALUES(first_donation_usd),
    largest_donation = VALUES(largest_donation),
    date_of_largest_donation = VALUES(date_of_largest_donation),
    lifetime_usd_total = VALUES(lifetime_usd_total),
    last_donation_date = VALUES(last_donation_date),
    first_donation_date = VALUES(first_donation_date),
    number_donations = VALUES(number_donations),
    endowment_largest_donation = VALUES(endowment_largest_donation),
    lifetime_including_endowment = VALUES(lifetime_including_endowment),
    endowment_lifetime_usd_total = VALUES(endowment_lifetime_usd_total),
    endowment_last_donation_date = VALUES(endowment_last_donation_date),
    endowment_first_donation_date = VALUES(endowment_first_donation_date),
    endowment_number_donations = VALUES(endowment_number_donations),
    " . implode(',', $updates) . ";";

    $significantFields = ['contribution_status_id', 'total_amount', 'contact_id', 'receive_date', 'currency', 'financial_type_id'];
    $updateConditions = [];
    foreach ($significantFields as $significantField) {
      $updateConditions[] = "(NEW.{$significantField} != OLD.{$significantField})";
    }

    $requiredClauses = [1];

    $matchingGiftDonors = civicrm_api3('Contact', 'get', ['nick_name' => ['IN' => ['Microsoft', 'Google', 'Apple']]])['values'];
    $excludedContacts = array_keys($matchingGiftDonors);
    $anonymousContact = civicrm_api3('Contact', 'get', [
      'first_name' => 'Anonymous',
      'last_name' => 'Anonymous',
      'options' => ['limit' => 1, 'sort' => 'id ASC'],
    ]);
    if ($anonymousContact['count']) {
      $excludedContacts[] = $anonymousContact['id'];
    }
    if (!empty($excludedContacts)) {
      // On live there will always be an anonymous contact. Check is just for dev instances.
      $requiredClauses[] = '(NEW.contact_id NOT IN (' . implode(',', $excludedContacts) . '))';
    }

    $insertSQL = ' IF ' . implode(' AND ', $requiredClauses) . ' THEN ' . $sql . ' END IF; ';
    $updateSQL = ' IF ' . implode(' AND ', $requiredClauses) . ' AND (' . implode(' OR ', $updateConditions) . ' ) THEN ' . $sql . ' END IF; ';
    $requiredClausesForOldClause = str_replace('NEW.', 'OLD.', implode(' AND ', $requiredClauses));
    $oldSql = str_replace('NEW.', 'OLD.', $sql);
    $updateOldSQL = ' IF ' . $requiredClausesForOldClause
      . ' AND (NEW.contact_id <> OLD.contact_id) THEN '
      . $oldSql . ' END IF; ';

    $deleteSql = ' IF ' . $requiredClausesForOldClause . ' THEN ' . $oldSql . ' END IF; ';


    // We want to fire this trigger on insert, update and delete.
    $info[] = [
      'table' => 'civicrm_contribution',
      'when' => 'AFTER',
      'event' => 'INSERT',
      'sql' => $insertSQL,
    ];
    $info[] = [
      'table' => 'civicrm_contribution',
      'when' => 'AFTER',
      'event' => 'UPDATE',
      'sql' => $updateSQL,
    ];
    $info[] = [
      'table' => 'civicrm_contribution',
      'when' => 'AFTER',
      'event' => 'UPDATE',
      'sql' => $updateOldSQL,
    ];
    // For delete, we reference OLD.field instead of NEW.field
    $info[] = [
      'table' => 'civicrm_contribution',
      'when' => 'AFTER',
      'event' => 'DELETE',
      'sql' => $deleteSql,
    ];
  }

}

/**
 * Intercede in searches to unset 'force' when it appears to be accidentally set.
 *
 * This is a long standing wmf hack & it's not sure when the url would be hit by
 * a user but it can be replicated by accessing
 *
 * /civicrm/contribute/search?force=1&context=search&reset=1
 *
 * When this is working correctly the criteria form not the results will show.
 *
 * Note this is a totally weird place to do this - but seems tobe the only place called
 * before the search is rendered.
 *
 * @param string $objectType
 * @param array $tasks
 *
 * @throws \CRM_Core_Exception
 */
function wmf_civicrm_civicrm_searchTasks($objectType, &$tasks) {
  if (CRM_Utils_Request::retrieve('context', 'String', $form, FALSE, 'search') === 'search'
    && CRM_Utils_Request::retrieve('qfKey', 'String') === NULL
  ) {
    $_GET['force'] = $_REQUEST['force'] = FALSE;
  }
}

/**
 * Get entity tag names.
 *
 * @param int $entity_id
 * @param string $entity_table which table the entity lives in
 *
 * @return array
 * @throws \CiviCRM_API3_Exception
 */
function wmf_civicrm_get_tag_names($entity_id, $entity_table = 'civicrm_contribution') {
  $entityTags = civicrm_api3('EntityTag', 'get', [
    'entity_table' => $entity_table,
    'entity_id' => $entity_id,
  ]);
  if (!isset(\Civi::$statics['wmf_civicrm']['tags'])) {
    \Civi::$statics['wmf_civicrm']['tags'] = civicrm_api3(
      'EntityTag', 'getoptions', ['field' => 'tag_id']
    )['values'];
  }
  $tag_names = [];
  foreach ($entityTags['values'] as $id => $entityTag) {
    $tag_names[] = \Civi::$statics['wmf_civicrm']['tags'][$entityTag['tag_id']];
  }
  return $tag_names;
}

/**
 * @param array $msg
 *
 * @return bool
 */
function wmf_civicrm_is_endowment_gift($msg) {
  return isset($msg['utm_medium']) && $msg['utm_medium'] === 'endowment';
}

/**
 * Get fields for wmf_donor custom group.
 *
 * This is the group with the custom fields for calculated donor data.
 *
 * @return array
 */
function _wmf_civicrm_get_wmf_donor_fields() {
  $fields = [
    'last_donation_date' => [
      'name' => 'last_donation_date',
      'column_name' => 'last_donation_date',
      'label' => ts('Last donation date'),
      'data_type' => 'Date',
      'html_type' => 'Select Date',
      'is_active' => 1,
      'is_searchable' => 1,
      'is_search_range' => 1,
      'is_view' => 1,
      'date_format' => 'M d, yy',
      'time_format' => 2,
    ],
    'endowment_last_donation_date' => [
      'name' => 'endowment_last_donation_date',
      'column_name' => 'endowment_last_donation_date',
      'label' => ts('Endowment Last donation date'),
      'data_type' => 'Date',
      'html_type' => 'Select Date',
      'is_active' => 1,
      'is_searchable' => 1,
      'is_search_range' => 1,
      'is_view' => 1,
      'date_format' => 'M d, yy',
      'time_format' => 2,
    ],
    'first_donation_date' => [
      'name' => 'first_donation_date',
      'column_name' => 'first_donation_date',
      'label' => ts('First donation date'),
      'data_type' => 'Date',
      'html_type' => 'Select Date',
      'is_active' => 1,
      'is_searchable' => 1,
      'is_search_range' => 1,
      'is_view' => 1,
      'date_format' => 'M d, yy',
      'time_format' => 2,
    ],
    'endowment_first_donation_date' => [
      'name' => 'endowment_first_donation_date',
      'column_name' => 'endowment_first_donation_date',
      'label' => ts('Endowment First donation date'),
      'data_type' => 'Date',
      'html_type' => 'Select Date',
      'is_active' => 1,
      'is_searchable' => 1,
      'is_search_range' => 1,
      'is_view' => 1,
      'date_format' => 'M d, yy',
      'time_format' => 2,
    ],
    // Per https://phabricator.wikimedia.org/T222958#5323233
    // This is used in emails - and needs to not mix endowments & non-endowments
    'last_donation_currency' => [
      'name' => 'last_donation_currency',
      'column_name' => 'last_donation_currency',
      'label' => ts('Last Donation Currency'),
      'data_type' => 'String',
      'html_type' => 'Text',
      'is_active' => 1,
      'is_searchable' => 1,
      'is_view' => 1,
    ],
    'last_donation_amount' => [
      'name' => 'last_donation_amount',
      'column_name' => 'last_donation_amount',
      'label' => ts('Last Donation Amount (Original Currency)'),
      'data_type' => 'Money',
      'html_type' => 'Text',
      'is_active' => 1,
      'is_searchable' => 1,
      'is_search_range' => 1,
      'default_value' => 0,
      'is_view' => 1,
    ],
    'first_donation_usd' => [
      'name' => 'first_donation_usd',
      'column_name' => 'first_donation_usd',
      'label' => ts('First Donation Amount (USD)'),
      'data_type' => 'Money',
      'html_type' => 'Text',
      'is_active' => 1,
      'is_searchable' => 1,
      'is_search_range' => 1,
      'default_value' => 0,
      'is_view' => 1,
    ],
    'last_donation_usd' => [
      'name' => 'last_donation_usd',
      'column_name' => 'last_donation_usd',
      'label' => ts('Last Donation Amount (USD)'),
      'data_type' => 'Money',
      'html_type' => 'Text',
      'is_active' => 1,
      'is_searchable' => 1,
      'is_search_range' => 1,
      'default_value' => 0,
      'is_view' => 1,
    ],
    'lifetime_usd_total' => [
      'name' => 'lifetime_usd_total',
      'column_name' => 'lifetime_usd_total',
      'label' => ts('Lifetime Donations (USD)'),
      'data_type' => 'Money',
      'html_type' => 'Text',
      'is_active' => 1,
      'is_searchable' => 1,
      'is_search_range' => 1,
      'default_value' => 0,
      'is_view' => 1,
    ],
    'lifetime_including_endowment' => [
      'name' => 'lifetime_including_endowment',
      'column_name' => 'lifetime_including_endowment',
      'label' => ts('Lifetime Donations (USD) (Incl Endowments)'),
      'data_type' => 'Money',
      'html_type' => 'Text',
      'is_active' => 1,
      'is_searchable' => 1,
      'is_search_range' => 1,
      'default_value' => 0,
      'is_view' => 1,
    ],
    'endowment_lifetime_usd_total' => [
      'name' => 'endowment_lifetime_usd_total',
      'column_name' => 'endowment_lifetime_usd_total',
      'label' => ts('Endowment Lifetime Donations (USD)'),
      'data_type' => 'Money',
      'html_type' => 'Text',
      'is_active' => 1,
      'is_searchable' => 1,
      'is_search_range' => 1,
      'default_value' => 0,
      'is_view' => 1,
    ],
    'number_donations' => [
      'name' => 'number_donations',
      'column_name' => 'number_donations',
      'label' => ts('Number of Donations'),
      'data_type' => 'Int',
      'html_type' => 'Text',
      'is_active' => 1,
      'is_searchable' => 1,
      'is_search_range' => 1,
      'is_view' => 1,
      'default_value' => 0,
    ],
    'endowment_number_donations' => [
      'name' => 'endowment_number_donations',
      'column_name' => 'endowment_number_donations',
      'label' => ts('Endowment Number of Donations'),
      'data_type' => 'Int',
      'html_type' => 'Text',
      'is_active' => 1,
      'is_searchable' => 1,
      'is_search_range' => 1,
      'is_view' => 1,
      'default_value' => 0,
    ],
    'largest_donation' => [
      'name' => 'largest_donation',
      'column_name' => 'largest_donation',
      'label' => ts('Largest Donation'),
      'data_type' => 'Money',
      'html_type' => 'Text',
      'is_active' => 1,
      'is_searchable' => 1,
      'is_search_range' => 1,
      'is_view' => 1,
      'default_value' => 0,
    ],
    'endowment_largest_donation' => [
      'name' => 'endowment_largest_donation',
      'column_name' => 'endowment_largest_donation',
      'label' => ts('Endowment Largest Donation'),
      'data_type' => 'Money',
      'html_type' => 'Text',
      'is_active' => 1,
      'is_searchable' => 1,
      'is_search_range' => 1,
      'is_view' => 1,
      'default_value' => 0,
    ],
    'date_of_largest_donation' => [
      'name' => 'date_of_largest_donation',
      'column_name' => 'date_of_largest_donation',
      'label' => ts('Date of Largest Donation'),
      'data_type' => 'Date',
      'html_type' => 'Select Date',
      'is_active' => 1,
      'is_searchable' => 1,
      'is_search_range' => 1,
      'is_view' => 1,
      'date_format' => 'M d, yy',
      'time_format' => 2,
    ],
  ];

  for ($year = WMF_MIN_ROLLUP_YEAR; $year <= WMF_MAX_ROLLUP_YEAR; $year++) {
    $nextYear = $year + 1;
    $weight = $year > 2018 ? ($year - 2000) : (2019 - $year);
    $fields["total_{$year}_{$nextYear}"] = [
      'name' => "total_{$year}_{$nextYear}",
      'column_name' => "total_{$year}_{$nextYear}",
      'label' => ts("FY {$year}-{$nextYear} total"),
      'data_type' => 'Money',
      'html_type' => 'Text',
      'default_value' => 0,
      'is_active' => 1,
      'is_required' => 0,
      'is_searchable' => 1,
      'is_view' => 1,
      'weight' => $weight,
      'is_search_range' => 1,
    ];
    $fields["total_{$year}"] = [
      'name' => "total_{$year}",
      'column_name' => "total_{$year}",
      'label' => ts("CY {$year} total"),
      'data_type' => 'Money',
      'html_type' => 'Text',
      'default_value' => 0,
      'is_active' => 1,
      'is_required' => 0,
      'is_searchable' => 1,
      'is_view' => 1,
      'weight' => $weight,
      'is_search_range' => 1,
    ];
    if ($year >= 2017) {
      if ($year >= 2018) {
        $fields["endowment_total_{$year}"] = array_merge(
          $fields["total_{$year}"],
          ['name' => "endowment_total_{$year}", 'column_name' => "endowment_total_{$year}", 'label' => 'Endowment ' . ts("CY {$year} total")]
        );
        $fields["endowment_total_{$year}_{$nextYear}"] = array_merge(
          $fields["total_{$year}_{$nextYear}"],
          ['name' => "endowment_total_{$year}_{$nextYear}", 'column_name' => "endowment_total_{$year}_{$nextYear}", 'label' => 'Endowment ' . ts("FY {$year}-{$nextYear} total")]
        );
      }
      $fields["change_{$year}_{$nextYear}"] = [
        'name' => "change_{$year}_{$nextYear}",
        'column_name' => "change_{$year}_{$nextYear}",
        'label' => ts("Change {$year}-{$nextYear} total"),
        'data_type' => 'Float',
        'html_type' => 'Text',
        'default_value' => 0,
        'is_active' => 1,
        'is_required' => 0,
        'is_searchable' => 1,
        'is_view' => 1,
        'weight' => $weight,
        'is_search_range' => 1,
      ];
    }
  }

  return $fields;
}

/**
 * @param string $language
 *
 * @throws \API_Exception
 */
function wmf_civicrm_insert_failure_message_translation($language) {
  $msgHtml = file_get_contents(__DIR__ . '/templates/recurring_failed_message.' . $language . '.html.txt');
  $subject = file_get_contents(__DIR__ . '/templates/recurring_failed_message.' . $language . '.subject.txt');
  $msgText = file_get_contents(__DIR__ . '/templates/recurring_failed_message.' . $language . '.text.txt');
  // It actually stores what we pass it - but we want it to store the same value as on the contact.
  $languageName = \Civi\Api4\OptionValue::get()
    ->setCheckPermissions(FALSE)
    ->addWhere('value', '=', $language)
    ->addSelect('name')->execute()->first()['name'];
  // This should be done by Civi but I hit an error on inserting the Japanese (although
  // this might not be needed as I added table alter statements too.
  CRM_Core_DAO::executeQuery('SET NAMES utf8mb4');

  \Civi\Api4\MessageTemplate::update()->setCheckPermissions(FALSE)
    ->setValues([
      'msg_html' => $msgHtml,
      'subject' => $subject,
      'msg_text' => $msgText,
    ])
    ->addWhere('workflow_name',  '=', 'recurring_failed_message')
    ->setLanguage($languageName)->execute();
}

/**
 * @throws \CiviCRM_API3_Exception
 */
function wmf_civicrm_update_custom_fields() {
  require_once 'update_custom_fields.php';
  _wmf_civicrm_update_custom_fields();
}
